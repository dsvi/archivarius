// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: format.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_format_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_format_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_format_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_format_2eproto {
  static const uint32_t offsets[];
};
namespace proto {
class Catalog_header;
struct Catalog_headerDefaultTypeInternal;
extern Catalog_headerDefaultTypeInternal _Catalog_header_default_instance_;
class Catalogue;
struct CatalogueDefaultTypeInternal;
extern CatalogueDefaultTypeInternal _Catalogue_default_instance_;
class Chacha_Encryption_filter;
struct Chacha_Encryption_filterDefaultTypeInternal;
extern Chacha_Encryption_filterDefaultTypeInternal _Chacha_Encryption_filter_default_instance_;
class Chapoly_Encryption_filter;
struct Chapoly_Encryption_filterDefaultTypeInternal;
extern Chapoly_Encryption_filterDefaultTypeInternal _Chapoly_Encryption_filter_default_instance_;
class Content_file;
struct Content_fileDefaultTypeInternal;
extern Content_fileDefaultTypeInternal _Content_file_default_instance_;
class Filters;
struct FiltersDefaultTypeInternal;
extern FiltersDefaultTypeInternal _Filters_default_instance_;
class Fs_record;
struct Fs_recordDefaultTypeInternal;
extern Fs_recordDefaultTypeInternal _Fs_record_default_instance_;
class Fs_state;
struct Fs_stateDefaultTypeInternal;
extern Fs_stateDefaultTypeInternal _Fs_state_default_instance_;
class Ref_count;
struct Ref_countDefaultTypeInternal;
extern Ref_countDefaultTypeInternal _Ref_count_default_instance_;
class Ref_to_refcount;
struct Ref_to_refcountDefaultTypeInternal;
extern Ref_to_refcountDefaultTypeInternal _Ref_to_refcount_default_instance_;
class State_file;
struct State_fileDefaultTypeInternal;
extern State_fileDefaultTypeInternal _State_file_default_instance_;
class ZSTD_Compression_filter;
struct ZSTD_Compression_filterDefaultTypeInternal;
extern ZSTD_Compression_filterDefaultTypeInternal _ZSTD_Compression_filter_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::Catalog_header* Arena::CreateMaybeMessage<::proto::Catalog_header>(Arena*);
template<> ::proto::Catalogue* Arena::CreateMaybeMessage<::proto::Catalogue>(Arena*);
template<> ::proto::Chacha_Encryption_filter* Arena::CreateMaybeMessage<::proto::Chacha_Encryption_filter>(Arena*);
template<> ::proto::Chapoly_Encryption_filter* Arena::CreateMaybeMessage<::proto::Chapoly_Encryption_filter>(Arena*);
template<> ::proto::Content_file* Arena::CreateMaybeMessage<::proto::Content_file>(Arena*);
template<> ::proto::Filters* Arena::CreateMaybeMessage<::proto::Filters>(Arena*);
template<> ::proto::Fs_record* Arena::CreateMaybeMessage<::proto::Fs_record>(Arena*);
template<> ::proto::Fs_state* Arena::CreateMaybeMessage<::proto::Fs_state>(Arena*);
template<> ::proto::Ref_count* Arena::CreateMaybeMessage<::proto::Ref_count>(Arena*);
template<> ::proto::Ref_to_refcount* Arena::CreateMaybeMessage<::proto::Ref_to_refcount>(Arena*);
template<> ::proto::State_file* Arena::CreateMaybeMessage<::proto::State_file>(Arena*);
template<> ::proto::ZSTD_Compression_filter* Arena::CreateMaybeMessage<::proto::ZSTD_Compression_filter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum File_type : int {
  FILE = 0,
  DIR = 1,
  SYMLINK = 2
};
bool File_type_IsValid(int value);
constexpr File_type File_type_MIN = FILE;
constexpr File_type File_type_MAX = SYMLINK;
constexpr int File_type_ARRAYSIZE = File_type_MAX + 1;

const std::string& File_type_Name(File_type value);
template<typename T>
inline const std::string& File_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, File_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function File_type_Name.");
  return File_type_Name(static_cast<File_type>(enum_t_value));
}
bool File_type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, File_type* value);
// ===================================================================

class ZSTD_Compression_filter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ZSTD_Compression_filter) */ {
 public:
  inline ZSTD_Compression_filter() : ZSTD_Compression_filter(nullptr) {}
  ~ZSTD_Compression_filter() override;
  explicit PROTOBUF_CONSTEXPR ZSTD_Compression_filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZSTD_Compression_filter(const ZSTD_Compression_filter& from);
  ZSTD_Compression_filter(ZSTD_Compression_filter&& from) noexcept
    : ZSTD_Compression_filter() {
    *this = ::std::move(from);
  }

  inline ZSTD_Compression_filter& operator=(const ZSTD_Compression_filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZSTD_Compression_filter& operator=(ZSTD_Compression_filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ZSTD_Compression_filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZSTD_Compression_filter* internal_default_instance() {
    return reinterpret_cast<const ZSTD_Compression_filter*>(
               &_ZSTD_Compression_filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ZSTD_Compression_filter& a, ZSTD_Compression_filter& b) {
    a.Swap(&b);
  }
  inline void Swap(ZSTD_Compression_filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZSTD_Compression_filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZSTD_Compression_filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZSTD_Compression_filter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ZSTD_Compression_filter& from);
  void MergeFrom(const ZSTD_Compression_filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ZSTD_Compression_filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ZSTD_Compression_filter";
  }
  protected:
  explicit ZSTD_Compression_filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.ZSTD_Compression_filter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Chapoly_Encryption_filter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Chapoly_Encryption_filter) */ {
 public:
  inline Chapoly_Encryption_filter() : Chapoly_Encryption_filter(nullptr) {}
  ~Chapoly_Encryption_filter() override;
  explicit PROTOBUF_CONSTEXPR Chapoly_Encryption_filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chapoly_Encryption_filter(const Chapoly_Encryption_filter& from);
  Chapoly_Encryption_filter(Chapoly_Encryption_filter&& from) noexcept
    : Chapoly_Encryption_filter() {
    *this = ::std::move(from);
  }

  inline Chapoly_Encryption_filter& operator=(const Chapoly_Encryption_filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chapoly_Encryption_filter& operator=(Chapoly_Encryption_filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Chapoly_Encryption_filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chapoly_Encryption_filter* internal_default_instance() {
    return reinterpret_cast<const Chapoly_Encryption_filter*>(
               &_Chapoly_Encryption_filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Chapoly_Encryption_filter& a, Chapoly_Encryption_filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Chapoly_Encryption_filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chapoly_Encryption_filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chapoly_Encryption_filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chapoly_Encryption_filter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Chapoly_Encryption_filter& from);
  void MergeFrom(const Chapoly_Encryption_filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Chapoly_Encryption_filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Chapoly_Encryption_filter";
  }
  protected:
  explicit Chapoly_Encryption_filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // required bytes iv = 1;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // optional bytes key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:proto.Chapoly_Encryption_filter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Chacha_Encryption_filter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Chacha_Encryption_filter) */ {
 public:
  inline Chacha_Encryption_filter() : Chacha_Encryption_filter(nullptr) {}
  ~Chacha_Encryption_filter() override;
  explicit PROTOBUF_CONSTEXPR Chacha_Encryption_filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chacha_Encryption_filter(const Chacha_Encryption_filter& from);
  Chacha_Encryption_filter(Chacha_Encryption_filter&& from) noexcept
    : Chacha_Encryption_filter() {
    *this = ::std::move(from);
  }

  inline Chacha_Encryption_filter& operator=(const Chacha_Encryption_filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chacha_Encryption_filter& operator=(Chacha_Encryption_filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Chacha_Encryption_filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chacha_Encryption_filter* internal_default_instance() {
    return reinterpret_cast<const Chacha_Encryption_filter*>(
               &_Chacha_Encryption_filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Chacha_Encryption_filter& a, Chacha_Encryption_filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Chacha_Encryption_filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chacha_Encryption_filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chacha_Encryption_filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chacha_Encryption_filter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Chacha_Encryption_filter& from);
  void MergeFrom(const Chacha_Encryption_filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Chacha_Encryption_filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Chacha_Encryption_filter";
  }
  protected:
  explicit Chacha_Encryption_filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // required bytes iv = 1;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // required bytes key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:proto.Chacha_Encryption_filter)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Filters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Filters) */ {
 public:
  inline Filters() : Filters(nullptr) {}
  ~Filters() override;
  explicit PROTOBUF_CONSTEXPR Filters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filters(const Filters& from);
  Filters(Filters&& from) noexcept
    : Filters() {
    *this = ::std::move(from);
  }

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filters& operator=(Filters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Filters& default_instance() {
    return *internal_default_instance();
  }
  enum EncryptionCase {
    kChapolyEncryption = 2,
    kChachaEncryption = 3,
    ENCRYPTION_NOT_SET = 0,
  };

  static inline const Filters* internal_default_instance() {
    return reinterpret_cast<const Filters*>(
               &_Filters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Filters& a, Filters& b) {
    a.Swap(&b);
  }
  inline void Swap(Filters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Filters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Filters";
  }
  protected:
  explicit Filters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZstdCompressionFieldNumber = 1,
    kChapolyEncryptionFieldNumber = 2,
    kChachaEncryptionFieldNumber = 3,
  };
  // optional .proto.ZSTD_Compression_filter zstd_compression = 1;
  bool has_zstd_compression() const;
  private:
  bool _internal_has_zstd_compression() const;
  public:
  void clear_zstd_compression();
  const ::proto::ZSTD_Compression_filter& zstd_compression() const;
  PROTOBUF_NODISCARD ::proto::ZSTD_Compression_filter* release_zstd_compression();
  ::proto::ZSTD_Compression_filter* mutable_zstd_compression();
  void set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression);
  private:
  const ::proto::ZSTD_Compression_filter& _internal_zstd_compression() const;
  ::proto::ZSTD_Compression_filter* _internal_mutable_zstd_compression();
  public:
  void unsafe_arena_set_allocated_zstd_compression(
      ::proto::ZSTD_Compression_filter* zstd_compression);
  ::proto::ZSTD_Compression_filter* unsafe_arena_release_zstd_compression();

  // .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
  bool has_chapoly_encryption() const;
  private:
  bool _internal_has_chapoly_encryption() const;
  public:
  void clear_chapoly_encryption();
  const ::proto::Chapoly_Encryption_filter& chapoly_encryption() const;
  PROTOBUF_NODISCARD ::proto::Chapoly_Encryption_filter* release_chapoly_encryption();
  ::proto::Chapoly_Encryption_filter* mutable_chapoly_encryption();
  void set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption);
  private:
  const ::proto::Chapoly_Encryption_filter& _internal_chapoly_encryption() const;
  ::proto::Chapoly_Encryption_filter* _internal_mutable_chapoly_encryption();
  public:
  void unsafe_arena_set_allocated_chapoly_encryption(
      ::proto::Chapoly_Encryption_filter* chapoly_encryption);
  ::proto::Chapoly_Encryption_filter* unsafe_arena_release_chapoly_encryption();

  // .proto.Chacha_Encryption_filter chacha_encryption = 3;
  bool has_chacha_encryption() const;
  private:
  bool _internal_has_chacha_encryption() const;
  public:
  void clear_chacha_encryption();
  const ::proto::Chacha_Encryption_filter& chacha_encryption() const;
  PROTOBUF_NODISCARD ::proto::Chacha_Encryption_filter* release_chacha_encryption();
  ::proto::Chacha_Encryption_filter* mutable_chacha_encryption();
  void set_allocated_chacha_encryption(::proto::Chacha_Encryption_filter* chacha_encryption);
  private:
  const ::proto::Chacha_Encryption_filter& _internal_chacha_encryption() const;
  ::proto::Chacha_Encryption_filter* _internal_mutable_chacha_encryption();
  public:
  void unsafe_arena_set_allocated_chacha_encryption(
      ::proto::Chacha_Encryption_filter* chacha_encryption);
  ::proto::Chacha_Encryption_filter* unsafe_arena_release_chacha_encryption();

  void clear_encryption();
  EncryptionCase encryption_case() const;
  // @@protoc_insertion_point(class_scope:proto.Filters)
 private:
  class _Internal;
  void set_has_chapoly_encryption();
  void set_has_chacha_encryption();

  inline bool has_encryption() const;
  inline void clear_has_encryption();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::ZSTD_Compression_filter* zstd_compression_;
  union EncryptionUnion {
    constexpr EncryptionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::proto::Chapoly_Encryption_filter* chapoly_encryption_;
    ::proto::Chacha_Encryption_filter* chacha_encryption_;
  } encryption_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Ref_to_refcount final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_to_refcount) */ {
 public:
  inline Ref_to_refcount() : Ref_to_refcount(nullptr) {}
  ~Ref_to_refcount() override;
  explicit PROTOBUF_CONSTEXPR Ref_to_refcount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ref_to_refcount(const Ref_to_refcount& from);
  Ref_to_refcount(Ref_to_refcount&& from) noexcept
    : Ref_to_refcount() {
    *this = ::std::move(from);
  }

  inline Ref_to_refcount& operator=(const Ref_to_refcount& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ref_to_refcount& operator=(Ref_to_refcount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Ref_to_refcount& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ref_to_refcount* internal_default_instance() {
    return reinterpret_cast<const Ref_to_refcount*>(
               &_Ref_to_refcount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Ref_to_refcount& a, Ref_to_refcount& b) {
    a.Swap(&b);
  }
  inline void Swap(Ref_to_refcount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ref_to_refcount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ref_to_refcount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ref_to_refcount>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Ref_to_refcount& from);
  void MergeFrom(const Ref_to_refcount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_to_refcount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Ref_to_refcount";
  }
  protected:
  explicit Ref_to_refcount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFnameFieldNumber = 1,
    kFromFieldNumber = 2,
  };
  // required string content_fname = 1;
  bool has_content_fname() const;
  private:
  bool _internal_has_content_fname() const;
  public:
  void clear_content_fname();
  const std::string& content_fname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_fname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_fname();
  PROTOBUF_NODISCARD std::string* release_content_fname();
  void set_allocated_content_fname(std::string* content_fname);
  private:
  const std::string& _internal_content_fname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_fname(const std::string& value);
  std::string* _internal_mutable_content_fname();
  public:

  // required uint64 from = 2;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  uint64_t from() const;
  void set_from(uint64_t value);
  private:
  uint64_t _internal_from() const;
  void _internal_set_from(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Ref_to_refcount)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_fname_;
  uint64_t from_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Fs_record final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_record) */ {
 public:
  inline Fs_record() : Fs_record(nullptr) {}
  ~Fs_record() override;
  explicit PROTOBUF_CONSTEXPR Fs_record(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fs_record(const Fs_record& from);
  Fs_record(Fs_record&& from) noexcept
    : Fs_record() {
    *this = ::std::move(from);
  }

  inline Fs_record& operator=(const Fs_record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fs_record& operator=(Fs_record&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fs_record& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fs_record* internal_default_instance() {
    return reinterpret_cast<const Fs_record*>(
               &_Fs_record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Fs_record& a, Fs_record& b) {
    a.Swap(&b);
  }
  inline void Swap(Fs_record* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fs_record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fs_record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fs_record>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fs_record& from);
  void MergeFrom(const Fs_record& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_record* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Fs_record";
  }
  protected:
  explicit Fs_record(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 1,
    kSymlinkTargetFieldNumber = 5,
    kPosixAclFieldNumber = 7,
    kPosixDefaultAclFieldNumber = 8,
    kRefFieldNumber = 4,
    kModifiedNanosecondsFieldNumber = 3,
    kTypeFieldNumber = 2,
    kUnixPermissionsFieldNumber = 6,
  };
  // required string pathname = 1;
  bool has_pathname() const;
  private:
  bool _internal_has_pathname() const;
  public:
  void clear_pathname();
  const std::string& pathname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pathname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pathname();
  PROTOBUF_NODISCARD std::string* release_pathname();
  void set_allocated_pathname(std::string* pathname);
  private:
  const std::string& _internal_pathname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pathname(const std::string& value);
  std::string* _internal_mutable_pathname();
  public:

  // optional string symlink_target = 5;
  bool has_symlink_target() const;
  private:
  bool _internal_has_symlink_target() const;
  public:
  void clear_symlink_target();
  const std::string& symlink_target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symlink_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symlink_target();
  PROTOBUF_NODISCARD std::string* release_symlink_target();
  void set_allocated_symlink_target(std::string* symlink_target);
  private:
  const std::string& _internal_symlink_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symlink_target(const std::string& value);
  std::string* _internal_mutable_symlink_target();
  public:

  // optional string posix_acl = 7;
  bool has_posix_acl() const;
  private:
  bool _internal_has_posix_acl() const;
  public:
  void clear_posix_acl();
  const std::string& posix_acl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_posix_acl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_posix_acl();
  PROTOBUF_NODISCARD std::string* release_posix_acl();
  void set_allocated_posix_acl(std::string* posix_acl);
  private:
  const std::string& _internal_posix_acl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_posix_acl(const std::string& value);
  std::string* _internal_mutable_posix_acl();
  public:

  // optional string posix_default_acl = 8;
  bool has_posix_default_acl() const;
  private:
  bool _internal_has_posix_default_acl() const;
  public:
  void clear_posix_default_acl();
  const std::string& posix_default_acl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_posix_default_acl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_posix_default_acl();
  PROTOBUF_NODISCARD std::string* release_posix_default_acl();
  void set_allocated_posix_default_acl(std::string* posix_default_acl);
  private:
  const std::string& _internal_posix_default_acl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_posix_default_acl(const std::string& value);
  std::string* _internal_mutable_posix_default_acl();
  public:

  // optional .proto.Ref_to_refcount ref = 4;
  bool has_ref() const;
  private:
  bool _internal_has_ref() const;
  public:
  void clear_ref();
  const ::proto::Ref_to_refcount& ref() const;
  PROTOBUF_NODISCARD ::proto::Ref_to_refcount* release_ref();
  ::proto::Ref_to_refcount* mutable_ref();
  void set_allocated_ref(::proto::Ref_to_refcount* ref);
  private:
  const ::proto::Ref_to_refcount& _internal_ref() const;
  ::proto::Ref_to_refcount* _internal_mutable_ref();
  public:
  void unsafe_arena_set_allocated_ref(
      ::proto::Ref_to_refcount* ref);
  ::proto::Ref_to_refcount* unsafe_arena_release_ref();

  // optional uint64 modified_nanoseconds = 3;
  bool has_modified_nanoseconds() const;
  private:
  bool _internal_has_modified_nanoseconds() const;
  public:
  void clear_modified_nanoseconds();
  uint64_t modified_nanoseconds() const;
  void set_modified_nanoseconds(uint64_t value);
  private:
  uint64_t _internal_modified_nanoseconds() const;
  void _internal_set_modified_nanoseconds(uint64_t value);
  public:

  // required .proto.File_type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::proto::File_type type() const;
  void set_type(::proto::File_type value);
  private:
  ::proto::File_type _internal_type() const;
  void _internal_set_type(::proto::File_type value);
  public:

  // optional uint32 unix_permissions = 6;
  bool has_unix_permissions() const;
  private:
  bool _internal_has_unix_permissions() const;
  public:
  void clear_unix_permissions();
  uint32_t unix_permissions() const;
  void set_unix_permissions(uint32_t value);
  private:
  uint32_t _internal_unix_permissions() const;
  void _internal_set_unix_permissions(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Fs_record)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symlink_target_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr posix_acl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr posix_default_acl_;
  ::proto::Ref_to_refcount* ref_;
  uint64_t modified_nanoseconds_;
  int type_;
  uint32_t unix_permissions_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Fs_state final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_state) */ {
 public:
  inline Fs_state() : Fs_state(nullptr) {}
  ~Fs_state() override;
  explicit PROTOBUF_CONSTEXPR Fs_state(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fs_state(const Fs_state& from);
  Fs_state(Fs_state&& from) noexcept
    : Fs_state() {
    *this = ::std::move(from);
  }

  inline Fs_state& operator=(const Fs_state& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fs_state& operator=(Fs_state&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fs_state& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fs_state* internal_default_instance() {
    return reinterpret_cast<const Fs_state*>(
               &_Fs_state_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Fs_state& a, Fs_state& b) {
    a.Swap(&b);
  }
  inline void Swap(Fs_state* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fs_state* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fs_state* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fs_state>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fs_state& from);
  void MergeFrom(const Fs_state& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_state* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Fs_state";
  }
  protected:
  explicit Fs_state(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecFieldNumber = 1,
  };
  // repeated .proto.Fs_record rec = 1;
  int rec_size() const;
  private:
  int _internal_rec_size() const;
  public:
  void clear_rec();
  ::proto::Fs_record* mutable_rec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record >*
      mutable_rec();
  private:
  const ::proto::Fs_record& _internal_rec(int index) const;
  ::proto::Fs_record* _internal_add_rec();
  public:
  const ::proto::Fs_record& rec(int index) const;
  ::proto::Fs_record* add_rec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record >&
      rec() const;

  // @@protoc_insertion_point(class_scope:proto.Fs_state)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record > rec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class State_file final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.State_file) */ {
 public:
  inline State_file() : State_file(nullptr) {}
  ~State_file() override;
  explicit PROTOBUF_CONSTEXPR State_file(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  State_file(const State_file& from);
  State_file(State_file&& from) noexcept
    : State_file() {
    *this = ::std::move(from);
  }

  inline State_file& operator=(const State_file& from) {
    CopyFrom(from);
    return *this;
  }
  inline State_file& operator=(State_file&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const State_file& default_instance() {
    return *internal_default_instance();
  }
  static inline const State_file* internal_default_instance() {
    return reinterpret_cast<const State_file*>(
               &_State_file_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(State_file& a, State_file& b) {
    a.Swap(&b);
  }
  inline void Swap(State_file* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State_file* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  State_file* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<State_file>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const State_file& from);
  void MergeFrom(const State_file& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(State_file* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.State_file";
  }
  protected:
  explicit State_file(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kFiltersFieldNumber = 1,
    kTimeCreatedFieldNumber = 3,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  private:
  bool _internal_has_filters() const;
  public:
  void clear_filters();
  const ::proto::Filters& filters() const;
  PROTOBUF_NODISCARD ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  private:
  const ::proto::Filters& _internal_filters() const;
  ::proto::Filters* _internal_mutable_filters();
  public:
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // required uint64 time_created = 3;
  bool has_time_created() const;
  private:
  bool _internal_has_time_created() const;
  public:
  void clear_time_created();
  uint64_t time_created() const;
  void set_time_created(uint64_t value);
  private:
  uint64_t _internal_time_created() const;
  void _internal_set_time_created(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.State_file)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::proto::Filters* filters_;
  uint64_t time_created_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Content_file final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Content_file) */ {
 public:
  inline Content_file() : Content_file(nullptr) {}
  ~Content_file() override;
  explicit PROTOBUF_CONSTEXPR Content_file(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Content_file(const Content_file& from);
  Content_file(Content_file&& from) noexcept
    : Content_file() {
    *this = ::std::move(from);
  }

  inline Content_file& operator=(const Content_file& from) {
    CopyFrom(from);
    return *this;
  }
  inline Content_file& operator=(Content_file&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Content_file& default_instance() {
    return *internal_default_instance();
  }
  static inline const Content_file* internal_default_instance() {
    return reinterpret_cast<const Content_file*>(
               &_Content_file_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Content_file& a, Content_file& b) {
    a.Swap(&b);
  }
  inline void Swap(Content_file* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Content_file* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Content_file* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Content_file>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Content_file& from);
  void MergeFrom(const Content_file& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Content_file* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Content_file";
  }
  protected:
  explicit Content_file(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefsFieldNumber = 3,
    kNameFieldNumber = 2,
    kFiltersFieldNumber = 1,
  };
  // repeated .proto.Ref_count refs = 3;
  int refs_size() const;
  private:
  int _internal_refs_size() const;
  public:
  void clear_refs();
  ::proto::Ref_count* mutable_refs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count >*
      mutable_refs();
  private:
  const ::proto::Ref_count& _internal_refs(int index) const;
  ::proto::Ref_count* _internal_add_refs();
  public:
  const ::proto::Ref_count& refs(int index) const;
  ::proto::Ref_count* add_refs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count >&
      refs() const;

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  private:
  bool _internal_has_filters() const;
  public:
  void clear_filters();
  const ::proto::Filters& filters() const;
  PROTOBUF_NODISCARD ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  private:
  const ::proto::Filters& _internal_filters() const;
  ::proto::Filters* _internal_mutable_filters();
  public:
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:proto.Content_file)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count > refs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::proto::Filters* filters_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Ref_count final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_count) */ {
 public:
  inline Ref_count() : Ref_count(nullptr) {}
  ~Ref_count() override;
  explicit PROTOBUF_CONSTEXPR Ref_count(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ref_count(const Ref_count& from);
  Ref_count(Ref_count&& from) noexcept
    : Ref_count() {
    *this = ::std::move(from);
  }

  inline Ref_count& operator=(const Ref_count& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ref_count& operator=(Ref_count&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Ref_count& default_instance() {
    return *internal_default_instance();
  }
  enum CsumCase {
    kXxhash = 5,
    kBlake2B = 6,
    CSUM_NOT_SET = 0,
  };

  static inline const Ref_count* internal_default_instance() {
    return reinterpret_cast<const Ref_count*>(
               &_Ref_count_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Ref_count& a, Ref_count& b) {
    a.Swap(&b);
  }
  inline void Swap(Ref_count* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ref_count* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ref_count* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ref_count>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Ref_count& from);
  void MergeFrom(const Ref_count& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_count* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Ref_count";
  }
  protected:
  explicit Ref_count(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kRefCountFieldNumber = 3,
    kSpaceTakenFieldNumber = 4,
    kXxhashFieldNumber = 5,
    kBlake2BFieldNumber = 6,
  };
  // required uint64 from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  uint64_t from() const;
  void set_from(uint64_t value);
  private:
  uint64_t _internal_from() const;
  void _internal_set_from(uint64_t value);
  public:

  // required uint64 to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  uint64_t to() const;
  void set_to(uint64_t value);
  private:
  uint64_t _internal_to() const;
  void _internal_set_to(uint64_t value);
  public:

  // required uint64 ref_count = 3;
  bool has_ref_count() const;
  private:
  bool _internal_has_ref_count() const;
  public:
  void clear_ref_count();
  uint64_t ref_count() const;
  void set_ref_count(uint64_t value);
  private:
  uint64_t _internal_ref_count() const;
  void _internal_set_ref_count(uint64_t value);
  public:

  // required uint64 space_taken = 4;
  bool has_space_taken() const;
  private:
  bool _internal_has_space_taken() const;
  public:
  void clear_space_taken();
  uint64_t space_taken() const;
  void set_space_taken(uint64_t value);
  private:
  uint64_t _internal_space_taken() const;
  void _internal_set_space_taken(uint64_t value);
  public:

  // uint64 xxhash = 5;
  bool has_xxhash() const;
  private:
  bool _internal_has_xxhash() const;
  public:
  void clear_xxhash();
  uint64_t xxhash() const;
  void set_xxhash(uint64_t value);
  private:
  uint64_t _internal_xxhash() const;
  void _internal_set_xxhash(uint64_t value);
  public:

  // bytes blake2b = 6;
  bool has_blake2b() const;
  private:
  bool _internal_has_blake2b() const;
  public:
  void clear_blake2b();
  const std::string& blake2b() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blake2b(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blake2b();
  PROTOBUF_NODISCARD std::string* release_blake2b();
  void set_allocated_blake2b(std::string* blake2b);
  private:
  const std::string& _internal_blake2b() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blake2b(const std::string& value);
  std::string* _internal_mutable_blake2b();
  public:

  void clear_csum();
  CsumCase csum_case() const;
  // @@protoc_insertion_point(class_scope:proto.Ref_count)
 private:
  class _Internal;
  void set_has_xxhash();
  void set_has_blake2b();

  inline bool has_csum() const;
  inline void clear_has_csum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t from_;
  uint64_t to_;
  uint64_t ref_count_;
  uint64_t space_taken_;
  union CsumUnion {
    constexpr CsumUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint64_t xxhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blake2b_;
  } csum_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Catalogue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalogue) */ {
 public:
  inline Catalogue() : Catalogue(nullptr) {}
  ~Catalogue() override;
  explicit PROTOBUF_CONSTEXPR Catalogue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Catalogue(const Catalogue& from);
  Catalogue(Catalogue&& from) noexcept
    : Catalogue() {
    *this = ::std::move(from);
  }

  inline Catalogue& operator=(const Catalogue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Catalogue& operator=(Catalogue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Catalogue& default_instance() {
    return *internal_default_instance();
  }
  static inline const Catalogue* internal_default_instance() {
    return reinterpret_cast<const Catalogue*>(
               &_Catalogue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Catalogue& a, Catalogue& b) {
    a.Swap(&b);
  }
  inline void Swap(Catalogue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Catalogue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Catalogue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Catalogue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Catalogue& from);
  void MergeFrom(const Catalogue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalogue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Catalogue";
  }
  protected:
  explicit Catalogue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFilesFieldNumber = 1,
    kContentFilesFieldNumber = 2,
  };
  // repeated .proto.State_file state_files = 1;
  int state_files_size() const;
  private:
  int _internal_state_files_size() const;
  public:
  void clear_state_files();
  ::proto::State_file* mutable_state_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file >*
      mutable_state_files();
  private:
  const ::proto::State_file& _internal_state_files(int index) const;
  ::proto::State_file* _internal_add_state_files();
  public:
  const ::proto::State_file& state_files(int index) const;
  ::proto::State_file* add_state_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file >&
      state_files() const;

  // repeated .proto.Content_file content_files = 2;
  int content_files_size() const;
  private:
  int _internal_content_files_size() const;
  public:
  void clear_content_files();
  ::proto::Content_file* mutable_content_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file >*
      mutable_content_files();
  private:
  const ::proto::Content_file& _internal_content_files(int index) const;
  ::proto::Content_file* _internal_add_content_files();
  public:
  const ::proto::Content_file& content_files(int index) const;
  ::proto::Content_file* add_content_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file >&
      content_files() const;

  // @@protoc_insertion_point(class_scope:proto.Catalogue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file > state_files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file > content_files_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Catalog_header final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalog_header) */ {
 public:
  inline Catalog_header() : Catalog_header(nullptr) {}
  ~Catalog_header() override;
  explicit PROTOBUF_CONSTEXPR Catalog_header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Catalog_header(const Catalog_header& from);
  Catalog_header(Catalog_header&& from) noexcept
    : Catalog_header() {
    *this = ::std::move(from);
  }

  inline Catalog_header& operator=(const Catalog_header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Catalog_header& operator=(Catalog_header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Catalog_header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Catalog_header* internal_default_instance() {
    return reinterpret_cast<const Catalog_header*>(
               &_Catalog_header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Catalog_header& a, Catalog_header& b) {
    a.Swap(&b);
  }
  inline void Swap(Catalog_header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Catalog_header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Catalog_header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Catalog_header>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Catalog_header& from);
  void MergeFrom(const Catalog_header& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalog_header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Catalog_header";
  }
  protected:
  explicit Catalog_header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  private:
  bool _internal_has_filters() const;
  public:
  void clear_filters();
  const ::proto::Filters& filters() const;
  PROTOBUF_NODISCARD ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  private:
  const ::proto::Filters& _internal_filters() const;
  ::proto::Filters* _internal_mutable_filters();
  public:
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:proto.Catalog_header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::Filters* filters_;
  friend struct ::TableStruct_format_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ZSTD_Compression_filter

// -------------------------------------------------------------------

// Chapoly_Encryption_filter

// required bytes iv = 1;
inline bool Chapoly_Encryption_filter::_internal_has_iv() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Chapoly_Encryption_filter::has_iv() const {
  return _internal_has_iv();
}
inline void Chapoly_Encryption_filter::clear_iv() {
  iv_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Chapoly_Encryption_filter::iv() const {
  // @@protoc_insertion_point(field_get:proto.Chapoly_Encryption_filter.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chapoly_Encryption_filter::set_iv(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Chapoly_Encryption_filter.iv)
}
inline std::string* Chapoly_Encryption_filter::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:proto.Chapoly_Encryption_filter.iv)
  return _s;
}
inline const std::string& Chapoly_Encryption_filter::_internal_iv() const {
  return iv_.Get();
}
inline void Chapoly_Encryption_filter::_internal_set_iv(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  iv_.Set(value, GetArenaForAllocation());
}
inline std::string* Chapoly_Encryption_filter::_internal_mutable_iv() {
  _has_bits_[0] |= 0x00000001u;
  return iv_.Mutable(GetArenaForAllocation());
}
inline std::string* Chapoly_Encryption_filter::release_iv() {
  // @@protoc_insertion_point(field_release:proto.Chapoly_Encryption_filter.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = iv_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iv_.IsDefault()) {
    iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Chapoly_Encryption_filter::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iv_.IsDefault()) {
    iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Chapoly_Encryption_filter.iv)
}

// optional bytes key = 2;
inline bool Chapoly_Encryption_filter::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Chapoly_Encryption_filter::has_key() const {
  return _internal_has_key();
}
inline void Chapoly_Encryption_filter::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Chapoly_Encryption_filter::key() const {
  // @@protoc_insertion_point(field_get:proto.Chapoly_Encryption_filter.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chapoly_Encryption_filter::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Chapoly_Encryption_filter.key)
}
inline std::string* Chapoly_Encryption_filter::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.Chapoly_Encryption_filter.key)
  return _s;
}
inline const std::string& Chapoly_Encryption_filter::_internal_key() const {
  return key_.Get();
}
inline void Chapoly_Encryption_filter::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* Chapoly_Encryption_filter::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000002u;
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* Chapoly_Encryption_filter::release_key() {
  // @@protoc_insertion_point(field_release:proto.Chapoly_Encryption_filter.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Chapoly_Encryption_filter::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Chapoly_Encryption_filter.key)
}

// -------------------------------------------------------------------

// Chacha_Encryption_filter

// required bytes iv = 1;
inline bool Chacha_Encryption_filter::_internal_has_iv() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Chacha_Encryption_filter::has_iv() const {
  return _internal_has_iv();
}
inline void Chacha_Encryption_filter::clear_iv() {
  iv_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Chacha_Encryption_filter::iv() const {
  // @@protoc_insertion_point(field_get:proto.Chacha_Encryption_filter.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chacha_Encryption_filter::set_iv(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Chacha_Encryption_filter.iv)
}
inline std::string* Chacha_Encryption_filter::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:proto.Chacha_Encryption_filter.iv)
  return _s;
}
inline const std::string& Chacha_Encryption_filter::_internal_iv() const {
  return iv_.Get();
}
inline void Chacha_Encryption_filter::_internal_set_iv(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  iv_.Set(value, GetArenaForAllocation());
}
inline std::string* Chacha_Encryption_filter::_internal_mutable_iv() {
  _has_bits_[0] |= 0x00000001u;
  return iv_.Mutable(GetArenaForAllocation());
}
inline std::string* Chacha_Encryption_filter::release_iv() {
  // @@protoc_insertion_point(field_release:proto.Chacha_Encryption_filter.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = iv_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iv_.IsDefault()) {
    iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Chacha_Encryption_filter::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iv_.IsDefault()) {
    iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Chacha_Encryption_filter.iv)
}

// required bytes key = 2;
inline bool Chacha_Encryption_filter::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Chacha_Encryption_filter::has_key() const {
  return _internal_has_key();
}
inline void Chacha_Encryption_filter::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Chacha_Encryption_filter::key() const {
  // @@protoc_insertion_point(field_get:proto.Chacha_Encryption_filter.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chacha_Encryption_filter::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Chacha_Encryption_filter.key)
}
inline std::string* Chacha_Encryption_filter::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.Chacha_Encryption_filter.key)
  return _s;
}
inline const std::string& Chacha_Encryption_filter::_internal_key() const {
  return key_.Get();
}
inline void Chacha_Encryption_filter::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* Chacha_Encryption_filter::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000002u;
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* Chacha_Encryption_filter::release_key() {
  // @@protoc_insertion_point(field_release:proto.Chacha_Encryption_filter.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Chacha_Encryption_filter::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Chacha_Encryption_filter.key)
}

// -------------------------------------------------------------------

// Filters

// optional .proto.ZSTD_Compression_filter zstd_compression = 1;
inline bool Filters::_internal_has_zstd_compression() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || zstd_compression_ != nullptr);
  return value;
}
inline bool Filters::has_zstd_compression() const {
  return _internal_has_zstd_compression();
}
inline void Filters::clear_zstd_compression() {
  if (zstd_compression_ != nullptr) zstd_compression_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::ZSTD_Compression_filter& Filters::_internal_zstd_compression() const {
  const ::proto::ZSTD_Compression_filter* p = zstd_compression_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ZSTD_Compression_filter&>(
      ::proto::_ZSTD_Compression_filter_default_instance_);
}
inline const ::proto::ZSTD_Compression_filter& Filters::zstd_compression() const {
  // @@protoc_insertion_point(field_get:proto.Filters.zstd_compression)
  return _internal_zstd_compression();
}
inline void Filters::unsafe_arena_set_allocated_zstd_compression(
    ::proto::ZSTD_Compression_filter* zstd_compression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zstd_compression_);
  }
  zstd_compression_ = zstd_compression;
  if (zstd_compression) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Filters.zstd_compression)
}
inline ::proto::ZSTD_Compression_filter* Filters::release_zstd_compression() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::ZSTD_Compression_filter* temp = zstd_compression_;
  zstd_compression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ZSTD_Compression_filter* Filters::unsafe_arena_release_zstd_compression() {
  // @@protoc_insertion_point(field_release:proto.Filters.zstd_compression)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::ZSTD_Compression_filter* temp = zstd_compression_;
  zstd_compression_ = nullptr;
  return temp;
}
inline ::proto::ZSTD_Compression_filter* Filters::_internal_mutable_zstd_compression() {
  _has_bits_[0] |= 0x00000001u;
  if (zstd_compression_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ZSTD_Compression_filter>(GetArenaForAllocation());
    zstd_compression_ = p;
  }
  return zstd_compression_;
}
inline ::proto::ZSTD_Compression_filter* Filters::mutable_zstd_compression() {
  ::proto::ZSTD_Compression_filter* _msg = _internal_mutable_zstd_compression();
  // @@protoc_insertion_point(field_mutable:proto.Filters.zstd_compression)
  return _msg;
}
inline void Filters::set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete zstd_compression_;
  }
  if (zstd_compression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(zstd_compression);
    if (message_arena != submessage_arena) {
      zstd_compression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zstd_compression, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  zstd_compression_ = zstd_compression;
  // @@protoc_insertion_point(field_set_allocated:proto.Filters.zstd_compression)
}

// .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
inline bool Filters::_internal_has_chapoly_encryption() const {
  return encryption_case() == kChapolyEncryption;
}
inline bool Filters::has_chapoly_encryption() const {
  return _internal_has_chapoly_encryption();
}
inline void Filters::set_has_chapoly_encryption() {
  _oneof_case_[0] = kChapolyEncryption;
}
inline void Filters::clear_chapoly_encryption() {
  if (_internal_has_chapoly_encryption()) {
    if (GetArenaForAllocation() == nullptr) {
      delete encryption_.chapoly_encryption_;
    }
    clear_has_encryption();
  }
}
inline ::proto::Chapoly_Encryption_filter* Filters::release_chapoly_encryption() {
  // @@protoc_insertion_point(field_release:proto.Filters.chapoly_encryption)
  if (_internal_has_chapoly_encryption()) {
    clear_has_encryption();
    ::proto::Chapoly_Encryption_filter* temp = encryption_.chapoly_encryption_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    encryption_.chapoly_encryption_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::Chapoly_Encryption_filter& Filters::_internal_chapoly_encryption() const {
  return _internal_has_chapoly_encryption()
      ? *encryption_.chapoly_encryption_
      : reinterpret_cast< ::proto::Chapoly_Encryption_filter&>(::proto::_Chapoly_Encryption_filter_default_instance_);
}
inline const ::proto::Chapoly_Encryption_filter& Filters::chapoly_encryption() const {
  // @@protoc_insertion_point(field_get:proto.Filters.chapoly_encryption)
  return _internal_chapoly_encryption();
}
inline ::proto::Chapoly_Encryption_filter* Filters::unsafe_arena_release_chapoly_encryption() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Filters.chapoly_encryption)
  if (_internal_has_chapoly_encryption()) {
    clear_has_encryption();
    ::proto::Chapoly_Encryption_filter* temp = encryption_.chapoly_encryption_;
    encryption_.chapoly_encryption_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filters::unsafe_arena_set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption) {
  clear_encryption();
  if (chapoly_encryption) {
    set_has_chapoly_encryption();
    encryption_.chapoly_encryption_ = chapoly_encryption;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Filters.chapoly_encryption)
}
inline ::proto::Chapoly_Encryption_filter* Filters::_internal_mutable_chapoly_encryption() {
  if (!_internal_has_chapoly_encryption()) {
    clear_encryption();
    set_has_chapoly_encryption();
    encryption_.chapoly_encryption_ = CreateMaybeMessage< ::proto::Chapoly_Encryption_filter >(GetArenaForAllocation());
  }
  return encryption_.chapoly_encryption_;
}
inline ::proto::Chapoly_Encryption_filter* Filters::mutable_chapoly_encryption() {
  ::proto::Chapoly_Encryption_filter* _msg = _internal_mutable_chapoly_encryption();
  // @@protoc_insertion_point(field_mutable:proto.Filters.chapoly_encryption)
  return _msg;
}

// .proto.Chacha_Encryption_filter chacha_encryption = 3;
inline bool Filters::_internal_has_chacha_encryption() const {
  return encryption_case() == kChachaEncryption;
}
inline bool Filters::has_chacha_encryption() const {
  return _internal_has_chacha_encryption();
}
inline void Filters::set_has_chacha_encryption() {
  _oneof_case_[0] = kChachaEncryption;
}
inline void Filters::clear_chacha_encryption() {
  if (_internal_has_chacha_encryption()) {
    if (GetArenaForAllocation() == nullptr) {
      delete encryption_.chacha_encryption_;
    }
    clear_has_encryption();
  }
}
inline ::proto::Chacha_Encryption_filter* Filters::release_chacha_encryption() {
  // @@protoc_insertion_point(field_release:proto.Filters.chacha_encryption)
  if (_internal_has_chacha_encryption()) {
    clear_has_encryption();
    ::proto::Chacha_Encryption_filter* temp = encryption_.chacha_encryption_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    encryption_.chacha_encryption_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::Chacha_Encryption_filter& Filters::_internal_chacha_encryption() const {
  return _internal_has_chacha_encryption()
      ? *encryption_.chacha_encryption_
      : reinterpret_cast< ::proto::Chacha_Encryption_filter&>(::proto::_Chacha_Encryption_filter_default_instance_);
}
inline const ::proto::Chacha_Encryption_filter& Filters::chacha_encryption() const {
  // @@protoc_insertion_point(field_get:proto.Filters.chacha_encryption)
  return _internal_chacha_encryption();
}
inline ::proto::Chacha_Encryption_filter* Filters::unsafe_arena_release_chacha_encryption() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Filters.chacha_encryption)
  if (_internal_has_chacha_encryption()) {
    clear_has_encryption();
    ::proto::Chacha_Encryption_filter* temp = encryption_.chacha_encryption_;
    encryption_.chacha_encryption_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filters::unsafe_arena_set_allocated_chacha_encryption(::proto::Chacha_Encryption_filter* chacha_encryption) {
  clear_encryption();
  if (chacha_encryption) {
    set_has_chacha_encryption();
    encryption_.chacha_encryption_ = chacha_encryption;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Filters.chacha_encryption)
}
inline ::proto::Chacha_Encryption_filter* Filters::_internal_mutable_chacha_encryption() {
  if (!_internal_has_chacha_encryption()) {
    clear_encryption();
    set_has_chacha_encryption();
    encryption_.chacha_encryption_ = CreateMaybeMessage< ::proto::Chacha_Encryption_filter >(GetArenaForAllocation());
  }
  return encryption_.chacha_encryption_;
}
inline ::proto::Chacha_Encryption_filter* Filters::mutable_chacha_encryption() {
  ::proto::Chacha_Encryption_filter* _msg = _internal_mutable_chacha_encryption();
  // @@protoc_insertion_point(field_mutable:proto.Filters.chacha_encryption)
  return _msg;
}

inline bool Filters::has_encryption() const {
  return encryption_case() != ENCRYPTION_NOT_SET;
}
inline void Filters::clear_has_encryption() {
  _oneof_case_[0] = ENCRYPTION_NOT_SET;
}
inline Filters::EncryptionCase Filters::encryption_case() const {
  return Filters::EncryptionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ref_to_refcount

// required string content_fname = 1;
inline bool Ref_to_refcount::_internal_has_content_fname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ref_to_refcount::has_content_fname() const {
  return _internal_has_content_fname();
}
inline void Ref_to_refcount::clear_content_fname() {
  content_fname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Ref_to_refcount::content_fname() const {
  // @@protoc_insertion_point(field_get:proto.Ref_to_refcount.content_fname)
  return _internal_content_fname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ref_to_refcount::set_content_fname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 content_fname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Ref_to_refcount.content_fname)
}
inline std::string* Ref_to_refcount::mutable_content_fname() {
  std::string* _s = _internal_mutable_content_fname();
  // @@protoc_insertion_point(field_mutable:proto.Ref_to_refcount.content_fname)
  return _s;
}
inline const std::string& Ref_to_refcount::_internal_content_fname() const {
  return content_fname_.Get();
}
inline void Ref_to_refcount::_internal_set_content_fname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  content_fname_.Set(value, GetArenaForAllocation());
}
inline std::string* Ref_to_refcount::_internal_mutable_content_fname() {
  _has_bits_[0] |= 0x00000001u;
  return content_fname_.Mutable(GetArenaForAllocation());
}
inline std::string* Ref_to_refcount::release_content_fname() {
  // @@protoc_insertion_point(field_release:proto.Ref_to_refcount.content_fname)
  if (!_internal_has_content_fname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = content_fname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_fname_.IsDefault()) {
    content_fname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Ref_to_refcount::set_allocated_content_fname(std::string* content_fname) {
  if (content_fname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_fname_.SetAllocated(content_fname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_fname_.IsDefault()) {
    content_fname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Ref_to_refcount.content_fname)
}

// required uint64 from = 2;
inline bool Ref_to_refcount::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ref_to_refcount::has_from() const {
  return _internal_has_from();
}
inline void Ref_to_refcount::clear_from() {
  from_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Ref_to_refcount::_internal_from() const {
  return from_;
}
inline uint64_t Ref_to_refcount::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_to_refcount.from)
  return _internal_from();
}
inline void Ref_to_refcount::_internal_set_from(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  from_ = value;
}
inline void Ref_to_refcount::set_from(uint64_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.Ref_to_refcount.from)
}

// -------------------------------------------------------------------

// Fs_record

// required string pathname = 1;
inline bool Fs_record::_internal_has_pathname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fs_record::has_pathname() const {
  return _internal_has_pathname();
}
inline void Fs_record::clear_pathname() {
  pathname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fs_record::pathname() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.pathname)
  return _internal_pathname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fs_record::set_pathname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pathname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Fs_record.pathname)
}
inline std::string* Fs_record::mutable_pathname() {
  std::string* _s = _internal_mutable_pathname();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.pathname)
  return _s;
}
inline const std::string& Fs_record::_internal_pathname() const {
  return pathname_.Get();
}
inline void Fs_record::_internal_set_pathname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pathname_.Set(value, GetArenaForAllocation());
}
inline std::string* Fs_record::_internal_mutable_pathname() {
  _has_bits_[0] |= 0x00000001u;
  return pathname_.Mutable(GetArenaForAllocation());
}
inline std::string* Fs_record::release_pathname() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.pathname)
  if (!_internal_has_pathname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = pathname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pathname_.IsDefault()) {
    pathname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fs_record::set_allocated_pathname(std::string* pathname) {
  if (pathname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pathname_.SetAllocated(pathname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pathname_.IsDefault()) {
    pathname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.pathname)
}

// required .proto.File_type type = 2;
inline bool Fs_record::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Fs_record::has_type() const {
  return _internal_has_type();
}
inline void Fs_record::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::proto::File_type Fs_record::_internal_type() const {
  return static_cast< ::proto::File_type >(type_);
}
inline ::proto::File_type Fs_record::type() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.type)
  return _internal_type();
}
inline void Fs_record::_internal_set_type(::proto::File_type value) {
  assert(::proto::File_type_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
}
inline void Fs_record::set_type(::proto::File_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.type)
}

// optional uint64 modified_nanoseconds = 3;
inline bool Fs_record::_internal_has_modified_nanoseconds() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Fs_record::has_modified_nanoseconds() const {
  return _internal_has_modified_nanoseconds();
}
inline void Fs_record::clear_modified_nanoseconds() {
  modified_nanoseconds_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t Fs_record::_internal_modified_nanoseconds() const {
  return modified_nanoseconds_;
}
inline uint64_t Fs_record::modified_nanoseconds() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.modified_nanoseconds)
  return _internal_modified_nanoseconds();
}
inline void Fs_record::_internal_set_modified_nanoseconds(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  modified_nanoseconds_ = value;
}
inline void Fs_record::set_modified_nanoseconds(uint64_t value) {
  _internal_set_modified_nanoseconds(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.modified_nanoseconds)
}

// optional .proto.Ref_to_refcount ref = 4;
inline bool Fs_record::_internal_has_ref() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || ref_ != nullptr);
  return value;
}
inline bool Fs_record::has_ref() const {
  return _internal_has_ref();
}
inline void Fs_record::clear_ref() {
  if (ref_ != nullptr) ref_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::proto::Ref_to_refcount& Fs_record::_internal_ref() const {
  const ::proto::Ref_to_refcount* p = ref_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Ref_to_refcount&>(
      ::proto::_Ref_to_refcount_default_instance_);
}
inline const ::proto::Ref_to_refcount& Fs_record::ref() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.ref)
  return _internal_ref();
}
inline void Fs_record::unsafe_arena_set_allocated_ref(
    ::proto::Ref_to_refcount* ref) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ref_);
  }
  ref_ = ref;
  if (ref) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.ref)
}
inline ::proto::Ref_to_refcount* Fs_record::release_ref() {
  _has_bits_[0] &= ~0x00000010u;
  ::proto::Ref_to_refcount* temp = ref_;
  ref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Ref_to_refcount* Fs_record::unsafe_arena_release_ref() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.ref)
  _has_bits_[0] &= ~0x00000010u;
  ::proto::Ref_to_refcount* temp = ref_;
  ref_ = nullptr;
  return temp;
}
inline ::proto::Ref_to_refcount* Fs_record::_internal_mutable_ref() {
  _has_bits_[0] |= 0x00000010u;
  if (ref_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Ref_to_refcount>(GetArenaForAllocation());
    ref_ = p;
  }
  return ref_;
}
inline ::proto::Ref_to_refcount* Fs_record::mutable_ref() {
  ::proto::Ref_to_refcount* _msg = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.ref)
  return _msg;
}
inline void Fs_record::set_allocated_ref(::proto::Ref_to_refcount* ref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ref_;
  }
  if (ref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ref);
    if (message_arena != submessage_arena) {
      ref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ref, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ref_ = ref;
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.ref)
}

// optional string symlink_target = 5;
inline bool Fs_record::_internal_has_symlink_target() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fs_record::has_symlink_target() const {
  return _internal_has_symlink_target();
}
inline void Fs_record::clear_symlink_target() {
  symlink_target_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fs_record::symlink_target() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.symlink_target)
  return _internal_symlink_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fs_record::set_symlink_target(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 symlink_target_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Fs_record.symlink_target)
}
inline std::string* Fs_record::mutable_symlink_target() {
  std::string* _s = _internal_mutable_symlink_target();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.symlink_target)
  return _s;
}
inline const std::string& Fs_record::_internal_symlink_target() const {
  return symlink_target_.Get();
}
inline void Fs_record::_internal_set_symlink_target(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  symlink_target_.Set(value, GetArenaForAllocation());
}
inline std::string* Fs_record::_internal_mutable_symlink_target() {
  _has_bits_[0] |= 0x00000002u;
  return symlink_target_.Mutable(GetArenaForAllocation());
}
inline std::string* Fs_record::release_symlink_target() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.symlink_target)
  if (!_internal_has_symlink_target()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = symlink_target_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symlink_target_.IsDefault()) {
    symlink_target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fs_record::set_allocated_symlink_target(std::string* symlink_target) {
  if (symlink_target != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  symlink_target_.SetAllocated(symlink_target, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symlink_target_.IsDefault()) {
    symlink_target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.symlink_target)
}

// optional uint32 unix_permissions = 6;
inline bool Fs_record::_internal_has_unix_permissions() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Fs_record::has_unix_permissions() const {
  return _internal_has_unix_permissions();
}
inline void Fs_record::clear_unix_permissions() {
  unix_permissions_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t Fs_record::_internal_unix_permissions() const {
  return unix_permissions_;
}
inline uint32_t Fs_record::unix_permissions() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.unix_permissions)
  return _internal_unix_permissions();
}
inline void Fs_record::_internal_set_unix_permissions(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  unix_permissions_ = value;
}
inline void Fs_record::set_unix_permissions(uint32_t value) {
  _internal_set_unix_permissions(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.unix_permissions)
}

// optional string posix_acl = 7;
inline bool Fs_record::_internal_has_posix_acl() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fs_record::has_posix_acl() const {
  return _internal_has_posix_acl();
}
inline void Fs_record::clear_posix_acl() {
  posix_acl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fs_record::posix_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_acl)
  return _internal_posix_acl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fs_record::set_posix_acl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 posix_acl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_acl)
}
inline std::string* Fs_record::mutable_posix_acl() {
  std::string* _s = _internal_mutable_posix_acl();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_acl)
  return _s;
}
inline const std::string& Fs_record::_internal_posix_acl() const {
  return posix_acl_.Get();
}
inline void Fs_record::_internal_set_posix_acl(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  posix_acl_.Set(value, GetArenaForAllocation());
}
inline std::string* Fs_record::_internal_mutable_posix_acl() {
  _has_bits_[0] |= 0x00000004u;
  return posix_acl_.Mutable(GetArenaForAllocation());
}
inline std::string* Fs_record::release_posix_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_acl)
  if (!_internal_has_posix_acl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = posix_acl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (posix_acl_.IsDefault()) {
    posix_acl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fs_record::set_allocated_posix_acl(std::string* posix_acl) {
  if (posix_acl != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  posix_acl_.SetAllocated(posix_acl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (posix_acl_.IsDefault()) {
    posix_acl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_acl)
}

// optional string posix_default_acl = 8;
inline bool Fs_record::_internal_has_posix_default_acl() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Fs_record::has_posix_default_acl() const {
  return _internal_has_posix_default_acl();
}
inline void Fs_record::clear_posix_default_acl() {
  posix_default_acl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Fs_record::posix_default_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_default_acl)
  return _internal_posix_default_acl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fs_record::set_posix_default_acl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 posix_default_acl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_default_acl)
}
inline std::string* Fs_record::mutable_posix_default_acl() {
  std::string* _s = _internal_mutable_posix_default_acl();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_default_acl)
  return _s;
}
inline const std::string& Fs_record::_internal_posix_default_acl() const {
  return posix_default_acl_.Get();
}
inline void Fs_record::_internal_set_posix_default_acl(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  posix_default_acl_.Set(value, GetArenaForAllocation());
}
inline std::string* Fs_record::_internal_mutable_posix_default_acl() {
  _has_bits_[0] |= 0x00000008u;
  return posix_default_acl_.Mutable(GetArenaForAllocation());
}
inline std::string* Fs_record::release_posix_default_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_default_acl)
  if (!_internal_has_posix_default_acl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = posix_default_acl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (posix_default_acl_.IsDefault()) {
    posix_default_acl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fs_record::set_allocated_posix_default_acl(std::string* posix_default_acl) {
  if (posix_default_acl != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  posix_default_acl_.SetAllocated(posix_default_acl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (posix_default_acl_.IsDefault()) {
    posix_default_acl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_default_acl)
}

// -------------------------------------------------------------------

// Fs_state

// repeated .proto.Fs_record rec = 1;
inline int Fs_state::_internal_rec_size() const {
  return rec_.size();
}
inline int Fs_state::rec_size() const {
  return _internal_rec_size();
}
inline void Fs_state::clear_rec() {
  rec_.Clear();
}
inline ::proto::Fs_record* Fs_state::mutable_rec(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Fs_state.rec)
  return rec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record >*
Fs_state::mutable_rec() {
  // @@protoc_insertion_point(field_mutable_list:proto.Fs_state.rec)
  return &rec_;
}
inline const ::proto::Fs_record& Fs_state::_internal_rec(int index) const {
  return rec_.Get(index);
}
inline const ::proto::Fs_record& Fs_state::rec(int index) const {
  // @@protoc_insertion_point(field_get:proto.Fs_state.rec)
  return _internal_rec(index);
}
inline ::proto::Fs_record* Fs_state::_internal_add_rec() {
  return rec_.Add();
}
inline ::proto::Fs_record* Fs_state::add_rec() {
  ::proto::Fs_record* _add = _internal_add_rec();
  // @@protoc_insertion_point(field_add:proto.Fs_state.rec)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record >&
Fs_state::rec() const {
  // @@protoc_insertion_point(field_list:proto.Fs_state.rec)
  return rec_;
}

// -------------------------------------------------------------------

// State_file

// optional .proto.Filters filters = 1;
inline bool State_file::_internal_has_filters() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || filters_ != nullptr);
  return value;
}
inline bool State_file::has_filters() const {
  return _internal_has_filters();
}
inline void State_file::clear_filters() {
  if (filters_ != nullptr) filters_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::Filters& State_file::_internal_filters() const {
  const ::proto::Filters* p = filters_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Filters&>(
      ::proto::_Filters_default_instance_);
}
inline const ::proto::Filters& State_file::filters() const {
  // @@protoc_insertion_point(field_get:proto.State_file.filters)
  return _internal_filters();
}
inline void State_file::unsafe_arena_set_allocated_filters(
    ::proto::Filters* filters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filters_);
  }
  filters_ = filters;
  if (filters) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.State_file.filters)
}
inline ::proto::Filters* State_file::release_filters() {
  _has_bits_[0] &= ~0x00000002u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Filters* State_file::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_release:proto.State_file.filters)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
  return temp;
}
inline ::proto::Filters* State_file::_internal_mutable_filters() {
  _has_bits_[0] |= 0x00000002u;
  if (filters_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Filters>(GetArenaForAllocation());
    filters_ = p;
  }
  return filters_;
}
inline ::proto::Filters* State_file::mutable_filters() {
  ::proto::Filters* _msg = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:proto.State_file.filters)
  return _msg;
}
inline void State_file::set_allocated_filters(::proto::Filters* filters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filters_;
  }
  if (filters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.State_file.filters)
}

// required string name = 2;
inline bool State_file::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool State_file::has_name() const {
  return _internal_has_name();
}
inline void State_file::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& State_file::name() const {
  // @@protoc_insertion_point(field_get:proto.State_file.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void State_file::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.State_file.name)
}
inline std::string* State_file::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.State_file.name)
  return _s;
}
inline const std::string& State_file::_internal_name() const {
  return name_.Get();
}
inline void State_file::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* State_file::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* State_file::release_name() {
  // @@protoc_insertion_point(field_release:proto.State_file.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void State_file::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.State_file.name)
}

// required uint64 time_created = 3;
inline bool State_file::_internal_has_time_created() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool State_file::has_time_created() const {
  return _internal_has_time_created();
}
inline void State_file::clear_time_created() {
  time_created_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t State_file::_internal_time_created() const {
  return time_created_;
}
inline uint64_t State_file::time_created() const {
  // @@protoc_insertion_point(field_get:proto.State_file.time_created)
  return _internal_time_created();
}
inline void State_file::_internal_set_time_created(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  time_created_ = value;
}
inline void State_file::set_time_created(uint64_t value) {
  _internal_set_time_created(value);
  // @@protoc_insertion_point(field_set:proto.State_file.time_created)
}

// -------------------------------------------------------------------

// Content_file

// optional .proto.Filters filters = 1;
inline bool Content_file::_internal_has_filters() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || filters_ != nullptr);
  return value;
}
inline bool Content_file::has_filters() const {
  return _internal_has_filters();
}
inline void Content_file::clear_filters() {
  if (filters_ != nullptr) filters_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::Filters& Content_file::_internal_filters() const {
  const ::proto::Filters* p = filters_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Filters&>(
      ::proto::_Filters_default_instance_);
}
inline const ::proto::Filters& Content_file::filters() const {
  // @@protoc_insertion_point(field_get:proto.Content_file.filters)
  return _internal_filters();
}
inline void Content_file::unsafe_arena_set_allocated_filters(
    ::proto::Filters* filters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filters_);
  }
  filters_ = filters;
  if (filters) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Content_file.filters)
}
inline ::proto::Filters* Content_file::release_filters() {
  _has_bits_[0] &= ~0x00000002u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Filters* Content_file::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_release:proto.Content_file.filters)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
  return temp;
}
inline ::proto::Filters* Content_file::_internal_mutable_filters() {
  _has_bits_[0] |= 0x00000002u;
  if (filters_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Filters>(GetArenaForAllocation());
    filters_ = p;
  }
  return filters_;
}
inline ::proto::Filters* Content_file::mutable_filters() {
  ::proto::Filters* _msg = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:proto.Content_file.filters)
  return _msg;
}
inline void Content_file::set_allocated_filters(::proto::Filters* filters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filters_;
  }
  if (filters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.Content_file.filters)
}

// required string name = 2;
inline bool Content_file::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Content_file::has_name() const {
  return _internal_has_name();
}
inline void Content_file::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Content_file::name() const {
  // @@protoc_insertion_point(field_get:proto.Content_file.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Content_file::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Content_file.name)
}
inline std::string* Content_file::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.Content_file.name)
  return _s;
}
inline const std::string& Content_file::_internal_name() const {
  return name_.Get();
}
inline void Content_file::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Content_file::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Content_file::release_name() {
  // @@protoc_insertion_point(field_release:proto.Content_file.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Content_file::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Content_file.name)
}

// repeated .proto.Ref_count refs = 3;
inline int Content_file::_internal_refs_size() const {
  return refs_.size();
}
inline int Content_file::refs_size() const {
  return _internal_refs_size();
}
inline void Content_file::clear_refs() {
  refs_.Clear();
}
inline ::proto::Ref_count* Content_file::mutable_refs(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Content_file.refs)
  return refs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count >*
Content_file::mutable_refs() {
  // @@protoc_insertion_point(field_mutable_list:proto.Content_file.refs)
  return &refs_;
}
inline const ::proto::Ref_count& Content_file::_internal_refs(int index) const {
  return refs_.Get(index);
}
inline const ::proto::Ref_count& Content_file::refs(int index) const {
  // @@protoc_insertion_point(field_get:proto.Content_file.refs)
  return _internal_refs(index);
}
inline ::proto::Ref_count* Content_file::_internal_add_refs() {
  return refs_.Add();
}
inline ::proto::Ref_count* Content_file::add_refs() {
  ::proto::Ref_count* _add = _internal_add_refs();
  // @@protoc_insertion_point(field_add:proto.Content_file.refs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count >&
Content_file::refs() const {
  // @@protoc_insertion_point(field_list:proto.Content_file.refs)
  return refs_;
}

// -------------------------------------------------------------------

// Ref_count

// required uint64 from = 1;
inline bool Ref_count::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ref_count::has_from() const {
  return _internal_has_from();
}
inline void Ref_count::clear_from() {
  from_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Ref_count::_internal_from() const {
  return from_;
}
inline uint64_t Ref_count::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.from)
  return _internal_from();
}
inline void Ref_count::_internal_set_from(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  from_ = value;
}
inline void Ref_count::set_from(uint64_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.from)
}

// required uint64 to = 2;
inline bool Ref_count::_internal_has_to() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ref_count::has_to() const {
  return _internal_has_to();
}
inline void Ref_count::clear_to() {
  to_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Ref_count::_internal_to() const {
  return to_;
}
inline uint64_t Ref_count::to() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.to)
  return _internal_to();
}
inline void Ref_count::_internal_set_to(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  to_ = value;
}
inline void Ref_count::set_to(uint64_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.to)
}

// required uint64 ref_count = 3;
inline bool Ref_count::_internal_has_ref_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Ref_count::has_ref_count() const {
  return _internal_has_ref_count();
}
inline void Ref_count::clear_ref_count() {
  ref_count_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Ref_count::_internal_ref_count() const {
  return ref_count_;
}
inline uint64_t Ref_count::ref_count() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.ref_count)
  return _internal_ref_count();
}
inline void Ref_count::_internal_set_ref_count(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  ref_count_ = value;
}
inline void Ref_count::set_ref_count(uint64_t value) {
  _internal_set_ref_count(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.ref_count)
}

// required uint64 space_taken = 4;
inline bool Ref_count::_internal_has_space_taken() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Ref_count::has_space_taken() const {
  return _internal_has_space_taken();
}
inline void Ref_count::clear_space_taken() {
  space_taken_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t Ref_count::_internal_space_taken() const {
  return space_taken_;
}
inline uint64_t Ref_count::space_taken() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.space_taken)
  return _internal_space_taken();
}
inline void Ref_count::_internal_set_space_taken(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  space_taken_ = value;
}
inline void Ref_count::set_space_taken(uint64_t value) {
  _internal_set_space_taken(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.space_taken)
}

// uint64 xxhash = 5;
inline bool Ref_count::_internal_has_xxhash() const {
  return csum_case() == kXxhash;
}
inline bool Ref_count::has_xxhash() const {
  return _internal_has_xxhash();
}
inline void Ref_count::set_has_xxhash() {
  _oneof_case_[0] = kXxhash;
}
inline void Ref_count::clear_xxhash() {
  if (_internal_has_xxhash()) {
    csum_.xxhash_ = uint64_t{0u};
    clear_has_csum();
  }
}
inline uint64_t Ref_count::_internal_xxhash() const {
  if (_internal_has_xxhash()) {
    return csum_.xxhash_;
  }
  return uint64_t{0u};
}
inline void Ref_count::_internal_set_xxhash(uint64_t value) {
  if (!_internal_has_xxhash()) {
    clear_csum();
    set_has_xxhash();
  }
  csum_.xxhash_ = value;
}
inline uint64_t Ref_count::xxhash() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.xxhash)
  return _internal_xxhash();
}
inline void Ref_count::set_xxhash(uint64_t value) {
  _internal_set_xxhash(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.xxhash)
}

// bytes blake2b = 6;
inline bool Ref_count::_internal_has_blake2b() const {
  return csum_case() == kBlake2B;
}
inline bool Ref_count::has_blake2b() const {
  return _internal_has_blake2b();
}
inline void Ref_count::set_has_blake2b() {
  _oneof_case_[0] = kBlake2B;
}
inline void Ref_count::clear_blake2b() {
  if (_internal_has_blake2b()) {
    csum_.blake2b_.Destroy();
    clear_has_csum();
  }
}
inline const std::string& Ref_count::blake2b() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.blake2b)
  return _internal_blake2b();
}
template <typename ArgT0, typename... ArgT>
inline void Ref_count::set_blake2b(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.InitDefault();
  }
  csum_.blake2b_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Ref_count.blake2b)
}
inline std::string* Ref_count::mutable_blake2b() {
  std::string* _s = _internal_mutable_blake2b();
  // @@protoc_insertion_point(field_mutable:proto.Ref_count.blake2b)
  return _s;
}
inline const std::string& Ref_count::_internal_blake2b() const {
  if (_internal_has_blake2b()) {
    return csum_.blake2b_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Ref_count::_internal_set_blake2b(const std::string& value) {
  if (!_internal_has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.InitDefault();
  }
  csum_.blake2b_.Set(value, GetArenaForAllocation());
}
inline std::string* Ref_count::_internal_mutable_blake2b() {
  if (!_internal_has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.InitDefault();
  }
  return csum_.blake2b_.Mutable(      GetArenaForAllocation());
}
inline std::string* Ref_count::release_blake2b() {
  // @@protoc_insertion_point(field_release:proto.Ref_count.blake2b)
  if (_internal_has_blake2b()) {
    clear_has_csum();
    return csum_.blake2b_.Release();
  } else {
    return nullptr;
  }
}
inline void Ref_count::set_allocated_blake2b(std::string* blake2b) {
  if (has_csum()) {
    clear_csum();
  }
  if (blake2b != nullptr) {
    set_has_blake2b();
    csum_.blake2b_.InitAllocated(blake2b, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Ref_count.blake2b)
}

inline bool Ref_count::has_csum() const {
  return csum_case() != CSUM_NOT_SET;
}
inline void Ref_count::clear_has_csum() {
  _oneof_case_[0] = CSUM_NOT_SET;
}
inline Ref_count::CsumCase Ref_count::csum_case() const {
  return Ref_count::CsumCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Catalogue

// repeated .proto.State_file state_files = 1;
inline int Catalogue::_internal_state_files_size() const {
  return state_files_.size();
}
inline int Catalogue::state_files_size() const {
  return _internal_state_files_size();
}
inline void Catalogue::clear_state_files() {
  state_files_.Clear();
}
inline ::proto::State_file* Catalogue::mutable_state_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.state_files)
  return state_files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file >*
Catalogue::mutable_state_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.state_files)
  return &state_files_;
}
inline const ::proto::State_file& Catalogue::_internal_state_files(int index) const {
  return state_files_.Get(index);
}
inline const ::proto::State_file& Catalogue::state_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.state_files)
  return _internal_state_files(index);
}
inline ::proto::State_file* Catalogue::_internal_add_state_files() {
  return state_files_.Add();
}
inline ::proto::State_file* Catalogue::add_state_files() {
  ::proto::State_file* _add = _internal_add_state_files();
  // @@protoc_insertion_point(field_add:proto.Catalogue.state_files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file >&
Catalogue::state_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.state_files)
  return state_files_;
}

// repeated .proto.Content_file content_files = 2;
inline int Catalogue::_internal_content_files_size() const {
  return content_files_.size();
}
inline int Catalogue::content_files_size() const {
  return _internal_content_files_size();
}
inline void Catalogue::clear_content_files() {
  content_files_.Clear();
}
inline ::proto::Content_file* Catalogue::mutable_content_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.content_files)
  return content_files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file >*
Catalogue::mutable_content_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.content_files)
  return &content_files_;
}
inline const ::proto::Content_file& Catalogue::_internal_content_files(int index) const {
  return content_files_.Get(index);
}
inline const ::proto::Content_file& Catalogue::content_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.content_files)
  return _internal_content_files(index);
}
inline ::proto::Content_file* Catalogue::_internal_add_content_files() {
  return content_files_.Add();
}
inline ::proto::Content_file* Catalogue::add_content_files() {
  ::proto::Content_file* _add = _internal_add_content_files();
  // @@protoc_insertion_point(field_add:proto.Catalogue.content_files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file >&
Catalogue::content_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.content_files)
  return content_files_;
}

// -------------------------------------------------------------------

// Catalog_header

// optional .proto.Filters filters = 1;
inline bool Catalog_header::_internal_has_filters() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || filters_ != nullptr);
  return value;
}
inline bool Catalog_header::has_filters() const {
  return _internal_has_filters();
}
inline void Catalog_header::clear_filters() {
  if (filters_ != nullptr) filters_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::Filters& Catalog_header::_internal_filters() const {
  const ::proto::Filters* p = filters_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Filters&>(
      ::proto::_Filters_default_instance_);
}
inline const ::proto::Filters& Catalog_header::filters() const {
  // @@protoc_insertion_point(field_get:proto.Catalog_header.filters)
  return _internal_filters();
}
inline void Catalog_header::unsafe_arena_set_allocated_filters(
    ::proto::Filters* filters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filters_);
  }
  filters_ = filters;
  if (filters) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Catalog_header.filters)
}
inline ::proto::Filters* Catalog_header::release_filters() {
  _has_bits_[0] &= ~0x00000001u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Filters* Catalog_header::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_release:proto.Catalog_header.filters)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
  return temp;
}
inline ::proto::Filters* Catalog_header::_internal_mutable_filters() {
  _has_bits_[0] |= 0x00000001u;
  if (filters_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Filters>(GetArenaForAllocation());
    filters_ = p;
  }
  return filters_;
}
inline ::proto::Filters* Catalog_header::mutable_filters() {
  ::proto::Filters* _msg = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:proto.Catalog_header.filters)
  return _msg;
}
inline void Catalog_header::set_allocated_filters(::proto::Filters* filters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filters_;
  }
  if (filters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.Catalog_header.filters)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::File_type> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_format_2eproto
