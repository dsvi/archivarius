// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: format.proto

#ifndef PROTOBUF_format_2eproto__INCLUDED
#define PROTOBUF_format_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_format_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsZSTD_Compression_filterImpl();
void InitDefaultsZSTD_Compression_filter();
void InitDefaultsChapoly_Encryption_filterImpl();
void InitDefaultsChapoly_Encryption_filter();
void InitDefaultsFiltersImpl();
void InitDefaultsFilters();
void InitDefaultsRef_to_refcountImpl();
void InitDefaultsRef_to_refcount();
void InitDefaultsFs_recordImpl();
void InitDefaultsFs_record();
void InitDefaultsFs_stateImpl();
void InitDefaultsFs_state();
void InitDefaultsState_fileImpl();
void InitDefaultsState_file();
void InitDefaultsContent_fileImpl();
void InitDefaultsContent_file();
void InitDefaultsRef_countImpl();
void InitDefaultsRef_count();
void InitDefaultsCatalogueImpl();
void InitDefaultsCatalogue();
void InitDefaultsCatalog_headerImpl();
void InitDefaultsCatalog_header();
inline void InitDefaults() {
  InitDefaultsZSTD_Compression_filter();
  InitDefaultsChapoly_Encryption_filter();
  InitDefaultsFilters();
  InitDefaultsRef_to_refcount();
  InitDefaultsFs_record();
  InitDefaultsFs_state();
  InitDefaultsState_file();
  InitDefaultsContent_file();
  InitDefaultsRef_count();
  InitDefaultsCatalogue();
  InitDefaultsCatalog_header();
}
}  // namespace protobuf_format_2eproto
namespace proto {
class Catalog_header;
class Catalog_headerDefaultTypeInternal;
extern Catalog_headerDefaultTypeInternal _Catalog_header_default_instance_;
class Catalogue;
class CatalogueDefaultTypeInternal;
extern CatalogueDefaultTypeInternal _Catalogue_default_instance_;
class Chapoly_Encryption_filter;
class Chapoly_Encryption_filterDefaultTypeInternal;
extern Chapoly_Encryption_filterDefaultTypeInternal _Chapoly_Encryption_filter_default_instance_;
class Content_file;
class Content_fileDefaultTypeInternal;
extern Content_fileDefaultTypeInternal _Content_file_default_instance_;
class Filters;
class FiltersDefaultTypeInternal;
extern FiltersDefaultTypeInternal _Filters_default_instance_;
class Fs_record;
class Fs_recordDefaultTypeInternal;
extern Fs_recordDefaultTypeInternal _Fs_record_default_instance_;
class Fs_state;
class Fs_stateDefaultTypeInternal;
extern Fs_stateDefaultTypeInternal _Fs_state_default_instance_;
class Ref_count;
class Ref_countDefaultTypeInternal;
extern Ref_countDefaultTypeInternal _Ref_count_default_instance_;
class Ref_to_refcount;
class Ref_to_refcountDefaultTypeInternal;
extern Ref_to_refcountDefaultTypeInternal _Ref_to_refcount_default_instance_;
class State_file;
class State_fileDefaultTypeInternal;
extern State_fileDefaultTypeInternal _State_file_default_instance_;
class ZSTD_Compression_filter;
class ZSTD_Compression_filterDefaultTypeInternal;
extern ZSTD_Compression_filterDefaultTypeInternal _ZSTD_Compression_filter_default_instance_;
}  // namespace proto
namespace proto {

enum File_type {
  FILE = 0,
  DIR = 1,
  SYMLINK = 2,
  File_type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  File_type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool File_type_IsValid(int value);
const File_type File_type_MIN = FILE;
const File_type File_type_MAX = SYMLINK;
const int File_type_ARRAYSIZE = File_type_MAX + 1;

// ===================================================================

class ZSTD_Compression_filter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ZSTD_Compression_filter) */ {
 public:
  ZSTD_Compression_filter();
  virtual ~ZSTD_Compression_filter();

  ZSTD_Compression_filter(const ZSTD_Compression_filter& from);

  inline ZSTD_Compression_filter& operator=(const ZSTD_Compression_filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ZSTD_Compression_filter(ZSTD_Compression_filter&& from) noexcept
    : ZSTD_Compression_filter() {
    *this = ::std::move(from);
  }

  inline ZSTD_Compression_filter& operator=(ZSTD_Compression_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ZSTD_Compression_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZSTD_Compression_filter* internal_default_instance() {
    return reinterpret_cast<const ZSTD_Compression_filter*>(
               &_ZSTD_Compression_filter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ZSTD_Compression_filter* other);
  friend void swap(ZSTD_Compression_filter& a, ZSTD_Compression_filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ZSTD_Compression_filter* New() const PROTOBUF_FINAL { return New(NULL); }

  ZSTD_Compression_filter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ZSTD_Compression_filter& from);
  void MergeFrom(const ZSTD_Compression_filter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ZSTD_Compression_filter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.ZSTD_Compression_filter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsZSTD_Compression_filterImpl();
};
// -------------------------------------------------------------------

class Chapoly_Encryption_filter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Chapoly_Encryption_filter) */ {
 public:
  Chapoly_Encryption_filter();
  virtual ~Chapoly_Encryption_filter();

  Chapoly_Encryption_filter(const Chapoly_Encryption_filter& from);

  inline Chapoly_Encryption_filter& operator=(const Chapoly_Encryption_filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chapoly_Encryption_filter(Chapoly_Encryption_filter&& from) noexcept
    : Chapoly_Encryption_filter() {
    *this = ::std::move(from);
  }

  inline Chapoly_Encryption_filter& operator=(Chapoly_Encryption_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Chapoly_Encryption_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chapoly_Encryption_filter* internal_default_instance() {
    return reinterpret_cast<const Chapoly_Encryption_filter*>(
               &_Chapoly_Encryption_filter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Chapoly_Encryption_filter* other);
  friend void swap(Chapoly_Encryption_filter& a, Chapoly_Encryption_filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chapoly_Encryption_filter* New() const PROTOBUF_FINAL { return New(NULL); }

  Chapoly_Encryption_filter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Chapoly_Encryption_filter& from);
  void MergeFrom(const Chapoly_Encryption_filter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Chapoly_Encryption_filter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes iv = 1;
  void clear_iv();
  static const int kIvFieldNumber = 1;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:proto.Chapoly_Encryption_filter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsChapoly_Encryption_filterImpl();
};
// -------------------------------------------------------------------

class Filters : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Filters) */ {
 public:
  Filters();
  virtual ~Filters();

  Filters(const Filters& from);

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Filters(Filters&& from) noexcept
    : Filters() {
    *this = ::std::move(from);
  }

  inline Filters& operator=(Filters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Filters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filters* internal_default_instance() {
    return reinterpret_cast<const Filters*>(
               &_Filters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Filters* other);
  friend void swap(Filters& a, Filters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Filters* New() const PROTOBUF_FINAL { return New(NULL); }

  Filters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Filters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.ZSTD_Compression_filter zstd_compression = 1;
  bool has_zstd_compression() const;
  void clear_zstd_compression();
  static const int kZstdCompressionFieldNumber = 1;
  const ::proto::ZSTD_Compression_filter& zstd_compression() const;
  ::proto::ZSTD_Compression_filter* release_zstd_compression();
  ::proto::ZSTD_Compression_filter* mutable_zstd_compression();
  void set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression);

  // .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
  bool has_chapoly_encryption() const;
  void clear_chapoly_encryption();
  static const int kChapolyEncryptionFieldNumber = 2;
  const ::proto::Chapoly_Encryption_filter& chapoly_encryption() const;
  ::proto::Chapoly_Encryption_filter* release_chapoly_encryption();
  ::proto::Chapoly_Encryption_filter* mutable_chapoly_encryption();
  void set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption);

  // @@protoc_insertion_point(class_scope:proto.Filters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::ZSTD_Compression_filter* zstd_compression_;
  ::proto::Chapoly_Encryption_filter* chapoly_encryption_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFiltersImpl();
};
// -------------------------------------------------------------------

class Ref_to_refcount : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_to_refcount) */ {
 public:
  Ref_to_refcount();
  virtual ~Ref_to_refcount();

  Ref_to_refcount(const Ref_to_refcount& from);

  inline Ref_to_refcount& operator=(const Ref_to_refcount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ref_to_refcount(Ref_to_refcount&& from) noexcept
    : Ref_to_refcount() {
    *this = ::std::move(from);
  }

  inline Ref_to_refcount& operator=(Ref_to_refcount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Ref_to_refcount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ref_to_refcount* internal_default_instance() {
    return reinterpret_cast<const Ref_to_refcount*>(
               &_Ref_to_refcount_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Ref_to_refcount* other);
  friend void swap(Ref_to_refcount& a, Ref_to_refcount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ref_to_refcount* New() const PROTOBUF_FINAL { return New(NULL); }

  Ref_to_refcount* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Ref_to_refcount& from);
  void MergeFrom(const Ref_to_refcount& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_to_refcount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content_fname = 1;
  void clear_content_fname();
  static const int kContentFnameFieldNumber = 1;
  const ::std::string& content_fname() const;
  void set_content_fname(const ::std::string& value);
  #if LANG_CXX11
  void set_content_fname(::std::string&& value);
  #endif
  void set_content_fname(const char* value);
  void set_content_fname(const char* value, size_t size);
  ::std::string* mutable_content_fname();
  ::std::string* release_content_fname();
  void set_allocated_content_fname(::std::string* content_fname);

  // uint64 from = 2;
  void clear_from();
  static const int kFromFieldNumber = 2;
  ::google::protobuf::uint64 from() const;
  void set_from(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Ref_to_refcount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_fname_;
  ::google::protobuf::uint64 from_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsRef_to_refcountImpl();
};
// -------------------------------------------------------------------

class Fs_record : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_record) */ {
 public:
  Fs_record();
  virtual ~Fs_record();

  Fs_record(const Fs_record& from);

  inline Fs_record& operator=(const Fs_record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fs_record(Fs_record&& from) noexcept
    : Fs_record() {
    *this = ::std::move(from);
  }

  inline Fs_record& operator=(Fs_record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Fs_record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fs_record* internal_default_instance() {
    return reinterpret_cast<const Fs_record*>(
               &_Fs_record_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Fs_record* other);
  friend void swap(Fs_record& a, Fs_record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fs_record* New() const PROTOBUF_FINAL { return New(NULL); }

  Fs_record* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Fs_record& from);
  void MergeFrom(const Fs_record& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pathname = 1;
  void clear_pathname();
  static const int kPathnameFieldNumber = 1;
  const ::std::string& pathname() const;
  void set_pathname(const ::std::string& value);
  #if LANG_CXX11
  void set_pathname(::std::string&& value);
  #endif
  void set_pathname(const char* value);
  void set_pathname(const char* value, size_t size);
  ::std::string* mutable_pathname();
  ::std::string* release_pathname();
  void set_allocated_pathname(::std::string* pathname);

  // string symlink_target = 6;
  void clear_symlink_target();
  static const int kSymlinkTargetFieldNumber = 6;
  const ::std::string& symlink_target() const;
  void set_symlink_target(const ::std::string& value);
  #if LANG_CXX11
  void set_symlink_target(::std::string&& value);
  #endif
  void set_symlink_target(const char* value);
  void set_symlink_target(const char* value, size_t size);
  ::std::string* mutable_symlink_target();
  ::std::string* release_symlink_target();
  void set_allocated_symlink_target(::std::string* symlink_target);

  // string posix_acl = 7;
  void clear_posix_acl();
  static const int kPosixAclFieldNumber = 7;
  const ::std::string& posix_acl() const;
  void set_posix_acl(const ::std::string& value);
  #if LANG_CXX11
  void set_posix_acl(::std::string&& value);
  #endif
  void set_posix_acl(const char* value);
  void set_posix_acl(const char* value, size_t size);
  ::std::string* mutable_posix_acl();
  ::std::string* release_posix_acl();
  void set_allocated_posix_acl(::std::string* posix_acl);

  // string posix_default_acl = 8;
  void clear_posix_default_acl();
  static const int kPosixDefaultAclFieldNumber = 8;
  const ::std::string& posix_default_acl() const;
  void set_posix_default_acl(const ::std::string& value);
  #if LANG_CXX11
  void set_posix_default_acl(::std::string&& value);
  #endif
  void set_posix_default_acl(const char* value);
  void set_posix_default_acl(const char* value, size_t size);
  ::std::string* mutable_posix_default_acl();
  ::std::string* release_posix_default_acl();
  void set_allocated_posix_default_acl(::std::string* posix_default_acl);

  // .proto.Ref_to_refcount ref = 5;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 5;
  const ::proto::Ref_to_refcount& ref() const;
  ::proto::Ref_to_refcount* release_ref();
  ::proto::Ref_to_refcount* mutable_ref();
  void set_allocated_ref(::proto::Ref_to_refcount* ref);

  // uint32 unix_permissions = 2;
  void clear_unix_permissions();
  static const int kUnixPermissionsFieldNumber = 2;
  ::google::protobuf::uint32 unix_permissions() const;
  void set_unix_permissions(::google::protobuf::uint32 value);

  // .proto.File_type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::proto::File_type type() const;
  void set_type(::proto::File_type value);

  // uint64 modified_seconds = 4;
  void clear_modified_seconds();
  static const int kModifiedSecondsFieldNumber = 4;
  ::google::protobuf::uint64 modified_seconds() const;
  void set_modified_seconds(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Fs_record)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pathname_;
  ::google::protobuf::internal::ArenaStringPtr symlink_target_;
  ::google::protobuf::internal::ArenaStringPtr posix_acl_;
  ::google::protobuf::internal::ArenaStringPtr posix_default_acl_;
  ::proto::Ref_to_refcount* ref_;
  ::google::protobuf::uint32 unix_permissions_;
  int type_;
  ::google::protobuf::uint64 modified_seconds_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFs_recordImpl();
};
// -------------------------------------------------------------------

class Fs_state : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_state) */ {
 public:
  Fs_state();
  virtual ~Fs_state();

  Fs_state(const Fs_state& from);

  inline Fs_state& operator=(const Fs_state& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fs_state(Fs_state&& from) noexcept
    : Fs_state() {
    *this = ::std::move(from);
  }

  inline Fs_state& operator=(Fs_state&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Fs_state& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fs_state* internal_default_instance() {
    return reinterpret_cast<const Fs_state*>(
               &_Fs_state_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Fs_state* other);
  friend void swap(Fs_state& a, Fs_state& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fs_state* New() const PROTOBUF_FINAL { return New(NULL); }

  Fs_state* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Fs_state& from);
  void MergeFrom(const Fs_state& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_state* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Fs_record rec = 1;
  int rec_size() const;
  void clear_rec();
  static const int kRecFieldNumber = 1;
  const ::proto::Fs_record& rec(int index) const;
  ::proto::Fs_record* mutable_rec(int index);
  ::proto::Fs_record* add_rec();
  ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >*
      mutable_rec();
  const ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >&
      rec() const;

  // @@protoc_insertion_point(class_scope:proto.Fs_state)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::Fs_record > rec_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFs_stateImpl();
};
// -------------------------------------------------------------------

class State_file : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.State_file) */ {
 public:
  State_file();
  virtual ~State_file();

  State_file(const State_file& from);

  inline State_file& operator=(const State_file& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State_file(State_file&& from) noexcept
    : State_file() {
    *this = ::std::move(from);
  }

  inline State_file& operator=(State_file&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const State_file& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_file* internal_default_instance() {
    return reinterpret_cast<const State_file*>(
               &_State_file_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(State_file* other);
  friend void swap(State_file& a, State_file& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State_file* New() const PROTOBUF_FINAL { return New(NULL); }

  State_file* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const State_file& from);
  void MergeFrom(const State_file& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(State_file* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .proto.Filters filters = 1;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 1;
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);

  // uint64 time_created = 3;
  void clear_time_created();
  static const int kTimeCreatedFieldNumber = 3;
  ::google::protobuf::uint64 time_created() const;
  void set_time_created(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.State_file)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::proto::Filters* filters_;
  ::google::protobuf::uint64 time_created_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsState_fileImpl();
};
// -------------------------------------------------------------------

class Content_file : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Content_file) */ {
 public:
  Content_file();
  virtual ~Content_file();

  Content_file(const Content_file& from);

  inline Content_file& operator=(const Content_file& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Content_file(Content_file&& from) noexcept
    : Content_file() {
    *this = ::std::move(from);
  }

  inline Content_file& operator=(Content_file&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Content_file& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Content_file* internal_default_instance() {
    return reinterpret_cast<const Content_file*>(
               &_Content_file_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Content_file* other);
  friend void swap(Content_file& a, Content_file& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Content_file* New() const PROTOBUF_FINAL { return New(NULL); }

  Content_file* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Content_file& from);
  void MergeFrom(const Content_file& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Content_file* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Ref_count refs = 3;
  int refs_size() const;
  void clear_refs();
  static const int kRefsFieldNumber = 3;
  const ::proto::Ref_count& refs(int index) const;
  ::proto::Ref_count* mutable_refs(int index);
  ::proto::Ref_count* add_refs();
  ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >*
      mutable_refs();
  const ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >&
      refs() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .proto.Filters filters = 1;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 1;
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);

  // @@protoc_insertion_point(class_scope:proto.Content_file)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::Ref_count > refs_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::proto::Filters* filters_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsContent_fileImpl();
};
// -------------------------------------------------------------------

class Ref_count : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_count) */ {
 public:
  Ref_count();
  virtual ~Ref_count();

  Ref_count(const Ref_count& from);

  inline Ref_count& operator=(const Ref_count& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ref_count(Ref_count&& from) noexcept
    : Ref_count() {
    *this = ::std::move(from);
  }

  inline Ref_count& operator=(Ref_count&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Ref_count& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ref_count* internal_default_instance() {
    return reinterpret_cast<const Ref_count*>(
               &_Ref_count_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Ref_count* other);
  friend void swap(Ref_count& a, Ref_count& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ref_count* New() const PROTOBUF_FINAL { return New(NULL); }

  Ref_count* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Ref_count& from);
  void MergeFrom(const Ref_count& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_count* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  ::google::protobuf::uint64 from() const;
  void set_from(::google::protobuf::uint64 value);

  // uint64 to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  ::google::protobuf::uint64 to() const;
  void set_to(::google::protobuf::uint64 value);

  // uint64 ref_count = 3;
  void clear_ref_count();
  static const int kRefCountFieldNumber = 3;
  ::google::protobuf::uint64 ref_count() const;
  void set_ref_count(::google::protobuf::uint64 value);

  // uint64 space_taken = 4;
  void clear_space_taken();
  static const int kSpaceTakenFieldNumber = 4;
  ::google::protobuf::uint64 space_taken() const;
  void set_space_taken(::google::protobuf::uint64 value);

  // uint64 xxhash = 5;
  void clear_xxhash();
  static const int kXxhashFieldNumber = 5;
  ::google::protobuf::uint64 xxhash() const;
  void set_xxhash(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Ref_count)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 from_;
  ::google::protobuf::uint64 to_;
  ::google::protobuf::uint64 ref_count_;
  ::google::protobuf::uint64 space_taken_;
  ::google::protobuf::uint64 xxhash_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsRef_countImpl();
};
// -------------------------------------------------------------------

class Catalogue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalogue) */ {
 public:
  Catalogue();
  virtual ~Catalogue();

  Catalogue(const Catalogue& from);

  inline Catalogue& operator=(const Catalogue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Catalogue(Catalogue&& from) noexcept
    : Catalogue() {
    *this = ::std::move(from);
  }

  inline Catalogue& operator=(Catalogue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Catalogue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Catalogue* internal_default_instance() {
    return reinterpret_cast<const Catalogue*>(
               &_Catalogue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Catalogue* other);
  friend void swap(Catalogue& a, Catalogue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Catalogue* New() const PROTOBUF_FINAL { return New(NULL); }

  Catalogue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Catalogue& from);
  void MergeFrom(const Catalogue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalogue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.State_file state_files = 1;
  int state_files_size() const;
  void clear_state_files();
  static const int kStateFilesFieldNumber = 1;
  const ::proto::State_file& state_files(int index) const;
  ::proto::State_file* mutable_state_files(int index);
  ::proto::State_file* add_state_files();
  ::google::protobuf::RepeatedPtrField< ::proto::State_file >*
      mutable_state_files();
  const ::google::protobuf::RepeatedPtrField< ::proto::State_file >&
      state_files() const;

  // repeated .proto.Content_file content_files = 2;
  int content_files_size() const;
  void clear_content_files();
  static const int kContentFilesFieldNumber = 2;
  const ::proto::Content_file& content_files(int index) const;
  ::proto::Content_file* mutable_content_files(int index);
  ::proto::Content_file* add_content_files();
  ::google::protobuf::RepeatedPtrField< ::proto::Content_file >*
      mutable_content_files();
  const ::google::protobuf::RepeatedPtrField< ::proto::Content_file >&
      content_files() const;

  // @@protoc_insertion_point(class_scope:proto.Catalogue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::State_file > state_files_;
  ::google::protobuf::RepeatedPtrField< ::proto::Content_file > content_files_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsCatalogueImpl();
};
// -------------------------------------------------------------------

class Catalog_header : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalog_header) */ {
 public:
  Catalog_header();
  virtual ~Catalog_header();

  Catalog_header(const Catalog_header& from);

  inline Catalog_header& operator=(const Catalog_header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Catalog_header(Catalog_header&& from) noexcept
    : Catalog_header() {
    *this = ::std::move(from);
  }

  inline Catalog_header& operator=(Catalog_header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Catalog_header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Catalog_header* internal_default_instance() {
    return reinterpret_cast<const Catalog_header*>(
               &_Catalog_header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Catalog_header* other);
  friend void swap(Catalog_header& a, Catalog_header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Catalog_header* New() const PROTOBUF_FINAL { return New(NULL); }

  Catalog_header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Catalog_header& from);
  void MergeFrom(const Catalog_header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalog_header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.Filters filters = 1;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 1;
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);

  // @@protoc_insertion_point(class_scope:proto.Catalog_header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::Filters* filters_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsCatalog_headerImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ZSTD_Compression_filter

// -------------------------------------------------------------------

// Chapoly_Encryption_filter

// bytes iv = 1;
inline void Chapoly_Encryption_filter::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chapoly_Encryption_filter::iv() const {
  // @@protoc_insertion_point(field_get:proto.Chapoly_Encryption_filter.iv)
  return iv_.GetNoArena();
}
inline void Chapoly_Encryption_filter::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Chapoly_Encryption_filter.iv)
}
#if LANG_CXX11
inline void Chapoly_Encryption_filter::set_iv(::std::string&& value) {
  
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Chapoly_Encryption_filter.iv)
}
#endif
inline void Chapoly_Encryption_filter::set_iv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Chapoly_Encryption_filter.iv)
}
inline void Chapoly_Encryption_filter::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Chapoly_Encryption_filter.iv)
}
inline ::std::string* Chapoly_Encryption_filter::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:proto.Chapoly_Encryption_filter.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chapoly_Encryption_filter::release_iv() {
  // @@protoc_insertion_point(field_release:proto.Chapoly_Encryption_filter.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chapoly_Encryption_filter::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:proto.Chapoly_Encryption_filter.iv)
}

// bytes key = 2;
inline void Chapoly_Encryption_filter::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chapoly_Encryption_filter::key() const {
  // @@protoc_insertion_point(field_get:proto.Chapoly_Encryption_filter.key)
  return key_.GetNoArena();
}
inline void Chapoly_Encryption_filter::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Chapoly_Encryption_filter.key)
}
#if LANG_CXX11
inline void Chapoly_Encryption_filter::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Chapoly_Encryption_filter.key)
}
#endif
inline void Chapoly_Encryption_filter::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Chapoly_Encryption_filter.key)
}
inline void Chapoly_Encryption_filter::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Chapoly_Encryption_filter.key)
}
inline ::std::string* Chapoly_Encryption_filter::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:proto.Chapoly_Encryption_filter.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chapoly_Encryption_filter::release_key() {
  // @@protoc_insertion_point(field_release:proto.Chapoly_Encryption_filter.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chapoly_Encryption_filter::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:proto.Chapoly_Encryption_filter.key)
}

// -------------------------------------------------------------------

// Filters

// .proto.ZSTD_Compression_filter zstd_compression = 1;
inline bool Filters::has_zstd_compression() const {
  return this != internal_default_instance() && zstd_compression_ != NULL;
}
inline void Filters::clear_zstd_compression() {
  if (GetArenaNoVirtual() == NULL && zstd_compression_ != NULL) {
    delete zstd_compression_;
  }
  zstd_compression_ = NULL;
}
inline const ::proto::ZSTD_Compression_filter& Filters::zstd_compression() const {
  const ::proto::ZSTD_Compression_filter* p = zstd_compression_;
  // @@protoc_insertion_point(field_get:proto.Filters.zstd_compression)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::ZSTD_Compression_filter*>(
      &::proto::_ZSTD_Compression_filter_default_instance_);
}
inline ::proto::ZSTD_Compression_filter* Filters::release_zstd_compression() {
  // @@protoc_insertion_point(field_release:proto.Filters.zstd_compression)
  
  ::proto::ZSTD_Compression_filter* temp = zstd_compression_;
  zstd_compression_ = NULL;
  return temp;
}
inline ::proto::ZSTD_Compression_filter* Filters::mutable_zstd_compression() {
  
  if (zstd_compression_ == NULL) {
    zstd_compression_ = new ::proto::ZSTD_Compression_filter;
  }
  // @@protoc_insertion_point(field_mutable:proto.Filters.zstd_compression)
  return zstd_compression_;
}
inline void Filters::set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zstd_compression_;
  }
  if (zstd_compression) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zstd_compression = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zstd_compression, submessage_arena);
    }
    
  } else {
    
  }
  zstd_compression_ = zstd_compression;
  // @@protoc_insertion_point(field_set_allocated:proto.Filters.zstd_compression)
}

// .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
inline bool Filters::has_chapoly_encryption() const {
  return this != internal_default_instance() && chapoly_encryption_ != NULL;
}
inline void Filters::clear_chapoly_encryption() {
  if (GetArenaNoVirtual() == NULL && chapoly_encryption_ != NULL) {
    delete chapoly_encryption_;
  }
  chapoly_encryption_ = NULL;
}
inline const ::proto::Chapoly_Encryption_filter& Filters::chapoly_encryption() const {
  const ::proto::Chapoly_Encryption_filter* p = chapoly_encryption_;
  // @@protoc_insertion_point(field_get:proto.Filters.chapoly_encryption)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Chapoly_Encryption_filter*>(
      &::proto::_Chapoly_Encryption_filter_default_instance_);
}
inline ::proto::Chapoly_Encryption_filter* Filters::release_chapoly_encryption() {
  // @@protoc_insertion_point(field_release:proto.Filters.chapoly_encryption)
  
  ::proto::Chapoly_Encryption_filter* temp = chapoly_encryption_;
  chapoly_encryption_ = NULL;
  return temp;
}
inline ::proto::Chapoly_Encryption_filter* Filters::mutable_chapoly_encryption() {
  
  if (chapoly_encryption_ == NULL) {
    chapoly_encryption_ = new ::proto::Chapoly_Encryption_filter;
  }
  // @@protoc_insertion_point(field_mutable:proto.Filters.chapoly_encryption)
  return chapoly_encryption_;
}
inline void Filters::set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chapoly_encryption_;
  }
  if (chapoly_encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chapoly_encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chapoly_encryption, submessage_arena);
    }
    
  } else {
    
  }
  chapoly_encryption_ = chapoly_encryption;
  // @@protoc_insertion_point(field_set_allocated:proto.Filters.chapoly_encryption)
}

// -------------------------------------------------------------------

// Ref_to_refcount

// string content_fname = 1;
inline void Ref_to_refcount::clear_content_fname() {
  content_fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Ref_to_refcount::content_fname() const {
  // @@protoc_insertion_point(field_get:proto.Ref_to_refcount.content_fname)
  return content_fname_.GetNoArena();
}
inline void Ref_to_refcount::set_content_fname(const ::std::string& value) {
  
  content_fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Ref_to_refcount.content_fname)
}
#if LANG_CXX11
inline void Ref_to_refcount::set_content_fname(::std::string&& value) {
  
  content_fname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Ref_to_refcount.content_fname)
}
#endif
inline void Ref_to_refcount::set_content_fname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Ref_to_refcount.content_fname)
}
inline void Ref_to_refcount::set_content_fname(const char* value, size_t size) {
  
  content_fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Ref_to_refcount.content_fname)
}
inline ::std::string* Ref_to_refcount::mutable_content_fname() {
  
  // @@protoc_insertion_point(field_mutable:proto.Ref_to_refcount.content_fname)
  return content_fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ref_to_refcount::release_content_fname() {
  // @@protoc_insertion_point(field_release:proto.Ref_to_refcount.content_fname)
  
  return content_fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ref_to_refcount::set_allocated_content_fname(::std::string* content_fname) {
  if (content_fname != NULL) {
    
  } else {
    
  }
  content_fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content_fname);
  // @@protoc_insertion_point(field_set_allocated:proto.Ref_to_refcount.content_fname)
}

// uint64 from = 2;
inline void Ref_to_refcount::clear_from() {
  from_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_to_refcount::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_to_refcount.from)
  return from_;
}
inline void Ref_to_refcount::set_from(::google::protobuf::uint64 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_to_refcount.from)
}

// -------------------------------------------------------------------

// Fs_record

// string pathname = 1;
inline void Fs_record::clear_pathname() {
  pathname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fs_record::pathname() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.pathname)
  return pathname_.GetNoArena();
}
inline void Fs_record::set_pathname(const ::std::string& value) {
  
  pathname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.pathname)
}
#if LANG_CXX11
inline void Fs_record::set_pathname(::std::string&& value) {
  
  pathname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.pathname)
}
#endif
inline void Fs_record::set_pathname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pathname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.pathname)
}
inline void Fs_record::set_pathname(const char* value, size_t size) {
  
  pathname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.pathname)
}
inline ::std::string* Fs_record::mutable_pathname() {
  
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.pathname)
  return pathname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fs_record::release_pathname() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.pathname)
  
  return pathname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fs_record::set_allocated_pathname(::std::string* pathname) {
  if (pathname != NULL) {
    
  } else {
    
  }
  pathname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pathname);
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.pathname)
}

// uint32 unix_permissions = 2;
inline void Fs_record::clear_unix_permissions() {
  unix_permissions_ = 0u;
}
inline ::google::protobuf::uint32 Fs_record::unix_permissions() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.unix_permissions)
  return unix_permissions_;
}
inline void Fs_record::set_unix_permissions(::google::protobuf::uint32 value) {
  
  unix_permissions_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.unix_permissions)
}

// .proto.File_type type = 3;
inline void Fs_record::clear_type() {
  type_ = 0;
}
inline ::proto::File_type Fs_record::type() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.type)
  return static_cast< ::proto::File_type >(type_);
}
inline void Fs_record::set_type(::proto::File_type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.type)
}

// uint64 modified_seconds = 4;
inline void Fs_record::clear_modified_seconds() {
  modified_seconds_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Fs_record::modified_seconds() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.modified_seconds)
  return modified_seconds_;
}
inline void Fs_record::set_modified_seconds(::google::protobuf::uint64 value) {
  
  modified_seconds_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.modified_seconds)
}

// .proto.Ref_to_refcount ref = 5;
inline bool Fs_record::has_ref() const {
  return this != internal_default_instance() && ref_ != NULL;
}
inline void Fs_record::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) {
    delete ref_;
  }
  ref_ = NULL;
}
inline const ::proto::Ref_to_refcount& Fs_record::ref() const {
  const ::proto::Ref_to_refcount* p = ref_;
  // @@protoc_insertion_point(field_get:proto.Fs_record.ref)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Ref_to_refcount*>(
      &::proto::_Ref_to_refcount_default_instance_);
}
inline ::proto::Ref_to_refcount* Fs_record::release_ref() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.ref)
  
  ::proto::Ref_to_refcount* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline ::proto::Ref_to_refcount* Fs_record::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::proto::Ref_to_refcount;
  }
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.ref)
  return ref_;
}
inline void Fs_record::set_allocated_ref(::proto::Ref_to_refcount* ref) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ref_;
  }
  if (ref) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ref = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ref, submessage_arena);
    }
    
  } else {
    
  }
  ref_ = ref;
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.ref)
}

// string symlink_target = 6;
inline void Fs_record::clear_symlink_target() {
  symlink_target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fs_record::symlink_target() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.symlink_target)
  return symlink_target_.GetNoArena();
}
inline void Fs_record::set_symlink_target(const ::std::string& value) {
  
  symlink_target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.symlink_target)
}
#if LANG_CXX11
inline void Fs_record::set_symlink_target(::std::string&& value) {
  
  symlink_target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.symlink_target)
}
#endif
inline void Fs_record::set_symlink_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symlink_target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.symlink_target)
}
inline void Fs_record::set_symlink_target(const char* value, size_t size) {
  
  symlink_target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.symlink_target)
}
inline ::std::string* Fs_record::mutable_symlink_target() {
  
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.symlink_target)
  return symlink_target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fs_record::release_symlink_target() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.symlink_target)
  
  return symlink_target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fs_record::set_allocated_symlink_target(::std::string* symlink_target) {
  if (symlink_target != NULL) {
    
  } else {
    
  }
  symlink_target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symlink_target);
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.symlink_target)
}

// string posix_acl = 7;
inline void Fs_record::clear_posix_acl() {
  posix_acl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fs_record::posix_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_acl)
  return posix_acl_.GetNoArena();
}
inline void Fs_record::set_posix_acl(const ::std::string& value) {
  
  posix_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_acl)
}
#if LANG_CXX11
inline void Fs_record::set_posix_acl(::std::string&& value) {
  
  posix_acl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.posix_acl)
}
#endif
inline void Fs_record::set_posix_acl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  posix_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.posix_acl)
}
inline void Fs_record::set_posix_acl(const char* value, size_t size) {
  
  posix_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.posix_acl)
}
inline ::std::string* Fs_record::mutable_posix_acl() {
  
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_acl)
  return posix_acl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fs_record::release_posix_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_acl)
  
  return posix_acl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fs_record::set_allocated_posix_acl(::std::string* posix_acl) {
  if (posix_acl != NULL) {
    
  } else {
    
  }
  posix_acl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), posix_acl);
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_acl)
}

// string posix_default_acl = 8;
inline void Fs_record::clear_posix_default_acl() {
  posix_default_acl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fs_record::posix_default_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_default_acl)
  return posix_default_acl_.GetNoArena();
}
inline void Fs_record::set_posix_default_acl(const ::std::string& value) {
  
  posix_default_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_default_acl)
}
#if LANG_CXX11
inline void Fs_record::set_posix_default_acl(::std::string&& value) {
  
  posix_default_acl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.posix_default_acl)
}
#endif
inline void Fs_record::set_posix_default_acl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  posix_default_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.posix_default_acl)
}
inline void Fs_record::set_posix_default_acl(const char* value, size_t size) {
  
  posix_default_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.posix_default_acl)
}
inline ::std::string* Fs_record::mutable_posix_default_acl() {
  
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_default_acl)
  return posix_default_acl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fs_record::release_posix_default_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_default_acl)
  
  return posix_default_acl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fs_record::set_allocated_posix_default_acl(::std::string* posix_default_acl) {
  if (posix_default_acl != NULL) {
    
  } else {
    
  }
  posix_default_acl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), posix_default_acl);
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_default_acl)
}

// -------------------------------------------------------------------

// Fs_state

// repeated .proto.Fs_record rec = 1;
inline int Fs_state::rec_size() const {
  return rec_.size();
}
inline void Fs_state::clear_rec() {
  rec_.Clear();
}
inline const ::proto::Fs_record& Fs_state::rec(int index) const {
  // @@protoc_insertion_point(field_get:proto.Fs_state.rec)
  return rec_.Get(index);
}
inline ::proto::Fs_record* Fs_state::mutable_rec(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Fs_state.rec)
  return rec_.Mutable(index);
}
inline ::proto::Fs_record* Fs_state::add_rec() {
  // @@protoc_insertion_point(field_add:proto.Fs_state.rec)
  return rec_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >*
Fs_state::mutable_rec() {
  // @@protoc_insertion_point(field_mutable_list:proto.Fs_state.rec)
  return &rec_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >&
Fs_state::rec() const {
  // @@protoc_insertion_point(field_list:proto.Fs_state.rec)
  return rec_;
}

// -------------------------------------------------------------------

// State_file

// .proto.Filters filters = 1;
inline bool State_file::has_filters() const {
  return this != internal_default_instance() && filters_ != NULL;
}
inline void State_file::clear_filters() {
  if (GetArenaNoVirtual() == NULL && filters_ != NULL) {
    delete filters_;
  }
  filters_ = NULL;
}
inline const ::proto::Filters& State_file::filters() const {
  const ::proto::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:proto.State_file.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline ::proto::Filters* State_file::release_filters() {
  // @@protoc_insertion_point(field_release:proto.State_file.filters)
  
  ::proto::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* State_file::mutable_filters() {
  
  if (filters_ == NULL) {
    filters_ = new ::proto::Filters;
  }
  // @@protoc_insertion_point(field_mutable:proto.State_file.filters)
  return filters_;
}
inline void State_file::set_allocated_filters(::proto::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filters_;
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    
  } else {
    
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.State_file.filters)
}

// string name = 2;
inline void State_file::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& State_file::name() const {
  // @@protoc_insertion_point(field_get:proto.State_file.name)
  return name_.GetNoArena();
}
inline void State_file::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.State_file.name)
}
#if LANG_CXX11
inline void State_file::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.State_file.name)
}
#endif
inline void State_file::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.State_file.name)
}
inline void State_file::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.State_file.name)
}
inline ::std::string* State_file::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.State_file.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* State_file::release_name() {
  // @@protoc_insertion_point(field_release:proto.State_file.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void State_file::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.State_file.name)
}

// uint64 time_created = 3;
inline void State_file::clear_time_created() {
  time_created_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 State_file::time_created() const {
  // @@protoc_insertion_point(field_get:proto.State_file.time_created)
  return time_created_;
}
inline void State_file::set_time_created(::google::protobuf::uint64 value) {
  
  time_created_ = value;
  // @@protoc_insertion_point(field_set:proto.State_file.time_created)
}

// -------------------------------------------------------------------

// Content_file

// .proto.Filters filters = 1;
inline bool Content_file::has_filters() const {
  return this != internal_default_instance() && filters_ != NULL;
}
inline void Content_file::clear_filters() {
  if (GetArenaNoVirtual() == NULL && filters_ != NULL) {
    delete filters_;
  }
  filters_ = NULL;
}
inline const ::proto::Filters& Content_file::filters() const {
  const ::proto::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:proto.Content_file.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline ::proto::Filters* Content_file::release_filters() {
  // @@protoc_insertion_point(field_release:proto.Content_file.filters)
  
  ::proto::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* Content_file::mutable_filters() {
  
  if (filters_ == NULL) {
    filters_ = new ::proto::Filters;
  }
  // @@protoc_insertion_point(field_mutable:proto.Content_file.filters)
  return filters_;
}
inline void Content_file::set_allocated_filters(::proto::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filters_;
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    
  } else {
    
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.Content_file.filters)
}

// string name = 2;
inline void Content_file::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Content_file::name() const {
  // @@protoc_insertion_point(field_get:proto.Content_file.name)
  return name_.GetNoArena();
}
inline void Content_file::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Content_file.name)
}
#if LANG_CXX11
inline void Content_file::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Content_file.name)
}
#endif
inline void Content_file::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Content_file.name)
}
inline void Content_file::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Content_file.name)
}
inline ::std::string* Content_file::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.Content_file.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Content_file::release_name() {
  // @@protoc_insertion_point(field_release:proto.Content_file.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Content_file::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.Content_file.name)
}

// repeated .proto.Ref_count refs = 3;
inline int Content_file::refs_size() const {
  return refs_.size();
}
inline void Content_file::clear_refs() {
  refs_.Clear();
}
inline const ::proto::Ref_count& Content_file::refs(int index) const {
  // @@protoc_insertion_point(field_get:proto.Content_file.refs)
  return refs_.Get(index);
}
inline ::proto::Ref_count* Content_file::mutable_refs(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Content_file.refs)
  return refs_.Mutable(index);
}
inline ::proto::Ref_count* Content_file::add_refs() {
  // @@protoc_insertion_point(field_add:proto.Content_file.refs)
  return refs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >*
Content_file::mutable_refs() {
  // @@protoc_insertion_point(field_mutable_list:proto.Content_file.refs)
  return &refs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >&
Content_file::refs() const {
  // @@protoc_insertion_point(field_list:proto.Content_file.refs)
  return refs_;
}

// -------------------------------------------------------------------

// Ref_count

// uint64 from = 1;
inline void Ref_count::clear_from() {
  from_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.from)
  return from_;
}
inline void Ref_count::set_from(::google::protobuf::uint64 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.from)
}

// uint64 to = 2;
inline void Ref_count::clear_to() {
  to_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::to() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.to)
  return to_;
}
inline void Ref_count::set_to(::google::protobuf::uint64 value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.to)
}

// uint64 ref_count = 3;
inline void Ref_count::clear_ref_count() {
  ref_count_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::ref_count() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.ref_count)
  return ref_count_;
}
inline void Ref_count::set_ref_count(::google::protobuf::uint64 value) {
  
  ref_count_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.ref_count)
}

// uint64 space_taken = 4;
inline void Ref_count::clear_space_taken() {
  space_taken_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::space_taken() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.space_taken)
  return space_taken_;
}
inline void Ref_count::set_space_taken(::google::protobuf::uint64 value) {
  
  space_taken_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.space_taken)
}

// uint64 xxhash = 5;
inline void Ref_count::clear_xxhash() {
  xxhash_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::xxhash() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.xxhash)
  return xxhash_;
}
inline void Ref_count::set_xxhash(::google::protobuf::uint64 value) {
  
  xxhash_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.xxhash)
}

// -------------------------------------------------------------------

// Catalogue

// repeated .proto.State_file state_files = 1;
inline int Catalogue::state_files_size() const {
  return state_files_.size();
}
inline void Catalogue::clear_state_files() {
  state_files_.Clear();
}
inline const ::proto::State_file& Catalogue::state_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.state_files)
  return state_files_.Get(index);
}
inline ::proto::State_file* Catalogue::mutable_state_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.state_files)
  return state_files_.Mutable(index);
}
inline ::proto::State_file* Catalogue::add_state_files() {
  // @@protoc_insertion_point(field_add:proto.Catalogue.state_files)
  return state_files_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::State_file >*
Catalogue::mutable_state_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.state_files)
  return &state_files_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::State_file >&
Catalogue::state_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.state_files)
  return state_files_;
}

// repeated .proto.Content_file content_files = 2;
inline int Catalogue::content_files_size() const {
  return content_files_.size();
}
inline void Catalogue::clear_content_files() {
  content_files_.Clear();
}
inline const ::proto::Content_file& Catalogue::content_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.content_files)
  return content_files_.Get(index);
}
inline ::proto::Content_file* Catalogue::mutable_content_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.content_files)
  return content_files_.Mutable(index);
}
inline ::proto::Content_file* Catalogue::add_content_files() {
  // @@protoc_insertion_point(field_add:proto.Catalogue.content_files)
  return content_files_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Content_file >*
Catalogue::mutable_content_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.content_files)
  return &content_files_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Content_file >&
Catalogue::content_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.content_files)
  return content_files_;
}

// -------------------------------------------------------------------

// Catalog_header

// .proto.Filters filters = 1;
inline bool Catalog_header::has_filters() const {
  return this != internal_default_instance() && filters_ != NULL;
}
inline void Catalog_header::clear_filters() {
  if (GetArenaNoVirtual() == NULL && filters_ != NULL) {
    delete filters_;
  }
  filters_ = NULL;
}
inline const ::proto::Filters& Catalog_header::filters() const {
  const ::proto::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:proto.Catalog_header.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline ::proto::Filters* Catalog_header::release_filters() {
  // @@protoc_insertion_point(field_release:proto.Catalog_header.filters)
  
  ::proto::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* Catalog_header::mutable_filters() {
  
  if (filters_ == NULL) {
    filters_ = new ::proto::Filters;
  }
  // @@protoc_insertion_point(field_mutable:proto.Catalog_header.filters)
  return filters_;
}
inline void Catalog_header::set_allocated_filters(::proto::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filters_;
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    
  } else {
    
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.Catalog_header.filters)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::File_type> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_format_2eproto__INCLUDED
