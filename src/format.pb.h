// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: format.proto

#ifndef PROTOBUF_format_2eproto__INCLUDED
#define PROTOBUF_format_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_format_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsZSTD_Compression_filterImpl();
void InitDefaultsZSTD_Compression_filter();
void InitDefaultsAES256_Encryption_filterImpl();
void InitDefaultsAES256_Encryption_filter();
void InitDefaultsFilterImpl();
void InitDefaultsFilter();
void InitDefaultsRefImpl();
void InitDefaultsRef();
void InitDefaultsFs_recordImpl();
void InitDefaultsFs_record();
void InitDefaultsFs_stateImpl();
void InitDefaultsFs_state();
void InitDefaultsFile_descImpl();
void InitDefaultsFile_desc();
void InitDefaultsRef_countImpl();
void InitDefaultsRef_count();
void InitDefaultsCatalogueImpl();
void InitDefaultsCatalogue();
void InitDefaultsCatalog_headerImpl();
void InitDefaultsCatalog_header();
inline void InitDefaults() {
  InitDefaultsZSTD_Compression_filter();
  InitDefaultsAES256_Encryption_filter();
  InitDefaultsFilter();
  InitDefaultsRef();
  InitDefaultsFs_record();
  InitDefaultsFs_state();
  InitDefaultsFile_desc();
  InitDefaultsRef_count();
  InitDefaultsCatalogue();
  InitDefaultsCatalog_header();
}
}  // namespace protobuf_format_2eproto
namespace proto {
class AES256_Encryption_filter;
class AES256_Encryption_filterDefaultTypeInternal;
extern AES256_Encryption_filterDefaultTypeInternal _AES256_Encryption_filter_default_instance_;
class Catalog_header;
class Catalog_headerDefaultTypeInternal;
extern Catalog_headerDefaultTypeInternal _Catalog_header_default_instance_;
class Catalogue;
class CatalogueDefaultTypeInternal;
extern CatalogueDefaultTypeInternal _Catalogue_default_instance_;
class File_desc;
class File_descDefaultTypeInternal;
extern File_descDefaultTypeInternal _File_desc_default_instance_;
class Filter;
class FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class Fs_record;
class Fs_recordDefaultTypeInternal;
extern Fs_recordDefaultTypeInternal _Fs_record_default_instance_;
class Fs_state;
class Fs_stateDefaultTypeInternal;
extern Fs_stateDefaultTypeInternal _Fs_state_default_instance_;
class Ref;
class RefDefaultTypeInternal;
extern RefDefaultTypeInternal _Ref_default_instance_;
class Ref_count;
class Ref_countDefaultTypeInternal;
extern Ref_countDefaultTypeInternal _Ref_count_default_instance_;
class ZSTD_Compression_filter;
class ZSTD_Compression_filterDefaultTypeInternal;
extern ZSTD_Compression_filterDefaultTypeInternal _ZSTD_Compression_filter_default_instance_;
}  // namespace proto
namespace proto {

enum File_type {
  FILE = 0,
  DIR = 1,
  SYMLINK = 2,
  File_type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  File_type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool File_type_IsValid(int value);
const File_type File_type_MIN = FILE;
const File_type File_type_MAX = SYMLINK;
const int File_type_ARRAYSIZE = File_type_MAX + 1;

// ===================================================================

class ZSTD_Compression_filter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ZSTD_Compression_filter) */ {
 public:
  ZSTD_Compression_filter();
  virtual ~ZSTD_Compression_filter();

  ZSTD_Compression_filter(const ZSTD_Compression_filter& from);

  inline ZSTD_Compression_filter& operator=(const ZSTD_Compression_filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ZSTD_Compression_filter(ZSTD_Compression_filter&& from) noexcept
    : ZSTD_Compression_filter() {
    *this = ::std::move(from);
  }

  inline ZSTD_Compression_filter& operator=(ZSTD_Compression_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ZSTD_Compression_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZSTD_Compression_filter* internal_default_instance() {
    return reinterpret_cast<const ZSTD_Compression_filter*>(
               &_ZSTD_Compression_filter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ZSTD_Compression_filter* other);
  friend void swap(ZSTD_Compression_filter& a, ZSTD_Compression_filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ZSTD_Compression_filter* New() const PROTOBUF_FINAL { return New(NULL); }

  ZSTD_Compression_filter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ZSTD_Compression_filter& from);
  void MergeFrom(const ZSTD_Compression_filter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ZSTD_Compression_filter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.ZSTD_Compression_filter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsZSTD_Compression_filterImpl();
};
// -------------------------------------------------------------------

class AES256_Encryption_filter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.AES256_Encryption_filter) */ {
 public:
  AES256_Encryption_filter();
  virtual ~AES256_Encryption_filter();

  AES256_Encryption_filter(const AES256_Encryption_filter& from);

  inline AES256_Encryption_filter& operator=(const AES256_Encryption_filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AES256_Encryption_filter(AES256_Encryption_filter&& from) noexcept
    : AES256_Encryption_filter() {
    *this = ::std::move(from);
  }

  inline AES256_Encryption_filter& operator=(AES256_Encryption_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AES256_Encryption_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AES256_Encryption_filter* internal_default_instance() {
    return reinterpret_cast<const AES256_Encryption_filter*>(
               &_AES256_Encryption_filter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AES256_Encryption_filter* other);
  friend void swap(AES256_Encryption_filter& a, AES256_Encryption_filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AES256_Encryption_filter* New() const PROTOBUF_FINAL { return New(NULL); }

  AES256_Encryption_filter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AES256_Encryption_filter& from);
  void MergeFrom(const AES256_Encryption_filter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AES256_Encryption_filter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes salt = 1;
  void clear_salt();
  static const int kSaltFieldNumber = 1;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_salt(::std::string&& value);
  #endif
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // @@protoc_insertion_point(class_scope:proto.AES256_Encryption_filter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsAES256_Encryption_filterImpl();
};
// -------------------------------------------------------------------

class Filter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Filter) */ {
 public:
  Filter();
  virtual ~Filter();

  Filter(const Filter& from);

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(Filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Filter& default_instance();

  enum FilterCase {
    kZstdCompression = 1,
    kAesEncryption = 2,
    FILTER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Filter* other);
  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Filter* New() const PROTOBUF_FINAL { return New(NULL); }

  Filter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Filter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.ZSTD_Compression_filter zstd_compression = 1;
  bool has_zstd_compression() const;
  void clear_zstd_compression();
  static const int kZstdCompressionFieldNumber = 1;
  const ::proto::ZSTD_Compression_filter& zstd_compression() const;
  ::proto::ZSTD_Compression_filter* release_zstd_compression();
  ::proto::ZSTD_Compression_filter* mutable_zstd_compression();
  void set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression);

  // .proto.AES256_Encryption_filter aes_encryption = 2;
  bool has_aes_encryption() const;
  void clear_aes_encryption();
  static const int kAesEncryptionFieldNumber = 2;
  const ::proto::AES256_Encryption_filter& aes_encryption() const;
  ::proto::AES256_Encryption_filter* release_aes_encryption();
  ::proto::AES256_Encryption_filter* mutable_aes_encryption();
  void set_allocated_aes_encryption(::proto::AES256_Encryption_filter* aes_encryption);

  FilterCase filter_case() const;
  // @@protoc_insertion_point(class_scope:proto.Filter)
 private:
  void set_has_zstd_compression();
  void set_has_aes_encryption();

  inline bool has_filter() const;
  void clear_filter();
  inline void clear_has_filter();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union FilterUnion {
    FilterUnion() {}
    ::proto::ZSTD_Compression_filter* zstd_compression_;
    ::proto::AES256_Encryption_filter* aes_encryption_;
  } filter_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFilterImpl();
};
// -------------------------------------------------------------------

class Ref : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref) */ {
 public:
  Ref();
  virtual ~Ref();

  Ref(const Ref& from);

  inline Ref& operator=(const Ref& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ref(Ref&& from) noexcept
    : Ref() {
    *this = ::std::move(from);
  }

  inline Ref& operator=(Ref&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Ref& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ref* internal_default_instance() {
    return reinterpret_cast<const Ref*>(
               &_Ref_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Ref* other);
  friend void swap(Ref& a, Ref& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ref* New() const PROTOBUF_FINAL { return New(NULL); }

  Ref* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Ref& from);
  void MergeFrom(const Ref& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content_fname = 1;
  void clear_content_fname();
  static const int kContentFnameFieldNumber = 1;
  const ::std::string& content_fname() const;
  void set_content_fname(const ::std::string& value);
  #if LANG_CXX11
  void set_content_fname(::std::string&& value);
  #endif
  void set_content_fname(const char* value);
  void set_content_fname(const char* value, size_t size);
  ::std::string* mutable_content_fname();
  ::std::string* release_content_fname();
  void set_allocated_content_fname(::std::string* content_fname);

  // uint64 from = 2;
  void clear_from();
  static const int kFromFieldNumber = 2;
  ::google::protobuf::uint64 from() const;
  void set_from(::google::protobuf::uint64 value);

  // uint64 to = 3;
  void clear_to();
  static const int kToFieldNumber = 3;
  ::google::protobuf::uint64 to() const;
  void set_to(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Ref)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_fname_;
  ::google::protobuf::uint64 from_;
  ::google::protobuf::uint64 to_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsRefImpl();
};
// -------------------------------------------------------------------

class Fs_record : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_record) */ {
 public:
  Fs_record();
  virtual ~Fs_record();

  Fs_record(const Fs_record& from);

  inline Fs_record& operator=(const Fs_record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fs_record(Fs_record&& from) noexcept
    : Fs_record() {
    *this = ::std::move(from);
  }

  inline Fs_record& operator=(Fs_record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Fs_record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fs_record* internal_default_instance() {
    return reinterpret_cast<const Fs_record*>(
               &_Fs_record_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Fs_record* other);
  friend void swap(Fs_record& a, Fs_record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fs_record* New() const PROTOBUF_FINAL { return New(NULL); }

  Fs_record* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Fs_record& from);
  void MergeFrom(const Fs_record& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pathname = 1;
  void clear_pathname();
  static const int kPathnameFieldNumber = 1;
  const ::std::string& pathname() const;
  void set_pathname(const ::std::string& value);
  #if LANG_CXX11
  void set_pathname(::std::string&& value);
  #endif
  void set_pathname(const char* value);
  void set_pathname(const char* value, size_t size);
  ::std::string* mutable_pathname();
  ::std::string* release_pathname();
  void set_allocated_pathname(::std::string* pathname);

  // string symlink_target = 6;
  void clear_symlink_target();
  static const int kSymlinkTargetFieldNumber = 6;
  const ::std::string& symlink_target() const;
  void set_symlink_target(const ::std::string& value);
  #if LANG_CXX11
  void set_symlink_target(::std::string&& value);
  #endif
  void set_symlink_target(const char* value);
  void set_symlink_target(const char* value, size_t size);
  ::std::string* mutable_symlink_target();
  ::std::string* release_symlink_target();
  void set_allocated_symlink_target(::std::string* symlink_target);

  // string posix_acl = 7;
  void clear_posix_acl();
  static const int kPosixAclFieldNumber = 7;
  const ::std::string& posix_acl() const;
  void set_posix_acl(const ::std::string& value);
  #if LANG_CXX11
  void set_posix_acl(::std::string&& value);
  #endif
  void set_posix_acl(const char* value);
  void set_posix_acl(const char* value, size_t size);
  ::std::string* mutable_posix_acl();
  ::std::string* release_posix_acl();
  void set_allocated_posix_acl(::std::string* posix_acl);

  // string posix_default_acl = 8;
  void clear_posix_default_acl();
  static const int kPosixDefaultAclFieldNumber = 8;
  const ::std::string& posix_default_acl() const;
  void set_posix_default_acl(const ::std::string& value);
  #if LANG_CXX11
  void set_posix_default_acl(::std::string&& value);
  #endif
  void set_posix_default_acl(const char* value);
  void set_posix_default_acl(const char* value, size_t size);
  ::std::string* mutable_posix_default_acl();
  ::std::string* release_posix_default_acl();
  void set_allocated_posix_default_acl(::std::string* posix_default_acl);

  // .proto.Ref ref = 5;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 5;
  const ::proto::Ref& ref() const;
  ::proto::Ref* release_ref();
  ::proto::Ref* mutable_ref();
  void set_allocated_ref(::proto::Ref* ref);

  // uint32 unix_permissions = 2;
  void clear_unix_permissions();
  static const int kUnixPermissionsFieldNumber = 2;
  ::google::protobuf::uint32 unix_permissions() const;
  void set_unix_permissions(::google::protobuf::uint32 value);

  // .proto.File_type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::proto::File_type type() const;
  void set_type(::proto::File_type value);

  // uint64 modified_seconds = 4;
  void clear_modified_seconds();
  static const int kModifiedSecondsFieldNumber = 4;
  ::google::protobuf::uint64 modified_seconds() const;
  void set_modified_seconds(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Fs_record)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pathname_;
  ::google::protobuf::internal::ArenaStringPtr symlink_target_;
  ::google::protobuf::internal::ArenaStringPtr posix_acl_;
  ::google::protobuf::internal::ArenaStringPtr posix_default_acl_;
  ::proto::Ref* ref_;
  ::google::protobuf::uint32 unix_permissions_;
  int type_;
  ::google::protobuf::uint64 modified_seconds_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFs_recordImpl();
};
// -------------------------------------------------------------------

class Fs_state : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_state) */ {
 public:
  Fs_state();
  virtual ~Fs_state();

  Fs_state(const Fs_state& from);

  inline Fs_state& operator=(const Fs_state& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fs_state(Fs_state&& from) noexcept
    : Fs_state() {
    *this = ::std::move(from);
  }

  inline Fs_state& operator=(Fs_state&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Fs_state& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fs_state* internal_default_instance() {
    return reinterpret_cast<const Fs_state*>(
               &_Fs_state_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Fs_state* other);
  friend void swap(Fs_state& a, Fs_state& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fs_state* New() const PROTOBUF_FINAL { return New(NULL); }

  Fs_state* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Fs_state& from);
  void MergeFrom(const Fs_state& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_state* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Fs_record rec = 1;
  int rec_size() const;
  void clear_rec();
  static const int kRecFieldNumber = 1;
  const ::proto::Fs_record& rec(int index) const;
  ::proto::Fs_record* mutable_rec(int index);
  ::proto::Fs_record* add_rec();
  ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >*
      mutable_rec();
  const ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >&
      rec() const;

  // @@protoc_insertion_point(class_scope:proto.Fs_state)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::Fs_record > rec_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFs_stateImpl();
};
// -------------------------------------------------------------------

class File_desc : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.File_desc) */ {
 public:
  File_desc();
  virtual ~File_desc();

  File_desc(const File_desc& from);

  inline File_desc& operator=(const File_desc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  File_desc(File_desc&& from) noexcept
    : File_desc() {
    *this = ::std::move(from);
  }

  inline File_desc& operator=(File_desc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const File_desc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const File_desc* internal_default_instance() {
    return reinterpret_cast<const File_desc*>(
               &_File_desc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(File_desc* other);
  friend void swap(File_desc& a, File_desc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline File_desc* New() const PROTOBUF_FINAL { return New(NULL); }

  File_desc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const File_desc& from);
  void MergeFrom(const File_desc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(File_desc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Filter filters = 2;
  int filters_size() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 2;
  const ::proto::Filter& filters(int index) const;
  ::proto::Filter* mutable_filters(int index);
  ::proto::Filter* add_filters();
  ::google::protobuf::RepeatedPtrField< ::proto::Filter >*
      mutable_filters();
  const ::google::protobuf::RepeatedPtrField< ::proto::Filter >&
      filters() const;

  // repeated .proto.Ref_count refs = 3;
  int refs_size() const;
  void clear_refs();
  static const int kRefsFieldNumber = 3;
  const ::proto::Ref_count& refs(int index) const;
  ::proto::Ref_count* mutable_refs(int index);
  ::proto::Ref_count* add_refs();
  ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >*
      mutable_refs();
  const ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >&
      refs() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint64 time_created = 4;
  void clear_time_created();
  static const int kTimeCreatedFieldNumber = 4;
  ::google::protobuf::uint64 time_created() const;
  void set_time_created(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.File_desc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::Filter > filters_;
  ::google::protobuf::RepeatedPtrField< ::proto::Ref_count > refs_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 time_created_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFile_descImpl();
};
// -------------------------------------------------------------------

class Ref_count : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_count) */ {
 public:
  Ref_count();
  virtual ~Ref_count();

  Ref_count(const Ref_count& from);

  inline Ref_count& operator=(const Ref_count& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ref_count(Ref_count&& from) noexcept
    : Ref_count() {
    *this = ::std::move(from);
  }

  inline Ref_count& operator=(Ref_count&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Ref_count& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ref_count* internal_default_instance() {
    return reinterpret_cast<const Ref_count*>(
               &_Ref_count_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Ref_count* other);
  friend void swap(Ref_count& a, Ref_count& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ref_count* New() const PROTOBUF_FINAL { return New(NULL); }

  Ref_count* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Ref_count& from);
  void MergeFrom(const Ref_count& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_count* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  ::google::protobuf::uint64 from() const;
  void set_from(::google::protobuf::uint64 value);

  // uint64 to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  ::google::protobuf::uint64 to() const;
  void set_to(::google::protobuf::uint64 value);

  // uint64 ref_count = 3;
  void clear_ref_count();
  static const int kRefCountFieldNumber = 3;
  ::google::protobuf::uint64 ref_count() const;
  void set_ref_count(::google::protobuf::uint64 value);

  // uint64 space_taken = 4;
  void clear_space_taken();
  static const int kSpaceTakenFieldNumber = 4;
  ::google::protobuf::uint64 space_taken() const;
  void set_space_taken(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Ref_count)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 from_;
  ::google::protobuf::uint64 to_;
  ::google::protobuf::uint64 ref_count_;
  ::google::protobuf::uint64 space_taken_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsRef_countImpl();
};
// -------------------------------------------------------------------

class Catalogue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalogue) */ {
 public:
  Catalogue();
  virtual ~Catalogue();

  Catalogue(const Catalogue& from);

  inline Catalogue& operator=(const Catalogue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Catalogue(Catalogue&& from) noexcept
    : Catalogue() {
    *this = ::std::move(from);
  }

  inline Catalogue& operator=(Catalogue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Catalogue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Catalogue* internal_default_instance() {
    return reinterpret_cast<const Catalogue*>(
               &_Catalogue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Catalogue* other);
  friend void swap(Catalogue& a, Catalogue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Catalogue* New() const PROTOBUF_FINAL { return New(NULL); }

  Catalogue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Catalogue& from);
  void MergeFrom(const Catalogue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalogue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.File_desc used_files = 1;
  int used_files_size() const;
  void clear_used_files();
  static const int kUsedFilesFieldNumber = 1;
  const ::proto::File_desc& used_files(int index) const;
  ::proto::File_desc* mutable_used_files(int index);
  ::proto::File_desc* add_used_files();
  ::google::protobuf::RepeatedPtrField< ::proto::File_desc >*
      mutable_used_files();
  const ::google::protobuf::RepeatedPtrField< ::proto::File_desc >&
      used_files() const;

  // @@protoc_insertion_point(class_scope:proto.Catalogue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::File_desc > used_files_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsCatalogueImpl();
};
// -------------------------------------------------------------------

class Catalog_header : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalog_header) */ {
 public:
  Catalog_header();
  virtual ~Catalog_header();

  Catalog_header(const Catalog_header& from);

  inline Catalog_header& operator=(const Catalog_header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Catalog_header(Catalog_header&& from) noexcept
    : Catalog_header() {
    *this = ::std::move(from);
  }

  inline Catalog_header& operator=(Catalog_header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Catalog_header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Catalog_header* internal_default_instance() {
    return reinterpret_cast<const Catalog_header*>(
               &_Catalog_header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Catalog_header* other);
  friend void swap(Catalog_header& a, Catalog_header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Catalog_header* New() const PROTOBUF_FINAL { return New(NULL); }

  Catalog_header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Catalog_header& from);
  void MergeFrom(const Catalog_header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalog_header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Filter filters = 2;
  int filters_size() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 2;
  const ::proto::Filter& filters(int index) const;
  ::proto::Filter* mutable_filters(int index);
  ::proto::Filter* add_filters();
  ::google::protobuf::RepeatedPtrField< ::proto::Filter >*
      mutable_filters();
  const ::google::protobuf::RepeatedPtrField< ::proto::Filter >&
      filters() const;

  // @@protoc_insertion_point(class_scope:proto.Catalog_header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::Filter > filters_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsCatalog_headerImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ZSTD_Compression_filter

// -------------------------------------------------------------------

// AES256_Encryption_filter

// bytes salt = 1;
inline void AES256_Encryption_filter::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AES256_Encryption_filter::salt() const {
  // @@protoc_insertion_point(field_get:proto.AES256_Encryption_filter.salt)
  return salt_.GetNoArena();
}
inline void AES256_Encryption_filter::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.AES256_Encryption_filter.salt)
}
#if LANG_CXX11
inline void AES256_Encryption_filter::set_salt(::std::string&& value) {
  
  salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.AES256_Encryption_filter.salt)
}
#endif
inline void AES256_Encryption_filter::set_salt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.AES256_Encryption_filter.salt)
}
inline void AES256_Encryption_filter::set_salt(const void* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.AES256_Encryption_filter.salt)
}
inline ::std::string* AES256_Encryption_filter::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:proto.AES256_Encryption_filter.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AES256_Encryption_filter::release_salt() {
  // @@protoc_insertion_point(field_release:proto.AES256_Encryption_filter.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AES256_Encryption_filter::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:proto.AES256_Encryption_filter.salt)
}

// -------------------------------------------------------------------

// Filter

// .proto.ZSTD_Compression_filter zstd_compression = 1;
inline bool Filter::has_zstd_compression() const {
  return filter_case() == kZstdCompression;
}
inline void Filter::set_has_zstd_compression() {
  _oneof_case_[0] = kZstdCompression;
}
inline void Filter::clear_zstd_compression() {
  if (has_zstd_compression()) {
    delete filter_.zstd_compression_;
    clear_has_filter();
  }
}
inline ::proto::ZSTD_Compression_filter* Filter::release_zstd_compression() {
  // @@protoc_insertion_point(field_release:proto.Filter.zstd_compression)
  if (has_zstd_compression()) {
    clear_has_filter();
      ::proto::ZSTD_Compression_filter* temp = filter_.zstd_compression_;
    filter_.zstd_compression_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::proto::ZSTD_Compression_filter& Filter::zstd_compression() const {
  // @@protoc_insertion_point(field_get:proto.Filter.zstd_compression)
  return has_zstd_compression()
      ? *filter_.zstd_compression_
      : *reinterpret_cast< ::proto::ZSTD_Compression_filter*>(&::proto::_ZSTD_Compression_filter_default_instance_);
}
inline ::proto::ZSTD_Compression_filter* Filter::mutable_zstd_compression() {
  if (!has_zstd_compression()) {
    clear_filter();
    set_has_zstd_compression();
    filter_.zstd_compression_ = new ::proto::ZSTD_Compression_filter;
  }
  // @@protoc_insertion_point(field_mutable:proto.Filter.zstd_compression)
  return filter_.zstd_compression_;
}

// .proto.AES256_Encryption_filter aes_encryption = 2;
inline bool Filter::has_aes_encryption() const {
  return filter_case() == kAesEncryption;
}
inline void Filter::set_has_aes_encryption() {
  _oneof_case_[0] = kAesEncryption;
}
inline void Filter::clear_aes_encryption() {
  if (has_aes_encryption()) {
    delete filter_.aes_encryption_;
    clear_has_filter();
  }
}
inline ::proto::AES256_Encryption_filter* Filter::release_aes_encryption() {
  // @@protoc_insertion_point(field_release:proto.Filter.aes_encryption)
  if (has_aes_encryption()) {
    clear_has_filter();
      ::proto::AES256_Encryption_filter* temp = filter_.aes_encryption_;
    filter_.aes_encryption_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::proto::AES256_Encryption_filter& Filter::aes_encryption() const {
  // @@protoc_insertion_point(field_get:proto.Filter.aes_encryption)
  return has_aes_encryption()
      ? *filter_.aes_encryption_
      : *reinterpret_cast< ::proto::AES256_Encryption_filter*>(&::proto::_AES256_Encryption_filter_default_instance_);
}
inline ::proto::AES256_Encryption_filter* Filter::mutable_aes_encryption() {
  if (!has_aes_encryption()) {
    clear_filter();
    set_has_aes_encryption();
    filter_.aes_encryption_ = new ::proto::AES256_Encryption_filter;
  }
  // @@protoc_insertion_point(field_mutable:proto.Filter.aes_encryption)
  return filter_.aes_encryption_;
}

inline bool Filter::has_filter() const {
  return filter_case() != FILTER_NOT_SET;
}
inline void Filter::clear_has_filter() {
  _oneof_case_[0] = FILTER_NOT_SET;
}
inline Filter::FilterCase Filter::filter_case() const {
  return Filter::FilterCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ref

// string content_fname = 1;
inline void Ref::clear_content_fname() {
  content_fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Ref::content_fname() const {
  // @@protoc_insertion_point(field_get:proto.Ref.content_fname)
  return content_fname_.GetNoArena();
}
inline void Ref::set_content_fname(const ::std::string& value) {
  
  content_fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Ref.content_fname)
}
#if LANG_CXX11
inline void Ref::set_content_fname(::std::string&& value) {
  
  content_fname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Ref.content_fname)
}
#endif
inline void Ref::set_content_fname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Ref.content_fname)
}
inline void Ref::set_content_fname(const char* value, size_t size) {
  
  content_fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Ref.content_fname)
}
inline ::std::string* Ref::mutable_content_fname() {
  
  // @@protoc_insertion_point(field_mutable:proto.Ref.content_fname)
  return content_fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ref::release_content_fname() {
  // @@protoc_insertion_point(field_release:proto.Ref.content_fname)
  
  return content_fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ref::set_allocated_content_fname(::std::string* content_fname) {
  if (content_fname != NULL) {
    
  } else {
    
  }
  content_fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content_fname);
  // @@protoc_insertion_point(field_set_allocated:proto.Ref.content_fname)
}

// uint64 from = 2;
inline void Ref::clear_from() {
  from_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref.from)
  return from_;
}
inline void Ref::set_from(::google::protobuf::uint64 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref.from)
}

// uint64 to = 3;
inline void Ref::clear_to() {
  to_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref::to() const {
  // @@protoc_insertion_point(field_get:proto.Ref.to)
  return to_;
}
inline void Ref::set_to(::google::protobuf::uint64 value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref.to)
}

// -------------------------------------------------------------------

// Fs_record

// string pathname = 1;
inline void Fs_record::clear_pathname() {
  pathname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fs_record::pathname() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.pathname)
  return pathname_.GetNoArena();
}
inline void Fs_record::set_pathname(const ::std::string& value) {
  
  pathname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.pathname)
}
#if LANG_CXX11
inline void Fs_record::set_pathname(::std::string&& value) {
  
  pathname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.pathname)
}
#endif
inline void Fs_record::set_pathname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pathname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.pathname)
}
inline void Fs_record::set_pathname(const char* value, size_t size) {
  
  pathname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.pathname)
}
inline ::std::string* Fs_record::mutable_pathname() {
  
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.pathname)
  return pathname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fs_record::release_pathname() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.pathname)
  
  return pathname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fs_record::set_allocated_pathname(::std::string* pathname) {
  if (pathname != NULL) {
    
  } else {
    
  }
  pathname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pathname);
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.pathname)
}

// uint32 unix_permissions = 2;
inline void Fs_record::clear_unix_permissions() {
  unix_permissions_ = 0u;
}
inline ::google::protobuf::uint32 Fs_record::unix_permissions() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.unix_permissions)
  return unix_permissions_;
}
inline void Fs_record::set_unix_permissions(::google::protobuf::uint32 value) {
  
  unix_permissions_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.unix_permissions)
}

// .proto.File_type type = 3;
inline void Fs_record::clear_type() {
  type_ = 0;
}
inline ::proto::File_type Fs_record::type() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.type)
  return static_cast< ::proto::File_type >(type_);
}
inline void Fs_record::set_type(::proto::File_type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.type)
}

// uint64 modified_seconds = 4;
inline void Fs_record::clear_modified_seconds() {
  modified_seconds_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Fs_record::modified_seconds() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.modified_seconds)
  return modified_seconds_;
}
inline void Fs_record::set_modified_seconds(::google::protobuf::uint64 value) {
  
  modified_seconds_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.modified_seconds)
}

// .proto.Ref ref = 5;
inline bool Fs_record::has_ref() const {
  return this != internal_default_instance() && ref_ != NULL;
}
inline void Fs_record::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) {
    delete ref_;
  }
  ref_ = NULL;
}
inline const ::proto::Ref& Fs_record::ref() const {
  const ::proto::Ref* p = ref_;
  // @@protoc_insertion_point(field_get:proto.Fs_record.ref)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Ref*>(
      &::proto::_Ref_default_instance_);
}
inline ::proto::Ref* Fs_record::release_ref() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.ref)
  
  ::proto::Ref* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline ::proto::Ref* Fs_record::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::proto::Ref;
  }
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.ref)
  return ref_;
}
inline void Fs_record::set_allocated_ref(::proto::Ref* ref) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ref_;
  }
  if (ref) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ref = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ref, submessage_arena);
    }
    
  } else {
    
  }
  ref_ = ref;
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.ref)
}

// string symlink_target = 6;
inline void Fs_record::clear_symlink_target() {
  symlink_target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fs_record::symlink_target() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.symlink_target)
  return symlink_target_.GetNoArena();
}
inline void Fs_record::set_symlink_target(const ::std::string& value) {
  
  symlink_target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.symlink_target)
}
#if LANG_CXX11
inline void Fs_record::set_symlink_target(::std::string&& value) {
  
  symlink_target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.symlink_target)
}
#endif
inline void Fs_record::set_symlink_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symlink_target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.symlink_target)
}
inline void Fs_record::set_symlink_target(const char* value, size_t size) {
  
  symlink_target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.symlink_target)
}
inline ::std::string* Fs_record::mutable_symlink_target() {
  
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.symlink_target)
  return symlink_target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fs_record::release_symlink_target() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.symlink_target)
  
  return symlink_target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fs_record::set_allocated_symlink_target(::std::string* symlink_target) {
  if (symlink_target != NULL) {
    
  } else {
    
  }
  symlink_target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symlink_target);
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.symlink_target)
}

// string posix_acl = 7;
inline void Fs_record::clear_posix_acl() {
  posix_acl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fs_record::posix_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_acl)
  return posix_acl_.GetNoArena();
}
inline void Fs_record::set_posix_acl(const ::std::string& value) {
  
  posix_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_acl)
}
#if LANG_CXX11
inline void Fs_record::set_posix_acl(::std::string&& value) {
  
  posix_acl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.posix_acl)
}
#endif
inline void Fs_record::set_posix_acl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  posix_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.posix_acl)
}
inline void Fs_record::set_posix_acl(const char* value, size_t size) {
  
  posix_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.posix_acl)
}
inline ::std::string* Fs_record::mutable_posix_acl() {
  
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_acl)
  return posix_acl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fs_record::release_posix_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_acl)
  
  return posix_acl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fs_record::set_allocated_posix_acl(::std::string* posix_acl) {
  if (posix_acl != NULL) {
    
  } else {
    
  }
  posix_acl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), posix_acl);
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_acl)
}

// string posix_default_acl = 8;
inline void Fs_record::clear_posix_default_acl() {
  posix_default_acl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fs_record::posix_default_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_default_acl)
  return posix_default_acl_.GetNoArena();
}
inline void Fs_record::set_posix_default_acl(const ::std::string& value) {
  
  posix_default_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_default_acl)
}
#if LANG_CXX11
inline void Fs_record::set_posix_default_acl(::std::string&& value) {
  
  posix_default_acl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.posix_default_acl)
}
#endif
inline void Fs_record::set_posix_default_acl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  posix_default_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.posix_default_acl)
}
inline void Fs_record::set_posix_default_acl(const char* value, size_t size) {
  
  posix_default_acl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.posix_default_acl)
}
inline ::std::string* Fs_record::mutable_posix_default_acl() {
  
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_default_acl)
  return posix_default_acl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fs_record::release_posix_default_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_default_acl)
  
  return posix_default_acl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fs_record::set_allocated_posix_default_acl(::std::string* posix_default_acl) {
  if (posix_default_acl != NULL) {
    
  } else {
    
  }
  posix_default_acl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), posix_default_acl);
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_default_acl)
}

// -------------------------------------------------------------------

// Fs_state

// repeated .proto.Fs_record rec = 1;
inline int Fs_state::rec_size() const {
  return rec_.size();
}
inline void Fs_state::clear_rec() {
  rec_.Clear();
}
inline const ::proto::Fs_record& Fs_state::rec(int index) const {
  // @@protoc_insertion_point(field_get:proto.Fs_state.rec)
  return rec_.Get(index);
}
inline ::proto::Fs_record* Fs_state::mutable_rec(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Fs_state.rec)
  return rec_.Mutable(index);
}
inline ::proto::Fs_record* Fs_state::add_rec() {
  // @@protoc_insertion_point(field_add:proto.Fs_state.rec)
  return rec_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >*
Fs_state::mutable_rec() {
  // @@protoc_insertion_point(field_mutable_list:proto.Fs_state.rec)
  return &rec_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >&
Fs_state::rec() const {
  // @@protoc_insertion_point(field_list:proto.Fs_state.rec)
  return rec_;
}

// -------------------------------------------------------------------

// File_desc

// string name = 1;
inline void File_desc::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File_desc::name() const {
  // @@protoc_insertion_point(field_get:proto.File_desc.name)
  return name_.GetNoArena();
}
inline void File_desc::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.File_desc.name)
}
#if LANG_CXX11
inline void File_desc::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.File_desc.name)
}
#endif
inline void File_desc::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.File_desc.name)
}
inline void File_desc::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.File_desc.name)
}
inline ::std::string* File_desc::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.File_desc.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File_desc::release_name() {
  // @@protoc_insertion_point(field_release:proto.File_desc.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File_desc::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.File_desc.name)
}

// repeated .proto.Filter filters = 2;
inline int File_desc::filters_size() const {
  return filters_.size();
}
inline void File_desc::clear_filters() {
  filters_.Clear();
}
inline const ::proto::Filter& File_desc::filters(int index) const {
  // @@protoc_insertion_point(field_get:proto.File_desc.filters)
  return filters_.Get(index);
}
inline ::proto::Filter* File_desc::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:proto.File_desc.filters)
  return filters_.Mutable(index);
}
inline ::proto::Filter* File_desc::add_filters() {
  // @@protoc_insertion_point(field_add:proto.File_desc.filters)
  return filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Filter >*
File_desc::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:proto.File_desc.filters)
  return &filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Filter >&
File_desc::filters() const {
  // @@protoc_insertion_point(field_list:proto.File_desc.filters)
  return filters_;
}

// repeated .proto.Ref_count refs = 3;
inline int File_desc::refs_size() const {
  return refs_.size();
}
inline void File_desc::clear_refs() {
  refs_.Clear();
}
inline const ::proto::Ref_count& File_desc::refs(int index) const {
  // @@protoc_insertion_point(field_get:proto.File_desc.refs)
  return refs_.Get(index);
}
inline ::proto::Ref_count* File_desc::mutable_refs(int index) {
  // @@protoc_insertion_point(field_mutable:proto.File_desc.refs)
  return refs_.Mutable(index);
}
inline ::proto::Ref_count* File_desc::add_refs() {
  // @@protoc_insertion_point(field_add:proto.File_desc.refs)
  return refs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >*
File_desc::mutable_refs() {
  // @@protoc_insertion_point(field_mutable_list:proto.File_desc.refs)
  return &refs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >&
File_desc::refs() const {
  // @@protoc_insertion_point(field_list:proto.File_desc.refs)
  return refs_;
}

// uint64 time_created = 4;
inline void File_desc::clear_time_created() {
  time_created_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 File_desc::time_created() const {
  // @@protoc_insertion_point(field_get:proto.File_desc.time_created)
  return time_created_;
}
inline void File_desc::set_time_created(::google::protobuf::uint64 value) {
  
  time_created_ = value;
  // @@protoc_insertion_point(field_set:proto.File_desc.time_created)
}

// -------------------------------------------------------------------

// Ref_count

// uint64 from = 1;
inline void Ref_count::clear_from() {
  from_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.from)
  return from_;
}
inline void Ref_count::set_from(::google::protobuf::uint64 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.from)
}

// uint64 to = 2;
inline void Ref_count::clear_to() {
  to_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::to() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.to)
  return to_;
}
inline void Ref_count::set_to(::google::protobuf::uint64 value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.to)
}

// uint64 ref_count = 3;
inline void Ref_count::clear_ref_count() {
  ref_count_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::ref_count() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.ref_count)
  return ref_count_;
}
inline void Ref_count::set_ref_count(::google::protobuf::uint64 value) {
  
  ref_count_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.ref_count)
}

// uint64 space_taken = 4;
inline void Ref_count::clear_space_taken() {
  space_taken_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ref_count::space_taken() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.space_taken)
  return space_taken_;
}
inline void Ref_count::set_space_taken(::google::protobuf::uint64 value) {
  
  space_taken_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.space_taken)
}

// -------------------------------------------------------------------

// Catalogue

// repeated .proto.File_desc used_files = 1;
inline int Catalogue::used_files_size() const {
  return used_files_.size();
}
inline void Catalogue::clear_used_files() {
  used_files_.Clear();
}
inline const ::proto::File_desc& Catalogue::used_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.used_files)
  return used_files_.Get(index);
}
inline ::proto::File_desc* Catalogue::mutable_used_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.used_files)
  return used_files_.Mutable(index);
}
inline ::proto::File_desc* Catalogue::add_used_files() {
  // @@protoc_insertion_point(field_add:proto.Catalogue.used_files)
  return used_files_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::File_desc >*
Catalogue::mutable_used_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.used_files)
  return &used_files_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::File_desc >&
Catalogue::used_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.used_files)
  return used_files_;
}

// -------------------------------------------------------------------

// Catalog_header

// repeated .proto.Filter filters = 2;
inline int Catalog_header::filters_size() const {
  return filters_.size();
}
inline void Catalog_header::clear_filters() {
  filters_.Clear();
}
inline const ::proto::Filter& Catalog_header::filters(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalog_header.filters)
  return filters_.Get(index);
}
inline ::proto::Filter* Catalog_header::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalog_header.filters)
  return filters_.Mutable(index);
}
inline ::proto::Filter* Catalog_header::add_filters() {
  // @@protoc_insertion_point(field_add:proto.Catalog_header.filters)
  return filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Filter >*
Catalog_header::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalog_header.filters)
  return &filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Filter >&
Catalog_header::filters() const {
  // @@protoc_insertion_point(field_list:proto.Catalog_header.filters)
  return filters_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::File_type> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_format_2eproto__INCLUDED
