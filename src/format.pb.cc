// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: format.proto

#include "format.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace proto {
class ZSTD_Compression_filterDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ZSTD_Compression_filter>
      _instance;
} _ZSTD_Compression_filter_default_instance_;
class Chapoly_Encryption_filterDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Chapoly_Encryption_filter>
      _instance;
} _Chapoly_Encryption_filter_default_instance_;
class Chacha_Encryption_filterDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Chacha_Encryption_filter>
      _instance;
} _Chacha_Encryption_filter_default_instance_;
class FiltersDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Filters>
      _instance;
  const ::proto::Chapoly_Encryption_filter* chapoly_encryption_;
  const ::proto::Chacha_Encryption_filter* chacha_encryption_;
} _Filters_default_instance_;
class Ref_to_refcountDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Ref_to_refcount>
      _instance;
} _Ref_to_refcount_default_instance_;
class Fs_recordDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Fs_record>
      _instance;
} _Fs_record_default_instance_;
class Fs_stateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Fs_state>
      _instance;
} _Fs_state_default_instance_;
class State_fileDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<State_file>
      _instance;
} _State_file_default_instance_;
class Content_fileDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Content_file>
      _instance;
} _Content_file_default_instance_;
class Ref_countDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Ref_count>
      _instance;
  ::google::protobuf::uint64 xxhash_;
  ::google::protobuf::internal::ArenaStringPtr blake2b_;
} _Ref_count_default_instance_;
class CatalogueDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Catalogue>
      _instance;
} _Catalogue_default_instance_;
class Catalog_headerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Catalog_header>
      _instance;
} _Catalog_header_default_instance_;
}  // namespace proto
namespace protobuf_format_2eproto {
void InitDefaultsZSTD_Compression_filterImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::proto::_ZSTD_Compression_filter_default_instance_;
    new (ptr) ::proto::ZSTD_Compression_filter();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::ZSTD_Compression_filter::InitAsDefaultInstance();
}

void InitDefaultsZSTD_Compression_filter() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsZSTD_Compression_filterImpl);
}

void InitDefaultsChapoly_Encryption_filterImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::proto::_Chapoly_Encryption_filter_default_instance_;
    new (ptr) ::proto::Chapoly_Encryption_filter();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Chapoly_Encryption_filter::InitAsDefaultInstance();
}

void InitDefaultsChapoly_Encryption_filter() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsChapoly_Encryption_filterImpl);
}

void InitDefaultsChacha_Encryption_filterImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::proto::_Chacha_Encryption_filter_default_instance_;
    new (ptr) ::proto::Chacha_Encryption_filter();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Chacha_Encryption_filter::InitAsDefaultInstance();
}

void InitDefaultsChacha_Encryption_filter() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsChacha_Encryption_filterImpl);
}

void InitDefaultsFiltersImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_format_2eproto::InitDefaultsZSTD_Compression_filter();
  protobuf_format_2eproto::InitDefaultsChapoly_Encryption_filter();
  protobuf_format_2eproto::InitDefaultsChacha_Encryption_filter();
  {
    void* ptr = &::proto::_Filters_default_instance_;
    new (ptr) ::proto::Filters();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Filters::InitAsDefaultInstance();
}

void InitDefaultsFilters() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsFiltersImpl);
}

void InitDefaultsRef_to_refcountImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::proto::_Ref_to_refcount_default_instance_;
    new (ptr) ::proto::Ref_to_refcount();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Ref_to_refcount::InitAsDefaultInstance();
}

void InitDefaultsRef_to_refcount() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsRef_to_refcountImpl);
}

void InitDefaultsFs_recordImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_format_2eproto::InitDefaultsRef_to_refcount();
  {
    void* ptr = &::proto::_Fs_record_default_instance_;
    new (ptr) ::proto::Fs_record();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Fs_record::InitAsDefaultInstance();
}

void InitDefaultsFs_record() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsFs_recordImpl);
}

void InitDefaultsFs_stateImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_format_2eproto::InitDefaultsFs_record();
  {
    void* ptr = &::proto::_Fs_state_default_instance_;
    new (ptr) ::proto::Fs_state();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Fs_state::InitAsDefaultInstance();
}

void InitDefaultsFs_state() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsFs_stateImpl);
}

void InitDefaultsState_fileImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_format_2eproto::InitDefaultsFilters();
  {
    void* ptr = &::proto::_State_file_default_instance_;
    new (ptr) ::proto::State_file();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::State_file::InitAsDefaultInstance();
}

void InitDefaultsState_file() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsState_fileImpl);
}

void InitDefaultsContent_fileImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_format_2eproto::InitDefaultsFilters();
  protobuf_format_2eproto::InitDefaultsRef_count();
  {
    void* ptr = &::proto::_Content_file_default_instance_;
    new (ptr) ::proto::Content_file();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Content_file::InitAsDefaultInstance();
}

void InitDefaultsContent_file() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsContent_fileImpl);
}

void InitDefaultsRef_countImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::proto::_Ref_count_default_instance_;
    new (ptr) ::proto::Ref_count();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Ref_count::InitAsDefaultInstance();
}

void InitDefaultsRef_count() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsRef_countImpl);
}

void InitDefaultsCatalogueImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_format_2eproto::InitDefaultsState_file();
  protobuf_format_2eproto::InitDefaultsContent_file();
  {
    void* ptr = &::proto::_Catalogue_default_instance_;
    new (ptr) ::proto::Catalogue();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Catalogue::InitAsDefaultInstance();
}

void InitDefaultsCatalogue() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsCatalogueImpl);
}

void InitDefaultsCatalog_headerImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_format_2eproto::InitDefaultsFilters();
  {
    void* ptr = &::proto::_Catalog_header_default_instance_;
    new (ptr) ::proto::Catalog_header();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::Catalog_header::InitAsDefaultInstance();
}

void InitDefaultsCatalog_header() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsCatalog_headerImpl);
}

}  // namespace protobuf_format_2eproto
namespace proto {
bool File_type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void ZSTD_Compression_filter::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ZSTD_Compression_filter::ZSTD_Compression_filter()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsZSTD_Compression_filter();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.ZSTD_Compression_filter)
}
ZSTD_Compression_filter::ZSTD_Compression_filter(const ZSTD_Compression_filter& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.ZSTD_Compression_filter)
}

void ZSTD_Compression_filter::SharedCtor() {
  _cached_size_ = 0;
}

ZSTD_Compression_filter::~ZSTD_Compression_filter() {
  // @@protoc_insertion_point(destructor:proto.ZSTD_Compression_filter)
  SharedDtor();
}

void ZSTD_Compression_filter::SharedDtor() {
}

void ZSTD_Compression_filter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ZSTD_Compression_filter& ZSTD_Compression_filter::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsZSTD_Compression_filter();
  return *internal_default_instance();
}

ZSTD_Compression_filter* ZSTD_Compression_filter::New(::google::protobuf::Arena* arena) const {
  ZSTD_Compression_filter* n = new ZSTD_Compression_filter;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ZSTD_Compression_filter::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ZSTD_Compression_filter)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ZSTD_Compression_filter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.ZSTD_Compression_filter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:proto.ZSTD_Compression_filter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.ZSTD_Compression_filter)
  return false;
#undef DO_
}

void ZSTD_Compression_filter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.ZSTD_Compression_filter)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.ZSTD_Compression_filter)
}

size_t ZSTD_Compression_filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ZSTD_Compression_filter)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ZSTD_Compression_filter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ZSTD_Compression_filter*>(&from));
}

void ZSTD_Compression_filter::MergeFrom(const ZSTD_Compression_filter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.ZSTD_Compression_filter)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ZSTD_Compression_filter::CopyFrom(const ZSTD_Compression_filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ZSTD_Compression_filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZSTD_Compression_filter::IsInitialized() const {
  return true;
}

void ZSTD_Compression_filter::Swap(ZSTD_Compression_filter* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ZSTD_Compression_filter::InternalSwap(ZSTD_Compression_filter* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ZSTD_Compression_filter::GetTypeName() const {
  return "proto.ZSTD_Compression_filter";
}


// ===================================================================

void Chapoly_Encryption_filter::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Chapoly_Encryption_filter::kIvFieldNumber;
const int Chapoly_Encryption_filter::kKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Chapoly_Encryption_filter::Chapoly_Encryption_filter()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsChapoly_Encryption_filter();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Chapoly_Encryption_filter)
}
Chapoly_Encryption_filter::Chapoly_Encryption_filter(const Chapoly_Encryption_filter& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_iv()) {
    iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
  }
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.Chapoly_Encryption_filter)
}

void Chapoly_Encryption_filter::SharedCtor() {
  _cached_size_ = 0;
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Chapoly_Encryption_filter::~Chapoly_Encryption_filter() {
  // @@protoc_insertion_point(destructor:proto.Chapoly_Encryption_filter)
  SharedDtor();
}

void Chapoly_Encryption_filter::SharedDtor() {
  iv_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Chapoly_Encryption_filter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Chapoly_Encryption_filter& Chapoly_Encryption_filter::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsChapoly_Encryption_filter();
  return *internal_default_instance();
}

Chapoly_Encryption_filter* Chapoly_Encryption_filter::New(::google::protobuf::Arena* arena) const {
  Chapoly_Encryption_filter* n = new Chapoly_Encryption_filter;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Chapoly_Encryption_filter::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Chapoly_Encryption_filter)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!iv_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*iv_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*key_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Chapoly_Encryption_filter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Chapoly_Encryption_filter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes iv = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes key = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Chapoly_Encryption_filter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Chapoly_Encryption_filter)
  return false;
#undef DO_
}

void Chapoly_Encryption_filter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Chapoly_Encryption_filter)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes iv = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->iv(), output);
  }

  // optional bytes key = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->key(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Chapoly_Encryption_filter)
}

size_t Chapoly_Encryption_filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Chapoly_Encryption_filter)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required bytes iv = 1;
  if (has_iv()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->iv());
  }
  // optional bytes key = 2;
  if (has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->key());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Chapoly_Encryption_filter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Chapoly_Encryption_filter*>(&from));
}

void Chapoly_Encryption_filter::MergeFrom(const Chapoly_Encryption_filter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Chapoly_Encryption_filter)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_iv();
      iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
  }
}

void Chapoly_Encryption_filter::CopyFrom(const Chapoly_Encryption_filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Chapoly_Encryption_filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chapoly_Encryption_filter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Chapoly_Encryption_filter::Swap(Chapoly_Encryption_filter* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Chapoly_Encryption_filter::InternalSwap(Chapoly_Encryption_filter* other) {
  using std::swap;
  iv_.Swap(&other->iv_);
  key_.Swap(&other->key_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Chapoly_Encryption_filter::GetTypeName() const {
  return "proto.Chapoly_Encryption_filter";
}


// ===================================================================

void Chacha_Encryption_filter::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Chacha_Encryption_filter::kIvFieldNumber;
const int Chacha_Encryption_filter::kKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Chacha_Encryption_filter::Chacha_Encryption_filter()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsChacha_Encryption_filter();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Chacha_Encryption_filter)
}
Chacha_Encryption_filter::Chacha_Encryption_filter(const Chacha_Encryption_filter& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_iv()) {
    iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
  }
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.Chacha_Encryption_filter)
}

void Chacha_Encryption_filter::SharedCtor() {
  _cached_size_ = 0;
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Chacha_Encryption_filter::~Chacha_Encryption_filter() {
  // @@protoc_insertion_point(destructor:proto.Chacha_Encryption_filter)
  SharedDtor();
}

void Chacha_Encryption_filter::SharedDtor() {
  iv_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Chacha_Encryption_filter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Chacha_Encryption_filter& Chacha_Encryption_filter::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsChacha_Encryption_filter();
  return *internal_default_instance();
}

Chacha_Encryption_filter* Chacha_Encryption_filter::New(::google::protobuf::Arena* arena) const {
  Chacha_Encryption_filter* n = new Chacha_Encryption_filter;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Chacha_Encryption_filter::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Chacha_Encryption_filter)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!iv_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*iv_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*key_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Chacha_Encryption_filter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Chacha_Encryption_filter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes iv = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes key = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Chacha_Encryption_filter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Chacha_Encryption_filter)
  return false;
#undef DO_
}

void Chacha_Encryption_filter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Chacha_Encryption_filter)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes iv = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->iv(), output);
  }

  // optional bytes key = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->key(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Chacha_Encryption_filter)
}

size_t Chacha_Encryption_filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Chacha_Encryption_filter)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required bytes iv = 1;
  if (has_iv()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->iv());
  }
  // optional bytes key = 2;
  if (has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->key());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Chacha_Encryption_filter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Chacha_Encryption_filter*>(&from));
}

void Chacha_Encryption_filter::MergeFrom(const Chacha_Encryption_filter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Chacha_Encryption_filter)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_iv();
      iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
  }
}

void Chacha_Encryption_filter::CopyFrom(const Chacha_Encryption_filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Chacha_Encryption_filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chacha_Encryption_filter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Chacha_Encryption_filter::Swap(Chacha_Encryption_filter* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Chacha_Encryption_filter::InternalSwap(Chacha_Encryption_filter* other) {
  using std::swap;
  iv_.Swap(&other->iv_);
  key_.Swap(&other->key_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Chacha_Encryption_filter::GetTypeName() const {
  return "proto.Chacha_Encryption_filter";
}


// ===================================================================

void Filters::InitAsDefaultInstance() {
  ::proto::_Filters_default_instance_._instance.get_mutable()->zstd_compression_ = const_cast< ::proto::ZSTD_Compression_filter*>(
      ::proto::ZSTD_Compression_filter::internal_default_instance());
}
void Filters::set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_encryption();
  if (chapoly_encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chapoly_encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chapoly_encryption, submessage_arena);
    }
    set_has_chapoly_encryption();
    encryption_.chapoly_encryption_ = chapoly_encryption;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Filters.chapoly_encryption)
}
void Filters::set_allocated_chacha_encryption(::proto::Chacha_Encryption_filter* chacha_encryption) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_encryption();
  if (chacha_encryption) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chacha_encryption = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chacha_encryption, submessage_arena);
    }
    set_has_chacha_encryption();
    encryption_.chacha_encryption_ = chacha_encryption;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Filters.chacha_encryption)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Filters::kZstdCompressionFieldNumber;
const int Filters::kChapolyEncryptionFieldNumber;
const int Filters::kChachaEncryptionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Filters::Filters()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsFilters();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Filters)
}
Filters::Filters(const Filters& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_zstd_compression()) {
    zstd_compression_ = new ::proto::ZSTD_Compression_filter(*from.zstd_compression_);
  } else {
    zstd_compression_ = NULL;
  }
  clear_has_encryption();
  switch (from.encryption_case()) {
    case kChapolyEncryption: {
      mutable_chapoly_encryption()->::proto::Chapoly_Encryption_filter::MergeFrom(from.chapoly_encryption());
      break;
    }
    case kChachaEncryption: {
      mutable_chacha_encryption()->::proto::Chacha_Encryption_filter::MergeFrom(from.chacha_encryption());
      break;
    }
    case ENCRYPTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.Filters)
}

void Filters::SharedCtor() {
  _cached_size_ = 0;
  zstd_compression_ = NULL;
  clear_has_encryption();
}

Filters::~Filters() {
  // @@protoc_insertion_point(destructor:proto.Filters)
  SharedDtor();
}

void Filters::SharedDtor() {
  if (this != internal_default_instance()) delete zstd_compression_;
  if (has_encryption()) {
    clear_encryption();
  }
}

void Filters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Filters& Filters::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsFilters();
  return *internal_default_instance();
}

Filters* Filters::New(::google::protobuf::Arena* arena) const {
  Filters* n = new Filters;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Filters::clear_encryption() {
// @@protoc_insertion_point(one_of_clear_start:proto.Filters)
  switch (encryption_case()) {
    case kChapolyEncryption: {
      delete encryption_.chapoly_encryption_;
      break;
    }
    case kChachaEncryption: {
      delete encryption_.chacha_encryption_;
      break;
    }
    case ENCRYPTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ENCRYPTION_NOT_SET;
}


void Filters::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Filters)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(zstd_compression_ != NULL);
    zstd_compression_->Clear();
  }
  clear_encryption();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Filters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Filters)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.ZSTD_Compression_filter zstd_compression = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_zstd_compression()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_chapoly_encryption()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.Chacha_Encryption_filter chacha_encryption = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_chacha_encryption()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Filters)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Filters)
  return false;
#undef DO_
}

void Filters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Filters)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.ZSTD_Compression_filter zstd_compression = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->zstd_compression_, output);
  }

  switch (encryption_case()) {
    case kChapolyEncryption:
      ::google::protobuf::internal::WireFormatLite::WriteMessage(
        2, *encryption_.chapoly_encryption_, output);
      break;
    case kChachaEncryption:
      ::google::protobuf::internal::WireFormatLite::WriteMessage(
        3, *encryption_.chacha_encryption_, output);
      break;
    default: ;
  }
  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Filters)
}

size_t Filters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Filters)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // optional .proto.ZSTD_Compression_filter zstd_compression = 1;
  if (has_zstd_compression()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->zstd_compression_);
  }

  switch (encryption_case()) {
    // optional .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
    case kChapolyEncryption: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *encryption_.chapoly_encryption_);
      break;
    }
    // optional .proto.Chacha_Encryption_filter chacha_encryption = 3;
    case kChachaEncryption: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *encryption_.chacha_encryption_);
      break;
    }
    case ENCRYPTION_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Filters::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Filters*>(&from));
}

void Filters::MergeFrom(const Filters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Filters)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_zstd_compression()) {
    mutable_zstd_compression()->::proto::ZSTD_Compression_filter::MergeFrom(from.zstd_compression());
  }
  switch (from.encryption_case()) {
    case kChapolyEncryption: {
      mutable_chapoly_encryption()->::proto::Chapoly_Encryption_filter::MergeFrom(from.chapoly_encryption());
      break;
    }
    case kChachaEncryption: {
      mutable_chacha_encryption()->::proto::Chacha_Encryption_filter::MergeFrom(from.chacha_encryption());
      break;
    }
    case ENCRYPTION_NOT_SET: {
      break;
    }
  }
}

void Filters::CopyFrom(const Filters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Filters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filters::IsInitialized() const {
  switch (encryption_case()) {
    case kChapolyEncryption: {
      if (has_chapoly_encryption()) {
        if (!this->chapoly_encryption().IsInitialized()) return false;
      }
      break;
    }
    case kChachaEncryption: {
      if (has_chacha_encryption()) {
        if (!this->chacha_encryption().IsInitialized()) return false;
      }
      break;
    }
    case ENCRYPTION_NOT_SET: {
      break;
    }
  }
  return true;
}

void Filters::Swap(Filters* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Filters::InternalSwap(Filters* other) {
  using std::swap;
  swap(zstd_compression_, other->zstd_compression_);
  swap(encryption_, other->encryption_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Filters::GetTypeName() const {
  return "proto.Filters";
}


// ===================================================================

void Ref_to_refcount::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Ref_to_refcount::kContentFnameFieldNumber;
const int Ref_to_refcount::kFromFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Ref_to_refcount::Ref_to_refcount()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsRef_to_refcount();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Ref_to_refcount)
}
Ref_to_refcount::Ref_to_refcount(const Ref_to_refcount& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  content_fname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_content_fname()) {
    content_fname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.content_fname_);
  }
  from_ = from.from_;
  // @@protoc_insertion_point(copy_constructor:proto.Ref_to_refcount)
}

void Ref_to_refcount::SharedCtor() {
  _cached_size_ = 0;
  content_fname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  from_ = GOOGLE_ULONGLONG(0);
}

Ref_to_refcount::~Ref_to_refcount() {
  // @@protoc_insertion_point(destructor:proto.Ref_to_refcount)
  SharedDtor();
}

void Ref_to_refcount::SharedDtor() {
  content_fname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Ref_to_refcount::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Ref_to_refcount& Ref_to_refcount::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsRef_to_refcount();
  return *internal_default_instance();
}

Ref_to_refcount* Ref_to_refcount::New(::google::protobuf::Arena* arena) const {
  Ref_to_refcount* n = new Ref_to_refcount;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Ref_to_refcount::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Ref_to_refcount)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!content_fname_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*content_fname_.UnsafeRawStringPointer())->clear();
  }
  from_ = GOOGLE_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Ref_to_refcount::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Ref_to_refcount)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string content_fname = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content_fname()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 from = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_from();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &from_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Ref_to_refcount)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Ref_to_refcount)
  return false;
#undef DO_
}

void Ref_to_refcount::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Ref_to_refcount)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string content_fname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->content_fname(), output);
  }

  // required uint64 from = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->from(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Ref_to_refcount)
}

size_t Ref_to_refcount::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:proto.Ref_to_refcount)
  size_t total_size = 0;

  if (has_content_fname()) {
    // required string content_fname = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->content_fname());
  }

  if (has_from()) {
    // required uint64 from = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->from());
  }

  return total_size;
}
size_t Ref_to_refcount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Ref_to_refcount)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string content_fname = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->content_fname());

    // required uint64 from = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->from());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ref_to_refcount::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Ref_to_refcount*>(&from));
}

void Ref_to_refcount::MergeFrom(const Ref_to_refcount& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Ref_to_refcount)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_content_fname();
      content_fname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.content_fname_);
    }
    if (cached_has_bits & 0x00000002u) {
      from_ = from.from_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ref_to_refcount::CopyFrom(const Ref_to_refcount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Ref_to_refcount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ref_to_refcount::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void Ref_to_refcount::Swap(Ref_to_refcount* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Ref_to_refcount::InternalSwap(Ref_to_refcount* other) {
  using std::swap;
  content_fname_.Swap(&other->content_fname_);
  swap(from_, other->from_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Ref_to_refcount::GetTypeName() const {
  return "proto.Ref_to_refcount";
}


// ===================================================================

void Fs_record::InitAsDefaultInstance() {
  ::proto::_Fs_record_default_instance_._instance.get_mutable()->ref_ = const_cast< ::proto::Ref_to_refcount*>(
      ::proto::Ref_to_refcount::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Fs_record::kPathnameFieldNumber;
const int Fs_record::kTypeFieldNumber;
const int Fs_record::kModifiedSecondsFieldNumber;
const int Fs_record::kRefFieldNumber;
const int Fs_record::kSymlinkTargetFieldNumber;
const int Fs_record::kUnixPermissionsFieldNumber;
const int Fs_record::kPosixAclFieldNumber;
const int Fs_record::kPosixDefaultAclFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Fs_record::Fs_record()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsFs_record();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Fs_record)
}
Fs_record::Fs_record(const Fs_record& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  pathname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pathname()) {
    pathname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pathname_);
  }
  symlink_target_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_symlink_target()) {
    symlink_target_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.symlink_target_);
  }
  posix_acl_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_posix_acl()) {
    posix_acl_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.posix_acl_);
  }
  posix_default_acl_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_posix_default_acl()) {
    posix_default_acl_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.posix_default_acl_);
  }
  if (from.has_ref()) {
    ref_ = new ::proto::Ref_to_refcount(*from.ref_);
  } else {
    ref_ = NULL;
  }
  ::memcpy(&modified_seconds_, &from.modified_seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&unix_permissions_) -
    reinterpret_cast<char*>(&modified_seconds_)) + sizeof(unix_permissions_));
  // @@protoc_insertion_point(copy_constructor:proto.Fs_record)
}

void Fs_record::SharedCtor() {
  _cached_size_ = 0;
  pathname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  symlink_target_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  posix_acl_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  posix_default_acl_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&ref_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&unix_permissions_) -
      reinterpret_cast<char*>(&ref_)) + sizeof(unix_permissions_));
}

Fs_record::~Fs_record() {
  // @@protoc_insertion_point(destructor:proto.Fs_record)
  SharedDtor();
}

void Fs_record::SharedDtor() {
  pathname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  symlink_target_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  posix_acl_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  posix_default_acl_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete ref_;
}

void Fs_record::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Fs_record& Fs_record::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsFs_record();
  return *internal_default_instance();
}

Fs_record* Fs_record::New(::google::protobuf::Arena* arena) const {
  Fs_record* n = new Fs_record;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Fs_record::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Fs_record)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!pathname_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*pathname_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!symlink_target_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*symlink_target_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!posix_acl_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*posix_acl_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(!posix_default_acl_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*posix_default_acl_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(ref_ != NULL);
      ref_->Clear();
    }
  }
  if (cached_has_bits & 224u) {
    ::memset(&modified_seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unix_permissions_) -
        reinterpret_cast<char*>(&modified_seconds_)) + sizeof(unix_permissions_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Fs_record::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Fs_record)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string pathname = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pathname()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .proto.File_type type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::proto::File_type_IsValid(value)) {
            set_type(static_cast< ::proto::File_type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 modified_seconds = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_modified_seconds();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &modified_seconds_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.Ref_to_refcount ref = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_ref()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string symlink_target = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_symlink_target()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 unix_permissions = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_unix_permissions();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unix_permissions_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string posix_acl = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_posix_acl()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string posix_default_acl = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_posix_default_acl()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Fs_record)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Fs_record)
  return false;
#undef DO_
}

void Fs_record::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Fs_record)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string pathname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->pathname(), output);
  }

  // required .proto.File_type type = 2;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // required uint64 modified_seconds = 3;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->modified_seconds(), output);
  }

  // optional .proto.Ref_to_refcount ref = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->ref_, output);
  }

  // optional string symlink_target = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->symlink_target(), output);
  }

  // required uint32 unix_permissions = 6;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unix_permissions(), output);
  }

  // optional string posix_acl = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->posix_acl(), output);
  }

  // optional string posix_default_acl = 8;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->posix_default_acl(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Fs_record)
}

size_t Fs_record::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:proto.Fs_record)
  size_t total_size = 0;

  if (has_pathname()) {
    // required string pathname = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->pathname());
  }

  if (has_modified_seconds()) {
    // required uint64 modified_seconds = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->modified_seconds());
  }

  if (has_type()) {
    // required .proto.File_type type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (has_unix_permissions()) {
    // required uint32 unix_permissions = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->unix_permissions());
  }

  return total_size;
}
size_t Fs_record::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Fs_record)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x000000e1) ^ 0x000000e1) == 0) {  // All required fields are present.
    // required string pathname = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->pathname());

    // required uint64 modified_seconds = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->modified_seconds());

    // required .proto.File_type type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

    // required uint32 unix_permissions = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->unix_permissions());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 30u) {
    // optional string symlink_target = 5;
    if (has_symlink_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->symlink_target());
    }

    // optional string posix_acl = 7;
    if (has_posix_acl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->posix_acl());
    }

    // optional string posix_default_acl = 8;
    if (has_posix_default_acl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->posix_default_acl());
    }

    // optional .proto.Ref_to_refcount ref = 4;
    if (has_ref()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->ref_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Fs_record::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Fs_record*>(&from));
}

void Fs_record::MergeFrom(const Fs_record& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Fs_record)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_pathname();
      pathname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pathname_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_symlink_target();
      symlink_target_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.symlink_target_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_posix_acl();
      posix_acl_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.posix_acl_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_posix_default_acl();
      posix_default_acl_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.posix_default_acl_);
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_ref()->::proto::Ref_to_refcount::MergeFrom(from.ref());
    }
    if (cached_has_bits & 0x00000020u) {
      modified_seconds_ = from.modified_seconds_;
    }
    if (cached_has_bits & 0x00000040u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000080u) {
      unix_permissions_ = from.unix_permissions_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Fs_record::CopyFrom(const Fs_record& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Fs_record)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fs_record::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000e1) != 0x000000e1) return false;
  if (has_ref()) {
    if (!this->ref_->IsInitialized()) return false;
  }
  return true;
}

void Fs_record::Swap(Fs_record* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Fs_record::InternalSwap(Fs_record* other) {
  using std::swap;
  pathname_.Swap(&other->pathname_);
  symlink_target_.Swap(&other->symlink_target_);
  posix_acl_.Swap(&other->posix_acl_);
  posix_default_acl_.Swap(&other->posix_default_acl_);
  swap(ref_, other->ref_);
  swap(modified_seconds_, other->modified_seconds_);
  swap(type_, other->type_);
  swap(unix_permissions_, other->unix_permissions_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Fs_record::GetTypeName() const {
  return "proto.Fs_record";
}


// ===================================================================

void Fs_state::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Fs_state::kRecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Fs_state::Fs_state()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsFs_state();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Fs_state)
}
Fs_state::Fs_state(const Fs_state& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      rec_(from.rec_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.Fs_state)
}

void Fs_state::SharedCtor() {
  _cached_size_ = 0;
}

Fs_state::~Fs_state() {
  // @@protoc_insertion_point(destructor:proto.Fs_state)
  SharedDtor();
}

void Fs_state::SharedDtor() {
}

void Fs_state::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Fs_state& Fs_state::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsFs_state();
  return *internal_default_instance();
}

Fs_state* Fs_state::New(::google::protobuf::Arena* arena) const {
  Fs_state* n = new Fs_state;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Fs_state::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Fs_state)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  rec_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Fs_state::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Fs_state)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.Fs_record rec = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_rec()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Fs_state)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Fs_state)
  return false;
#undef DO_
}

void Fs_state::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Fs_state)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.Fs_record rec = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->rec_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->rec(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Fs_state)
}

size_t Fs_state::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Fs_state)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .proto.Fs_record rec = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->rec_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->rec(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Fs_state::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Fs_state*>(&from));
}

void Fs_state::MergeFrom(const Fs_state& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Fs_state)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  rec_.MergeFrom(from.rec_);
}

void Fs_state::CopyFrom(const Fs_state& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Fs_state)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fs_state::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->rec())) return false;
  return true;
}

void Fs_state::Swap(Fs_state* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Fs_state::InternalSwap(Fs_state* other) {
  using std::swap;
  rec_.InternalSwap(&other->rec_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Fs_state::GetTypeName() const {
  return "proto.Fs_state";
}


// ===================================================================

void State_file::InitAsDefaultInstance() {
  ::proto::_State_file_default_instance_._instance.get_mutable()->filters_ = const_cast< ::proto::Filters*>(
      ::proto::Filters::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int State_file::kFiltersFieldNumber;
const int State_file::kNameFieldNumber;
const int State_file::kTimeCreatedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

State_file::State_file()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsState_file();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.State_file)
}
State_file::State_file(const State_file& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_filters()) {
    filters_ = new ::proto::Filters(*from.filters_);
  } else {
    filters_ = NULL;
  }
  time_created_ = from.time_created_;
  // @@protoc_insertion_point(copy_constructor:proto.State_file)
}

void State_file::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&filters_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_created_) -
      reinterpret_cast<char*>(&filters_)) + sizeof(time_created_));
}

State_file::~State_file() {
  // @@protoc_insertion_point(destructor:proto.State_file)
  SharedDtor();
}

void State_file::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete filters_;
}

void State_file::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const State_file& State_file::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsState_file();
  return *internal_default_instance();
}

State_file* State_file::New(::google::protobuf::Arena* arena) const {
  State_file* n = new State_file;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void State_file::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.State_file)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(filters_ != NULL);
      filters_->Clear();
    }
  }
  time_created_ = GOOGLE_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool State_file::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.State_file)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.Filters filters = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_filters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string name = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 time_created = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_time_created();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &time_created_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.State_file)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.State_file)
  return false;
#undef DO_
}

void State_file::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.State_file)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.Filters filters = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->filters_, output);
  }

  // required string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // required uint64 time_created = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->time_created(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.State_file)
}

size_t State_file::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:proto.State_file)
  size_t total_size = 0;

  if (has_name()) {
    // required string name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_time_created()) {
    // required uint64 time_created = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->time_created());
  }

  return total_size;
}
size_t State_file::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.State_file)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required string name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required uint64 time_created = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->time_created());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .proto.Filters filters = 1;
  if (has_filters()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->filters_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void State_file::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const State_file*>(&from));
}

void State_file::MergeFrom(const State_file& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.State_file)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_filters()->::proto::Filters::MergeFrom(from.filters());
    }
    if (cached_has_bits & 0x00000004u) {
      time_created_ = from.time_created_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void State_file::CopyFrom(const State_file& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.State_file)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State_file::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  if (has_filters()) {
    if (!this->filters_->IsInitialized()) return false;
  }
  return true;
}

void State_file::Swap(State_file* other) {
  if (other == this) return;
  InternalSwap(other);
}
void State_file::InternalSwap(State_file* other) {
  using std::swap;
  name_.Swap(&other->name_);
  swap(filters_, other->filters_);
  swap(time_created_, other->time_created_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string State_file::GetTypeName() const {
  return "proto.State_file";
}


// ===================================================================

void Content_file::InitAsDefaultInstance() {
  ::proto::_Content_file_default_instance_._instance.get_mutable()->filters_ = const_cast< ::proto::Filters*>(
      ::proto::Filters::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Content_file::kFiltersFieldNumber;
const int Content_file::kNameFieldNumber;
const int Content_file::kRefsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Content_file::Content_file()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsContent_file();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Content_file)
}
Content_file::Content_file(const Content_file& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      refs_(from.refs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_filters()) {
    filters_ = new ::proto::Filters(*from.filters_);
  } else {
    filters_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:proto.Content_file)
}

void Content_file::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  filters_ = NULL;
}

Content_file::~Content_file() {
  // @@protoc_insertion_point(destructor:proto.Content_file)
  SharedDtor();
}

void Content_file::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete filters_;
}

void Content_file::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Content_file& Content_file::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsContent_file();
  return *internal_default_instance();
}

Content_file* Content_file::New(::google::protobuf::Arena* arena) const {
  Content_file* n = new Content_file;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Content_file::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Content_file)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  refs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(filters_ != NULL);
      filters_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Content_file::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Content_file)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.Filters filters = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_filters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string name = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .proto.Ref_count refs = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_refs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Content_file)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Content_file)
  return false;
#undef DO_
}

void Content_file::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Content_file)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.Filters filters = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->filters_, output);
  }

  // required string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // repeated .proto.Ref_count refs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->refs_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->refs(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Content_file)
}

size_t Content_file::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Content_file)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required string name = 2;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  // repeated .proto.Ref_count refs = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->refs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->refs(static_cast<int>(i)));
    }
  }

  // optional .proto.Filters filters = 1;
  if (has_filters()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->filters_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Content_file::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Content_file*>(&from));
}

void Content_file::MergeFrom(const Content_file& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Content_file)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  refs_.MergeFrom(from.refs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_filters()->::proto::Filters::MergeFrom(from.filters());
    }
  }
}

void Content_file::CopyFrom(const Content_file& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Content_file)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Content_file::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->refs())) return false;
  if (has_filters()) {
    if (!this->filters_->IsInitialized()) return false;
  }
  return true;
}

void Content_file::Swap(Content_file* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Content_file::InternalSwap(Content_file* other) {
  using std::swap;
  refs_.InternalSwap(&other->refs_);
  name_.Swap(&other->name_);
  swap(filters_, other->filters_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Content_file::GetTypeName() const {
  return "proto.Content_file";
}


// ===================================================================

void Ref_count::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Ref_count::kFromFieldNumber;
const int Ref_count::kToFieldNumber;
const int Ref_count::kRefCountFieldNumber;
const int Ref_count::kSpaceTakenFieldNumber;
const int Ref_count::kXxhashFieldNumber;
const int Ref_count::kBlake2BFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Ref_count::Ref_count()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsRef_count();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Ref_count)
}
Ref_count::Ref_count(const Ref_count& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&from_, &from.from_,
    static_cast<size_t>(reinterpret_cast<char*>(&space_taken_) -
    reinterpret_cast<char*>(&from_)) + sizeof(space_taken_));
  clear_has_csum();
  switch (from.csum_case()) {
    case kXxhash: {
      set_xxhash(from.xxhash());
      break;
    }
    case kBlake2B: {
      set_blake2b(from.blake2b());
      break;
    }
    case CSUM_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.Ref_count)
}

void Ref_count::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&from_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&space_taken_) -
      reinterpret_cast<char*>(&from_)) + sizeof(space_taken_));
  clear_has_csum();
}

Ref_count::~Ref_count() {
  // @@protoc_insertion_point(destructor:proto.Ref_count)
  SharedDtor();
}

void Ref_count::SharedDtor() {
  if (has_csum()) {
    clear_csum();
  }
}

void Ref_count::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Ref_count& Ref_count::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsRef_count();
  return *internal_default_instance();
}

Ref_count* Ref_count::New(::google::protobuf::Arena* arena) const {
  Ref_count* n = new Ref_count;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Ref_count::clear_csum() {
// @@protoc_insertion_point(one_of_clear_start:proto.Ref_count)
  switch (csum_case()) {
    case kXxhash: {
      // No need to clear
      break;
    }
    case kBlake2B: {
      csum_.blake2b_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case CSUM_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CSUM_NOT_SET;
}


void Ref_count::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Ref_count)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    ::memset(&from_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&space_taken_) -
        reinterpret_cast<char*>(&from_)) + sizeof(space_taken_));
  }
  clear_csum();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Ref_count::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Ref_count)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 from = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_from();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &from_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 to = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_to();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &to_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 ref_count = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_ref_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ref_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 space_taken = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_space_taken();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &space_taken_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 xxhash = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          clear_csum();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &csum_.xxhash_)));
          set_has_xxhash();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes blake2b = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_blake2b()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Ref_count)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Ref_count)
  return false;
#undef DO_
}

void Ref_count::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Ref_count)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 from = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->from(), output);
  }

  // required uint64 to = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->to(), output);
  }

  // required uint64 ref_count = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->ref_count(), output);
  }

  // required uint64 space_taken = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->space_taken(), output);
  }

  switch (csum_case()) {
    case kXxhash:
      ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->xxhash(), output);
      break;
    case kBlake2B:
      ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
        6, this->blake2b(), output);
      break;
    default: ;
  }
  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Ref_count)
}

size_t Ref_count::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:proto.Ref_count)
  size_t total_size = 0;

  if (has_from()) {
    // required uint64 from = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->from());
  }

  if (has_to()) {
    // required uint64 to = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->to());
  }

  if (has_ref_count()) {
    // required uint64 ref_count = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->ref_count());
  }

  if (has_space_taken()) {
    // required uint64 space_taken = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->space_taken());
  }

  return total_size;
}
size_t Ref_count::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Ref_count)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint64 from = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->from());

    // required uint64 to = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->to());

    // required uint64 ref_count = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->ref_count());

    // required uint64 space_taken = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->space_taken());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  switch (csum_case()) {
    // optional uint64 xxhash = 5;
    case kXxhash: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->xxhash());
      break;
    }
    // optional bytes blake2b = 6;
    case kBlake2B: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->blake2b());
      break;
    }
    case CSUM_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ref_count::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Ref_count*>(&from));
}

void Ref_count::MergeFrom(const Ref_count& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Ref_count)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      from_ = from.from_;
    }
    if (cached_has_bits & 0x00000002u) {
      to_ = from.to_;
    }
    if (cached_has_bits & 0x00000004u) {
      ref_count_ = from.ref_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      space_taken_ = from.space_taken_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.csum_case()) {
    case kXxhash: {
      set_xxhash(from.xxhash());
      break;
    }
    case kBlake2B: {
      set_blake2b(from.blake2b());
      break;
    }
    case CSUM_NOT_SET: {
      break;
    }
  }
}

void Ref_count::CopyFrom(const Ref_count& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Ref_count)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ref_count::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void Ref_count::Swap(Ref_count* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Ref_count::InternalSwap(Ref_count* other) {
  using std::swap;
  swap(from_, other->from_);
  swap(to_, other->to_);
  swap(ref_count_, other->ref_count_);
  swap(space_taken_, other->space_taken_);
  swap(csum_, other->csum_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Ref_count::GetTypeName() const {
  return "proto.Ref_count";
}


// ===================================================================

void Catalogue::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Catalogue::kStateFilesFieldNumber;
const int Catalogue::kContentFilesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Catalogue::Catalogue()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsCatalogue();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Catalogue)
}
Catalogue::Catalogue(const Catalogue& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      state_files_(from.state_files_),
      content_files_(from.content_files_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.Catalogue)
}

void Catalogue::SharedCtor() {
  _cached_size_ = 0;
}

Catalogue::~Catalogue() {
  // @@protoc_insertion_point(destructor:proto.Catalogue)
  SharedDtor();
}

void Catalogue::SharedDtor() {
}

void Catalogue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Catalogue& Catalogue::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsCatalogue();
  return *internal_default_instance();
}

Catalogue* Catalogue::New(::google::protobuf::Arena* arena) const {
  Catalogue* n = new Catalogue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Catalogue::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Catalogue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_files_.Clear();
  content_files_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Catalogue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Catalogue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.State_file state_files = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_state_files()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .proto.Content_file content_files = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_content_files()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Catalogue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Catalogue)
  return false;
#undef DO_
}

void Catalogue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Catalogue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.State_file state_files = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->state_files_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->state_files(static_cast<int>(i)), output);
  }

  // repeated .proto.Content_file content_files = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->content_files_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->content_files(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Catalogue)
}

size_t Catalogue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Catalogue)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .proto.State_file state_files = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->state_files_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->state_files(static_cast<int>(i)));
    }
  }

  // repeated .proto.Content_file content_files = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->content_files_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->content_files(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Catalogue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Catalogue*>(&from));
}

void Catalogue::MergeFrom(const Catalogue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Catalogue)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  state_files_.MergeFrom(from.state_files_);
  content_files_.MergeFrom(from.content_files_);
}

void Catalogue::CopyFrom(const Catalogue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Catalogue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Catalogue::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->state_files())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->content_files())) return false;
  return true;
}

void Catalogue::Swap(Catalogue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Catalogue::InternalSwap(Catalogue* other) {
  using std::swap;
  state_files_.InternalSwap(&other->state_files_);
  content_files_.InternalSwap(&other->content_files_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Catalogue::GetTypeName() const {
  return "proto.Catalogue";
}


// ===================================================================

void Catalog_header::InitAsDefaultInstance() {
  ::proto::_Catalog_header_default_instance_._instance.get_mutable()->filters_ = const_cast< ::proto::Filters*>(
      ::proto::Filters::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Catalog_header::kFiltersFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Catalog_header::Catalog_header()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_format_2eproto::InitDefaultsCatalog_header();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Catalog_header)
}
Catalog_header::Catalog_header(const Catalog_header& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_filters()) {
    filters_ = new ::proto::Filters(*from.filters_);
  } else {
    filters_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:proto.Catalog_header)
}

void Catalog_header::SharedCtor() {
  _cached_size_ = 0;
  filters_ = NULL;
}

Catalog_header::~Catalog_header() {
  // @@protoc_insertion_point(destructor:proto.Catalog_header)
  SharedDtor();
}

void Catalog_header::SharedDtor() {
  if (this != internal_default_instance()) delete filters_;
}

void Catalog_header::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Catalog_header& Catalog_header::default_instance() {
  ::protobuf_format_2eproto::InitDefaultsCatalog_header();
  return *internal_default_instance();
}

Catalog_header* Catalog_header::New(::google::protobuf::Arena* arena) const {
  Catalog_header* n = new Catalog_header;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Catalog_header::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Catalog_header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(filters_ != NULL);
    filters_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Catalog_header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:proto.Catalog_header)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.Filters filters = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_filters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Catalog_header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Catalog_header)
  return false;
#undef DO_
}

void Catalog_header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Catalog_header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.Filters filters = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->filters_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:proto.Catalog_header)
}

size_t Catalog_header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Catalog_header)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // optional .proto.Filters filters = 1;
  if (has_filters()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->filters_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Catalog_header::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Catalog_header*>(&from));
}

void Catalog_header::MergeFrom(const Catalog_header& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.Catalog_header)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_filters()) {
    mutable_filters()->::proto::Filters::MergeFrom(from.filters());
  }
}

void Catalog_header::CopyFrom(const Catalog_header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Catalog_header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Catalog_header::IsInitialized() const {
  if (has_filters()) {
    if (!this->filters_->IsInitialized()) return false;
  }
  return true;
}

void Catalog_header::Swap(Catalog_header* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Catalog_header::InternalSwap(Catalog_header* other) {
  using std::swap;
  swap(filters_, other->filters_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Catalog_header::GetTypeName() const {
  return "proto.Catalog_header";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto

// @@protoc_insertion_point(global_scope)
