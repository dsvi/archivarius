// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: format.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_format_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_format_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_format_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_format_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace proto {
class Catalog_header;
class Catalog_headerDefaultTypeInternal;
extern Catalog_headerDefaultTypeInternal _Catalog_header_default_instance_;
class Catalogue;
class CatalogueDefaultTypeInternal;
extern CatalogueDefaultTypeInternal _Catalogue_default_instance_;
class Chacha_Encryption_filter;
class Chacha_Encryption_filterDefaultTypeInternal;
extern Chacha_Encryption_filterDefaultTypeInternal _Chacha_Encryption_filter_default_instance_;
class Chapoly_Encryption_filter;
class Chapoly_Encryption_filterDefaultTypeInternal;
extern Chapoly_Encryption_filterDefaultTypeInternal _Chapoly_Encryption_filter_default_instance_;
class Content_file;
class Content_fileDefaultTypeInternal;
extern Content_fileDefaultTypeInternal _Content_file_default_instance_;
class Filters;
class FiltersDefaultTypeInternal;
extern FiltersDefaultTypeInternal _Filters_default_instance_;
class Fs_record;
class Fs_recordDefaultTypeInternal;
extern Fs_recordDefaultTypeInternal _Fs_record_default_instance_;
class Fs_state;
class Fs_stateDefaultTypeInternal;
extern Fs_stateDefaultTypeInternal _Fs_state_default_instance_;
class Ref_count;
class Ref_countDefaultTypeInternal;
extern Ref_countDefaultTypeInternal _Ref_count_default_instance_;
class Ref_to_refcount;
class Ref_to_refcountDefaultTypeInternal;
extern Ref_to_refcountDefaultTypeInternal _Ref_to_refcount_default_instance_;
class State_file;
class State_fileDefaultTypeInternal;
extern State_fileDefaultTypeInternal _State_file_default_instance_;
class ZSTD_Compression_filter;
class ZSTD_Compression_filterDefaultTypeInternal;
extern ZSTD_Compression_filterDefaultTypeInternal _ZSTD_Compression_filter_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::Catalog_header* Arena::CreateMaybeMessage<::proto::Catalog_header>(Arena*);
template<> ::proto::Catalogue* Arena::CreateMaybeMessage<::proto::Catalogue>(Arena*);
template<> ::proto::Chacha_Encryption_filter* Arena::CreateMaybeMessage<::proto::Chacha_Encryption_filter>(Arena*);
template<> ::proto::Chapoly_Encryption_filter* Arena::CreateMaybeMessage<::proto::Chapoly_Encryption_filter>(Arena*);
template<> ::proto::Content_file* Arena::CreateMaybeMessage<::proto::Content_file>(Arena*);
template<> ::proto::Filters* Arena::CreateMaybeMessage<::proto::Filters>(Arena*);
template<> ::proto::Fs_record* Arena::CreateMaybeMessage<::proto::Fs_record>(Arena*);
template<> ::proto::Fs_state* Arena::CreateMaybeMessage<::proto::Fs_state>(Arena*);
template<> ::proto::Ref_count* Arena::CreateMaybeMessage<::proto::Ref_count>(Arena*);
template<> ::proto::Ref_to_refcount* Arena::CreateMaybeMessage<::proto::Ref_to_refcount>(Arena*);
template<> ::proto::State_file* Arena::CreateMaybeMessage<::proto::State_file>(Arena*);
template<> ::proto::ZSTD_Compression_filter* Arena::CreateMaybeMessage<::proto::ZSTD_Compression_filter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum File_type : int {
  FILE = 0,
  DIR = 1,
  SYMLINK = 2
};
bool File_type_IsValid(int value);
constexpr File_type File_type_MIN = FILE;
constexpr File_type File_type_MAX = SYMLINK;
constexpr int File_type_ARRAYSIZE = File_type_MAX + 1;

const std::string& File_type_Name(File_type value);
template<typename T>
inline const std::string& File_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, File_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function File_type_Name.");
  return File_type_Name(static_cast<File_type>(enum_t_value));
}
bool File_type_Parse(
    const std::string& name, File_type* value);
// ===================================================================

class ZSTD_Compression_filter :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.ZSTD_Compression_filter) */ {
 public:
  ZSTD_Compression_filter();
  virtual ~ZSTD_Compression_filter();

  ZSTD_Compression_filter(const ZSTD_Compression_filter& from);
  ZSTD_Compression_filter(ZSTD_Compression_filter&& from) noexcept
    : ZSTD_Compression_filter() {
    *this = ::std::move(from);
  }

  inline ZSTD_Compression_filter& operator=(const ZSTD_Compression_filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZSTD_Compression_filter& operator=(ZSTD_Compression_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ZSTD_Compression_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZSTD_Compression_filter* internal_default_instance() {
    return reinterpret_cast<const ZSTD_Compression_filter*>(
               &_ZSTD_Compression_filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ZSTD_Compression_filter& a, ZSTD_Compression_filter& b) {
    a.Swap(&b);
  }
  inline void Swap(ZSTD_Compression_filter* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZSTD_Compression_filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ZSTD_Compression_filter* New() const final {
    return CreateMaybeMessage<ZSTD_Compression_filter>(nullptr);
  }

  ZSTD_Compression_filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ZSTD_Compression_filter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ZSTD_Compression_filter& from);
  void MergeFrom(const ZSTD_Compression_filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ZSTD_Compression_filter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ZSTD_Compression_filter";
  }
  protected:
  explicit ZSTD_Compression_filter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.ZSTD_Compression_filter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Chapoly_Encryption_filter :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Chapoly_Encryption_filter) */ {
 public:
  Chapoly_Encryption_filter();
  virtual ~Chapoly_Encryption_filter();

  Chapoly_Encryption_filter(const Chapoly_Encryption_filter& from);
  Chapoly_Encryption_filter(Chapoly_Encryption_filter&& from) noexcept
    : Chapoly_Encryption_filter() {
    *this = ::std::move(from);
  }

  inline Chapoly_Encryption_filter& operator=(const Chapoly_Encryption_filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chapoly_Encryption_filter& operator=(Chapoly_Encryption_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Chapoly_Encryption_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chapoly_Encryption_filter* internal_default_instance() {
    return reinterpret_cast<const Chapoly_Encryption_filter*>(
               &_Chapoly_Encryption_filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Chapoly_Encryption_filter& a, Chapoly_Encryption_filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Chapoly_Encryption_filter* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chapoly_Encryption_filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Chapoly_Encryption_filter* New() const final {
    return CreateMaybeMessage<Chapoly_Encryption_filter>(nullptr);
  }

  Chapoly_Encryption_filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Chapoly_Encryption_filter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Chapoly_Encryption_filter& from);
  void MergeFrom(const Chapoly_Encryption_filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Chapoly_Encryption_filter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Chapoly_Encryption_filter";
  }
  protected:
  explicit Chapoly_Encryption_filter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // required bytes iv = 1;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  void set_iv(const std::string& value);
  void set_iv(std::string&& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  std::string* mutable_iv();
  std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_iv();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_iv(
      std::string* iv);
  private:
  const std::string& _internal_iv() const;
  void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // optional bytes key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:proto.Chapoly_Encryption_filter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Chacha_Encryption_filter :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Chacha_Encryption_filter) */ {
 public:
  Chacha_Encryption_filter();
  virtual ~Chacha_Encryption_filter();

  Chacha_Encryption_filter(const Chacha_Encryption_filter& from);
  Chacha_Encryption_filter(Chacha_Encryption_filter&& from) noexcept
    : Chacha_Encryption_filter() {
    *this = ::std::move(from);
  }

  inline Chacha_Encryption_filter& operator=(const Chacha_Encryption_filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chacha_Encryption_filter& operator=(Chacha_Encryption_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Chacha_Encryption_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chacha_Encryption_filter* internal_default_instance() {
    return reinterpret_cast<const Chacha_Encryption_filter*>(
               &_Chacha_Encryption_filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Chacha_Encryption_filter& a, Chacha_Encryption_filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Chacha_Encryption_filter* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chacha_Encryption_filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Chacha_Encryption_filter* New() const final {
    return CreateMaybeMessage<Chacha_Encryption_filter>(nullptr);
  }

  Chacha_Encryption_filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Chacha_Encryption_filter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Chacha_Encryption_filter& from);
  void MergeFrom(const Chacha_Encryption_filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Chacha_Encryption_filter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Chacha_Encryption_filter";
  }
  protected:
  explicit Chacha_Encryption_filter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // required bytes iv = 1;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  void set_iv(const std::string& value);
  void set_iv(std::string&& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  std::string* mutable_iv();
  std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_iv();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_iv(
      std::string* iv);
  private:
  const std::string& _internal_iv() const;
  void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // optional bytes key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:proto.Chacha_Encryption_filter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Filters :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Filters) */ {
 public:
  Filters();
  virtual ~Filters();

  Filters(const Filters& from);
  Filters(Filters&& from) noexcept
    : Filters() {
    *this = ::std::move(from);
  }

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filters& operator=(Filters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Filters& default_instance();

  enum EncryptionCase {
    kChapolyEncryption = 2,
    kChachaEncryption = 3,
    ENCRYPTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filters* internal_default_instance() {
    return reinterpret_cast<const Filters*>(
               &_Filters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Filters& a, Filters& b) {
    a.Swap(&b);
  }
  inline void Swap(Filters* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Filters* New() const final {
    return CreateMaybeMessage<Filters>(nullptr);
  }

  Filters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Filters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Filters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Filters";
  }
  protected:
  explicit Filters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZstdCompressionFieldNumber = 1,
    kChapolyEncryptionFieldNumber = 2,
    kChachaEncryptionFieldNumber = 3,
  };
  // optional .proto.ZSTD_Compression_filter zstd_compression = 1;
  bool has_zstd_compression() const;
  private:
  bool _internal_has_zstd_compression() const;
  public:
  void clear_zstd_compression();
  const ::proto::ZSTD_Compression_filter& zstd_compression() const;
  ::proto::ZSTD_Compression_filter* release_zstd_compression();
  ::proto::ZSTD_Compression_filter* mutable_zstd_compression();
  void set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression);
  private:
  const ::proto::ZSTD_Compression_filter& _internal_zstd_compression() const;
  ::proto::ZSTD_Compression_filter* _internal_mutable_zstd_compression();
  public:
  void unsafe_arena_set_allocated_zstd_compression(
      ::proto::ZSTD_Compression_filter* zstd_compression);
  ::proto::ZSTD_Compression_filter* unsafe_arena_release_zstd_compression();

  // optional .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
  bool has_chapoly_encryption() const;
  private:
  bool _internal_has_chapoly_encryption() const;
  public:
  void clear_chapoly_encryption();
  const ::proto::Chapoly_Encryption_filter& chapoly_encryption() const;
  ::proto::Chapoly_Encryption_filter* release_chapoly_encryption();
  ::proto::Chapoly_Encryption_filter* mutable_chapoly_encryption();
  void set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption);
  private:
  const ::proto::Chapoly_Encryption_filter& _internal_chapoly_encryption() const;
  ::proto::Chapoly_Encryption_filter* _internal_mutable_chapoly_encryption();
  public:
  void unsafe_arena_set_allocated_chapoly_encryption(
      ::proto::Chapoly_Encryption_filter* chapoly_encryption);
  ::proto::Chapoly_Encryption_filter* unsafe_arena_release_chapoly_encryption();

  // optional .proto.Chacha_Encryption_filter chacha_encryption = 3;
  bool has_chacha_encryption() const;
  private:
  bool _internal_has_chacha_encryption() const;
  public:
  void clear_chacha_encryption();
  const ::proto::Chacha_Encryption_filter& chacha_encryption() const;
  ::proto::Chacha_Encryption_filter* release_chacha_encryption();
  ::proto::Chacha_Encryption_filter* mutable_chacha_encryption();
  void set_allocated_chacha_encryption(::proto::Chacha_Encryption_filter* chacha_encryption);
  private:
  const ::proto::Chacha_Encryption_filter& _internal_chacha_encryption() const;
  ::proto::Chacha_Encryption_filter* _internal_mutable_chacha_encryption();
  public:
  void unsafe_arena_set_allocated_chacha_encryption(
      ::proto::Chacha_Encryption_filter* chacha_encryption);
  ::proto::Chacha_Encryption_filter* unsafe_arena_release_chacha_encryption();

  void clear_encryption();
  EncryptionCase encryption_case() const;
  // @@protoc_insertion_point(class_scope:proto.Filters)
 private:
  class _Internal;
  void set_has_chapoly_encryption();
  void set_has_chacha_encryption();

  inline bool has_encryption() const;
  inline void clear_has_encryption();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::ZSTD_Compression_filter* zstd_compression_;
  union EncryptionUnion {
    EncryptionUnion() {}
    ::proto::Chapoly_Encryption_filter* chapoly_encryption_;
    ::proto::Chacha_Encryption_filter* chacha_encryption_;
  } encryption_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Ref_to_refcount :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_to_refcount) */ {
 public:
  Ref_to_refcount();
  virtual ~Ref_to_refcount();

  Ref_to_refcount(const Ref_to_refcount& from);
  Ref_to_refcount(Ref_to_refcount&& from) noexcept
    : Ref_to_refcount() {
    *this = ::std::move(from);
  }

  inline Ref_to_refcount& operator=(const Ref_to_refcount& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ref_to_refcount& operator=(Ref_to_refcount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Ref_to_refcount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ref_to_refcount* internal_default_instance() {
    return reinterpret_cast<const Ref_to_refcount*>(
               &_Ref_to_refcount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Ref_to_refcount& a, Ref_to_refcount& b) {
    a.Swap(&b);
  }
  inline void Swap(Ref_to_refcount* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ref_to_refcount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ref_to_refcount* New() const final {
    return CreateMaybeMessage<Ref_to_refcount>(nullptr);
  }

  Ref_to_refcount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ref_to_refcount>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Ref_to_refcount& from);
  void MergeFrom(const Ref_to_refcount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_to_refcount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Ref_to_refcount";
  }
  protected:
  explicit Ref_to_refcount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFnameFieldNumber = 1,
    kFromFieldNumber = 2,
  };
  // required string content_fname = 1;
  bool has_content_fname() const;
  private:
  bool _internal_has_content_fname() const;
  public:
  void clear_content_fname();
  const std::string& content_fname() const;
  void set_content_fname(const std::string& value);
  void set_content_fname(std::string&& value);
  void set_content_fname(const char* value);
  void set_content_fname(const char* value, size_t size);
  std::string* mutable_content_fname();
  std::string* release_content_fname();
  void set_allocated_content_fname(std::string* content_fname);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_content_fname();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_content_fname(
      std::string* content_fname);
  private:
  const std::string& _internal_content_fname() const;
  void _internal_set_content_fname(const std::string& value);
  std::string* _internal_mutable_content_fname();
  public:

  // required uint64 from = 2;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  ::PROTOBUF_NAMESPACE_ID::uint64 from() const;
  void set_from(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_from() const;
  void _internal_set_from(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Ref_to_refcount)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_fname_;
  ::PROTOBUF_NAMESPACE_ID::uint64 from_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Fs_record :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_record) */ {
 public:
  Fs_record();
  virtual ~Fs_record();

  Fs_record(const Fs_record& from);
  Fs_record(Fs_record&& from) noexcept
    : Fs_record() {
    *this = ::std::move(from);
  }

  inline Fs_record& operator=(const Fs_record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fs_record& operator=(Fs_record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Fs_record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fs_record* internal_default_instance() {
    return reinterpret_cast<const Fs_record*>(
               &_Fs_record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Fs_record& a, Fs_record& b) {
    a.Swap(&b);
  }
  inline void Swap(Fs_record* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fs_record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fs_record* New() const final {
    return CreateMaybeMessage<Fs_record>(nullptr);
  }

  Fs_record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fs_record>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fs_record& from);
  void MergeFrom(const Fs_record& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_record* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Fs_record";
  }
  protected:
  explicit Fs_record(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 1,
    kSymlinkTargetFieldNumber = 5,
    kPosixAclFieldNumber = 7,
    kPosixDefaultAclFieldNumber = 8,
    kRefFieldNumber = 4,
    kModifiedNanosecondsFieldNumber = 3,
    kTypeFieldNumber = 2,
    kUnixPermissionsFieldNumber = 6,
  };
  // required string pathname = 1;
  bool has_pathname() const;
  private:
  bool _internal_has_pathname() const;
  public:
  void clear_pathname();
  const std::string& pathname() const;
  void set_pathname(const std::string& value);
  void set_pathname(std::string&& value);
  void set_pathname(const char* value);
  void set_pathname(const char* value, size_t size);
  std::string* mutable_pathname();
  std::string* release_pathname();
  void set_allocated_pathname(std::string* pathname);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_pathname();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_pathname(
      std::string* pathname);
  private:
  const std::string& _internal_pathname() const;
  void _internal_set_pathname(const std::string& value);
  std::string* _internal_mutable_pathname();
  public:

  // optional string symlink_target = 5;
  bool has_symlink_target() const;
  private:
  bool _internal_has_symlink_target() const;
  public:
  void clear_symlink_target();
  const std::string& symlink_target() const;
  void set_symlink_target(const std::string& value);
  void set_symlink_target(std::string&& value);
  void set_symlink_target(const char* value);
  void set_symlink_target(const char* value, size_t size);
  std::string* mutable_symlink_target();
  std::string* release_symlink_target();
  void set_allocated_symlink_target(std::string* symlink_target);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_symlink_target();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symlink_target(
      std::string* symlink_target);
  private:
  const std::string& _internal_symlink_target() const;
  void _internal_set_symlink_target(const std::string& value);
  std::string* _internal_mutable_symlink_target();
  public:

  // optional string posix_acl = 7;
  bool has_posix_acl() const;
  private:
  bool _internal_has_posix_acl() const;
  public:
  void clear_posix_acl();
  const std::string& posix_acl() const;
  void set_posix_acl(const std::string& value);
  void set_posix_acl(std::string&& value);
  void set_posix_acl(const char* value);
  void set_posix_acl(const char* value, size_t size);
  std::string* mutable_posix_acl();
  std::string* release_posix_acl();
  void set_allocated_posix_acl(std::string* posix_acl);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_posix_acl();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_posix_acl(
      std::string* posix_acl);
  private:
  const std::string& _internal_posix_acl() const;
  void _internal_set_posix_acl(const std::string& value);
  std::string* _internal_mutable_posix_acl();
  public:

  // optional string posix_default_acl = 8;
  bool has_posix_default_acl() const;
  private:
  bool _internal_has_posix_default_acl() const;
  public:
  void clear_posix_default_acl();
  const std::string& posix_default_acl() const;
  void set_posix_default_acl(const std::string& value);
  void set_posix_default_acl(std::string&& value);
  void set_posix_default_acl(const char* value);
  void set_posix_default_acl(const char* value, size_t size);
  std::string* mutable_posix_default_acl();
  std::string* release_posix_default_acl();
  void set_allocated_posix_default_acl(std::string* posix_default_acl);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_posix_default_acl();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_posix_default_acl(
      std::string* posix_default_acl);
  private:
  const std::string& _internal_posix_default_acl() const;
  void _internal_set_posix_default_acl(const std::string& value);
  std::string* _internal_mutable_posix_default_acl();
  public:

  // optional .proto.Ref_to_refcount ref = 4;
  bool has_ref() const;
  private:
  bool _internal_has_ref() const;
  public:
  void clear_ref();
  const ::proto::Ref_to_refcount& ref() const;
  ::proto::Ref_to_refcount* release_ref();
  ::proto::Ref_to_refcount* mutable_ref();
  void set_allocated_ref(::proto::Ref_to_refcount* ref);
  private:
  const ::proto::Ref_to_refcount& _internal_ref() const;
  ::proto::Ref_to_refcount* _internal_mutable_ref();
  public:
  void unsafe_arena_set_allocated_ref(
      ::proto::Ref_to_refcount* ref);
  ::proto::Ref_to_refcount* unsafe_arena_release_ref();

  // optional uint64 modified_nanoseconds = 3;
  bool has_modified_nanoseconds() const;
  private:
  bool _internal_has_modified_nanoseconds() const;
  public:
  void clear_modified_nanoseconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 modified_nanoseconds() const;
  void set_modified_nanoseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_modified_nanoseconds() const;
  void _internal_set_modified_nanoseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .proto.File_type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::proto::File_type type() const;
  void set_type(::proto::File_type value);
  private:
  ::proto::File_type _internal_type() const;
  void _internal_set_type(::proto::File_type value);
  public:

  // optional uint32 unix_permissions = 6;
  bool has_unix_permissions() const;
  private:
  bool _internal_has_unix_permissions() const;
  public:
  void clear_unix_permissions();
  ::PROTOBUF_NAMESPACE_ID::uint32 unix_permissions() const;
  void set_unix_permissions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unix_permissions() const;
  void _internal_set_unix_permissions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Fs_record)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symlink_target_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr posix_acl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr posix_default_acl_;
  ::proto::Ref_to_refcount* ref_;
  ::PROTOBUF_NAMESPACE_ID::uint64 modified_nanoseconds_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unix_permissions_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Fs_state :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_state) */ {
 public:
  Fs_state();
  virtual ~Fs_state();

  Fs_state(const Fs_state& from);
  Fs_state(Fs_state&& from) noexcept
    : Fs_state() {
    *this = ::std::move(from);
  }

  inline Fs_state& operator=(const Fs_state& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fs_state& operator=(Fs_state&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Fs_state& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fs_state* internal_default_instance() {
    return reinterpret_cast<const Fs_state*>(
               &_Fs_state_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Fs_state& a, Fs_state& b) {
    a.Swap(&b);
  }
  inline void Swap(Fs_state* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fs_state* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fs_state* New() const final {
    return CreateMaybeMessage<Fs_state>(nullptr);
  }

  Fs_state* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fs_state>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Fs_state& from);
  void MergeFrom(const Fs_state& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_state* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Fs_state";
  }
  protected:
  explicit Fs_state(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecFieldNumber = 1,
  };
  // repeated .proto.Fs_record rec = 1;
  int rec_size() const;
  private:
  int _internal_rec_size() const;
  public:
  void clear_rec();
  ::proto::Fs_record* mutable_rec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record >*
      mutable_rec();
  private:
  const ::proto::Fs_record& _internal_rec(int index) const;
  ::proto::Fs_record* _internal_add_rec();
  public:
  const ::proto::Fs_record& rec(int index) const;
  ::proto::Fs_record* add_rec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record >&
      rec() const;

  // @@protoc_insertion_point(class_scope:proto.Fs_state)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record > rec_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class State_file :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.State_file) */ {
 public:
  State_file();
  virtual ~State_file();

  State_file(const State_file& from);
  State_file(State_file&& from) noexcept
    : State_file() {
    *this = ::std::move(from);
  }

  inline State_file& operator=(const State_file& from) {
    CopyFrom(from);
    return *this;
  }
  inline State_file& operator=(State_file&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const State_file& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_file* internal_default_instance() {
    return reinterpret_cast<const State_file*>(
               &_State_file_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(State_file& a, State_file& b) {
    a.Swap(&b);
  }
  inline void Swap(State_file* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State_file* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline State_file* New() const final {
    return CreateMaybeMessage<State_file>(nullptr);
  }

  State_file* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<State_file>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const State_file& from);
  void MergeFrom(const State_file& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(State_file* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.State_file";
  }
  protected:
  explicit State_file(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kFiltersFieldNumber = 1,
    kTimeCreatedFieldNumber = 3,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  private:
  bool _internal_has_filters() const;
  public:
  void clear_filters();
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  private:
  const ::proto::Filters& _internal_filters() const;
  ::proto::Filters* _internal_mutable_filters();
  public:
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // required uint64 time_created = 3;
  bool has_time_created() const;
  private:
  bool _internal_has_time_created() const;
  public:
  void clear_time_created();
  ::PROTOBUF_NAMESPACE_ID::uint64 time_created() const;
  void set_time_created(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time_created() const;
  void _internal_set_time_created(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:proto.State_file)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::proto::Filters* filters_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_created_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Content_file :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Content_file) */ {
 public:
  Content_file();
  virtual ~Content_file();

  Content_file(const Content_file& from);
  Content_file(Content_file&& from) noexcept
    : Content_file() {
    *this = ::std::move(from);
  }

  inline Content_file& operator=(const Content_file& from) {
    CopyFrom(from);
    return *this;
  }
  inline Content_file& operator=(Content_file&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Content_file& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Content_file* internal_default_instance() {
    return reinterpret_cast<const Content_file*>(
               &_Content_file_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Content_file& a, Content_file& b) {
    a.Swap(&b);
  }
  inline void Swap(Content_file* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Content_file* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Content_file* New() const final {
    return CreateMaybeMessage<Content_file>(nullptr);
  }

  Content_file* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Content_file>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Content_file& from);
  void MergeFrom(const Content_file& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Content_file* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Content_file";
  }
  protected:
  explicit Content_file(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefsFieldNumber = 3,
    kNameFieldNumber = 2,
    kFiltersFieldNumber = 1,
  };
  // repeated .proto.Ref_count refs = 3;
  int refs_size() const;
  private:
  int _internal_refs_size() const;
  public:
  void clear_refs();
  ::proto::Ref_count* mutable_refs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count >*
      mutable_refs();
  private:
  const ::proto::Ref_count& _internal_refs(int index) const;
  ::proto::Ref_count* _internal_add_refs();
  public:
  const ::proto::Ref_count& refs(int index) const;
  ::proto::Ref_count* add_refs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count >&
      refs() const;

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  private:
  bool _internal_has_filters() const;
  public:
  void clear_filters();
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  private:
  const ::proto::Filters& _internal_filters() const;
  ::proto::Filters* _internal_mutable_filters();
  public:
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:proto.Content_file)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count > refs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::proto::Filters* filters_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Ref_count :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_count) */ {
 public:
  Ref_count();
  virtual ~Ref_count();

  Ref_count(const Ref_count& from);
  Ref_count(Ref_count&& from) noexcept
    : Ref_count() {
    *this = ::std::move(from);
  }

  inline Ref_count& operator=(const Ref_count& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ref_count& operator=(Ref_count&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Ref_count& default_instance();

  enum CsumCase {
    kXxhash = 5,
    kBlake2B = 6,
    CSUM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ref_count* internal_default_instance() {
    return reinterpret_cast<const Ref_count*>(
               &_Ref_count_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Ref_count& a, Ref_count& b) {
    a.Swap(&b);
  }
  inline void Swap(Ref_count* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ref_count* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ref_count* New() const final {
    return CreateMaybeMessage<Ref_count>(nullptr);
  }

  Ref_count* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ref_count>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Ref_count& from);
  void MergeFrom(const Ref_count& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_count* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Ref_count";
  }
  protected:
  explicit Ref_count(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kRefCountFieldNumber = 3,
    kSpaceTakenFieldNumber = 4,
    kXxhashFieldNumber = 5,
    kBlake2BFieldNumber = 6,
  };
  // required uint64 from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  ::PROTOBUF_NAMESPACE_ID::uint64 from() const;
  void set_from(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_from() const;
  void _internal_set_from(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  ::PROTOBUF_NAMESPACE_ID::uint64 to() const;
  void set_to(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_to() const;
  void _internal_set_to(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 ref_count = 3;
  bool has_ref_count() const;
  private:
  bool _internal_has_ref_count() const;
  public:
  void clear_ref_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 ref_count() const;
  void set_ref_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ref_count() const;
  void _internal_set_ref_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 space_taken = 4;
  bool has_space_taken() const;
  private:
  bool _internal_has_space_taken() const;
  public:
  void clear_space_taken();
  ::PROTOBUF_NAMESPACE_ID::uint64 space_taken() const;
  void set_space_taken(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_space_taken() const;
  void _internal_set_space_taken(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 xxhash = 5;
  bool has_xxhash() const;
  private:
  bool _internal_has_xxhash() const;
  public:
  void clear_xxhash();
  ::PROTOBUF_NAMESPACE_ID::uint64 xxhash() const;
  void set_xxhash(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_xxhash() const;
  void _internal_set_xxhash(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bytes blake2b = 6;
  bool has_blake2b() const;
  private:
  bool _internal_has_blake2b() const;
  public:
  void clear_blake2b();
  const std::string& blake2b() const;
  void set_blake2b(const std::string& value);
  void set_blake2b(std::string&& value);
  void set_blake2b(const char* value);
  void set_blake2b(const void* value, size_t size);
  std::string* mutable_blake2b();
  std::string* release_blake2b();
  void set_allocated_blake2b(std::string* blake2b);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_blake2b();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_blake2b(
      std::string* blake2b);
  private:
  const std::string& _internal_blake2b() const;
  void _internal_set_blake2b(const std::string& value);
  std::string* _internal_mutable_blake2b();
  public:

  void clear_csum();
  CsumCase csum_case() const;
  // @@protoc_insertion_point(class_scope:proto.Ref_count)
 private:
  class _Internal;
  void set_has_xxhash();
  void set_has_blake2b();

  inline bool has_csum() const;
  inline void clear_has_csum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 from_;
  ::PROTOBUF_NAMESPACE_ID::uint64 to_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ref_count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 space_taken_;
  union CsumUnion {
    CsumUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint64 xxhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blake2b_;
  } csum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Catalogue :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalogue) */ {
 public:
  Catalogue();
  virtual ~Catalogue();

  Catalogue(const Catalogue& from);
  Catalogue(Catalogue&& from) noexcept
    : Catalogue() {
    *this = ::std::move(from);
  }

  inline Catalogue& operator=(const Catalogue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Catalogue& operator=(Catalogue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Catalogue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Catalogue* internal_default_instance() {
    return reinterpret_cast<const Catalogue*>(
               &_Catalogue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Catalogue& a, Catalogue& b) {
    a.Swap(&b);
  }
  inline void Swap(Catalogue* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Catalogue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Catalogue* New() const final {
    return CreateMaybeMessage<Catalogue>(nullptr);
  }

  Catalogue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Catalogue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Catalogue& from);
  void MergeFrom(const Catalogue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalogue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Catalogue";
  }
  protected:
  explicit Catalogue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFilesFieldNumber = 1,
    kContentFilesFieldNumber = 2,
  };
  // repeated .proto.State_file state_files = 1;
  int state_files_size() const;
  private:
  int _internal_state_files_size() const;
  public:
  void clear_state_files();
  ::proto::State_file* mutable_state_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file >*
      mutable_state_files();
  private:
  const ::proto::State_file& _internal_state_files(int index) const;
  ::proto::State_file* _internal_add_state_files();
  public:
  const ::proto::State_file& state_files(int index) const;
  ::proto::State_file* add_state_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file >&
      state_files() const;

  // repeated .proto.Content_file content_files = 2;
  int content_files_size() const;
  private:
  int _internal_content_files_size() const;
  public:
  void clear_content_files();
  ::proto::Content_file* mutable_content_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file >*
      mutable_content_files();
  private:
  const ::proto::Content_file& _internal_content_files(int index) const;
  ::proto::Content_file* _internal_add_content_files();
  public:
  const ::proto::Content_file& content_files(int index) const;
  ::proto::Content_file* add_content_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file >&
      content_files() const;

  // @@protoc_insertion_point(class_scope:proto.Catalogue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file > state_files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file > content_files_;
  friend struct ::TableStruct_format_2eproto;
};
// -------------------------------------------------------------------

class Catalog_header :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalog_header) */ {
 public:
  Catalog_header();
  virtual ~Catalog_header();

  Catalog_header(const Catalog_header& from);
  Catalog_header(Catalog_header&& from) noexcept
    : Catalog_header() {
    *this = ::std::move(from);
  }

  inline Catalog_header& operator=(const Catalog_header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Catalog_header& operator=(Catalog_header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const Catalog_header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Catalog_header* internal_default_instance() {
    return reinterpret_cast<const Catalog_header*>(
               &_Catalog_header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Catalog_header& a, Catalog_header& b) {
    a.Swap(&b);
  }
  inline void Swap(Catalog_header* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Catalog_header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Catalog_header* New() const final {
    return CreateMaybeMessage<Catalog_header>(nullptr);
  }

  Catalog_header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Catalog_header>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Catalog_header& from);
  void MergeFrom(const Catalog_header& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalog_header* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Catalog_header";
  }
  protected:
  explicit Catalog_header(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  private:
  bool _internal_has_filters() const;
  public:
  void clear_filters();
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  private:
  const ::proto::Filters& _internal_filters() const;
  ::proto::Filters* _internal_mutable_filters();
  public:
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:proto.Catalog_header)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::proto::Filters* filters_;
  friend struct ::TableStruct_format_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ZSTD_Compression_filter

// -------------------------------------------------------------------

// Chapoly_Encryption_filter

// required bytes iv = 1;
inline bool Chapoly_Encryption_filter::_internal_has_iv() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Chapoly_Encryption_filter::has_iv() const {
  return _internal_has_iv();
}
inline void Chapoly_Encryption_filter::clear_iv() {
  iv_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Chapoly_Encryption_filter::iv() const {
  // @@protoc_insertion_point(field_get:proto.Chapoly_Encryption_filter.iv)
  return _internal_iv();
}
inline void Chapoly_Encryption_filter::set_iv(const std::string& value) {
  _internal_set_iv(value);
  // @@protoc_insertion_point(field_set:proto.Chapoly_Encryption_filter.iv)
}
inline std::string* Chapoly_Encryption_filter::mutable_iv() {
  // @@protoc_insertion_point(field_mutable:proto.Chapoly_Encryption_filter.iv)
  return _internal_mutable_iv();
}
inline const std::string& Chapoly_Encryption_filter::_internal_iv() const {
  return iv_.Get();
}
inline void Chapoly_Encryption_filter::_internal_set_iv(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::set_iv(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Chapoly_Encryption_filter.iv)
}
inline void Chapoly_Encryption_filter::set_iv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  iv_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Chapoly_Encryption_filter.iv)
}
inline void Chapoly_Encryption_filter::set_iv(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Chapoly_Encryption_filter.iv)
}
inline std::string* Chapoly_Encryption_filter::_internal_mutable_iv() {
  _has_bits_[0] |= 0x00000001u;
  return iv_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Chapoly_Encryption_filter::release_iv() {
  // @@protoc_insertion_point(field_release:proto.Chapoly_Encryption_filter.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return iv_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iv,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Chapoly_Encryption_filter.iv)
}
inline std::string* Chapoly_Encryption_filter::unsafe_arena_release_iv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Chapoly_Encryption_filter.iv)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return iv_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::unsafe_arena_set_allocated_iv(
    std::string* iv) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iv_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      iv, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Chapoly_Encryption_filter.iv)
}

// optional bytes key = 2;
inline bool Chapoly_Encryption_filter::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Chapoly_Encryption_filter::has_key() const {
  return _internal_has_key();
}
inline void Chapoly_Encryption_filter::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Chapoly_Encryption_filter::key() const {
  // @@protoc_insertion_point(field_get:proto.Chapoly_Encryption_filter.key)
  return _internal_key();
}
inline void Chapoly_Encryption_filter::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:proto.Chapoly_Encryption_filter.key)
}
inline std::string* Chapoly_Encryption_filter::mutable_key() {
  // @@protoc_insertion_point(field_mutable:proto.Chapoly_Encryption_filter.key)
  return _internal_mutable_key();
}
inline const std::string& Chapoly_Encryption_filter::_internal_key() const {
  return key_.Get();
}
inline void Chapoly_Encryption_filter::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Chapoly_Encryption_filter.key)
}
inline void Chapoly_Encryption_filter::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Chapoly_Encryption_filter.key)
}
inline void Chapoly_Encryption_filter::set_key(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Chapoly_Encryption_filter.key)
}
inline std::string* Chapoly_Encryption_filter::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000002u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Chapoly_Encryption_filter::release_key() {
  // @@protoc_insertion_point(field_release:proto.Chapoly_Encryption_filter.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Chapoly_Encryption_filter.key)
}
inline std::string* Chapoly_Encryption_filter::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Chapoly_Encryption_filter.key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Chapoly_Encryption_filter.key)
}

// -------------------------------------------------------------------

// Chacha_Encryption_filter

// required bytes iv = 1;
inline bool Chacha_Encryption_filter::_internal_has_iv() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Chacha_Encryption_filter::has_iv() const {
  return _internal_has_iv();
}
inline void Chacha_Encryption_filter::clear_iv() {
  iv_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Chacha_Encryption_filter::iv() const {
  // @@protoc_insertion_point(field_get:proto.Chacha_Encryption_filter.iv)
  return _internal_iv();
}
inline void Chacha_Encryption_filter::set_iv(const std::string& value) {
  _internal_set_iv(value);
  // @@protoc_insertion_point(field_set:proto.Chacha_Encryption_filter.iv)
}
inline std::string* Chacha_Encryption_filter::mutable_iv() {
  // @@protoc_insertion_point(field_mutable:proto.Chacha_Encryption_filter.iv)
  return _internal_mutable_iv();
}
inline const std::string& Chacha_Encryption_filter::_internal_iv() const {
  return iv_.Get();
}
inline void Chacha_Encryption_filter::_internal_set_iv(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::set_iv(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Chacha_Encryption_filter.iv)
}
inline void Chacha_Encryption_filter::set_iv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  iv_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Chacha_Encryption_filter.iv)
}
inline void Chacha_Encryption_filter::set_iv(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Chacha_Encryption_filter.iv)
}
inline std::string* Chacha_Encryption_filter::_internal_mutable_iv() {
  _has_bits_[0] |= 0x00000001u;
  return iv_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Chacha_Encryption_filter::release_iv() {
  // @@protoc_insertion_point(field_release:proto.Chacha_Encryption_filter.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return iv_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iv,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Chacha_Encryption_filter.iv)
}
inline std::string* Chacha_Encryption_filter::unsafe_arena_release_iv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Chacha_Encryption_filter.iv)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return iv_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::unsafe_arena_set_allocated_iv(
    std::string* iv) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iv_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      iv, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Chacha_Encryption_filter.iv)
}

// optional bytes key = 2;
inline bool Chacha_Encryption_filter::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Chacha_Encryption_filter::has_key() const {
  return _internal_has_key();
}
inline void Chacha_Encryption_filter::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Chacha_Encryption_filter::key() const {
  // @@protoc_insertion_point(field_get:proto.Chacha_Encryption_filter.key)
  return _internal_key();
}
inline void Chacha_Encryption_filter::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:proto.Chacha_Encryption_filter.key)
}
inline std::string* Chacha_Encryption_filter::mutable_key() {
  // @@protoc_insertion_point(field_mutable:proto.Chacha_Encryption_filter.key)
  return _internal_mutable_key();
}
inline const std::string& Chacha_Encryption_filter::_internal_key() const {
  return key_.Get();
}
inline void Chacha_Encryption_filter::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Chacha_Encryption_filter.key)
}
inline void Chacha_Encryption_filter::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Chacha_Encryption_filter.key)
}
inline void Chacha_Encryption_filter::set_key(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Chacha_Encryption_filter.key)
}
inline std::string* Chacha_Encryption_filter::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000002u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Chacha_Encryption_filter::release_key() {
  // @@protoc_insertion_point(field_release:proto.Chacha_Encryption_filter.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Chacha_Encryption_filter.key)
}
inline std::string* Chacha_Encryption_filter::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Chacha_Encryption_filter.key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Chacha_Encryption_filter.key)
}

// -------------------------------------------------------------------

// Filters

// optional .proto.ZSTD_Compression_filter zstd_compression = 1;
inline bool Filters::_internal_has_zstd_compression() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || zstd_compression_ != nullptr);
  return value;
}
inline bool Filters::has_zstd_compression() const {
  return _internal_has_zstd_compression();
}
inline void Filters::clear_zstd_compression() {
  if (zstd_compression_ != nullptr) zstd_compression_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::ZSTD_Compression_filter& Filters::_internal_zstd_compression() const {
  const ::proto::ZSTD_Compression_filter* p = zstd_compression_;
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::ZSTD_Compression_filter*>(
      &::proto::_ZSTD_Compression_filter_default_instance_);
}
inline const ::proto::ZSTD_Compression_filter& Filters::zstd_compression() const {
  // @@protoc_insertion_point(field_get:proto.Filters.zstd_compression)
  return _internal_zstd_compression();
}
inline ::proto::ZSTD_Compression_filter* Filters::release_zstd_compression() {
  auto temp = unsafe_arena_release_zstd_compression();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::proto::ZSTD_Compression_filter* Filters::unsafe_arena_release_zstd_compression() {
  // @@protoc_insertion_point(field_release:proto.Filters.zstd_compression)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::ZSTD_Compression_filter* temp = zstd_compression_;
  zstd_compression_ = nullptr;
  return temp;
}
inline ::proto::ZSTD_Compression_filter* Filters::_internal_mutable_zstd_compression() {
  _has_bits_[0] |= 0x00000001u;
  if (zstd_compression_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ZSTD_Compression_filter>(GetArenaNoVirtual());
    zstd_compression_ = p;
  }
  return zstd_compression_;
}
inline ::proto::ZSTD_Compression_filter* Filters::mutable_zstd_compression() {
  // @@protoc_insertion_point(field_mutable:proto.Filters.zstd_compression)
  return _internal_mutable_zstd_compression();
}
inline void Filters::set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete zstd_compression_;
  }
  if (zstd_compression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(zstd_compression);
    if (message_arena != submessage_arena) {
      zstd_compression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zstd_compression, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  zstd_compression_ = zstd_compression;
  // @@protoc_insertion_point(field_set_allocated:proto.Filters.zstd_compression)
}

// optional .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
inline bool Filters::_internal_has_chapoly_encryption() const {
  return encryption_case() == kChapolyEncryption;
}
inline bool Filters::has_chapoly_encryption() const {
  return _internal_has_chapoly_encryption();
}
inline void Filters::set_has_chapoly_encryption() {
  _oneof_case_[0] = kChapolyEncryption;
}
inline void Filters::clear_chapoly_encryption() {
  if (_internal_has_chapoly_encryption()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete encryption_.chapoly_encryption_;
    }
    clear_has_encryption();
  }
}
inline ::proto::Chapoly_Encryption_filter* Filters::release_chapoly_encryption() {
  // @@protoc_insertion_point(field_release:proto.Filters.chapoly_encryption)
  if (_internal_has_chapoly_encryption()) {
    clear_has_encryption();
      ::proto::Chapoly_Encryption_filter* temp = encryption_.chapoly_encryption_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    encryption_.chapoly_encryption_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::Chapoly_Encryption_filter& Filters::_internal_chapoly_encryption() const {
  return _internal_has_chapoly_encryption()
      ? *encryption_.chapoly_encryption_
      : *reinterpret_cast< ::proto::Chapoly_Encryption_filter*>(&::proto::_Chapoly_Encryption_filter_default_instance_);
}
inline const ::proto::Chapoly_Encryption_filter& Filters::chapoly_encryption() const {
  // @@protoc_insertion_point(field_get:proto.Filters.chapoly_encryption)
  return _internal_chapoly_encryption();
}
inline ::proto::Chapoly_Encryption_filter* Filters::unsafe_arena_release_chapoly_encryption() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Filters.chapoly_encryption)
  if (_internal_has_chapoly_encryption()) {
    clear_has_encryption();
    ::proto::Chapoly_Encryption_filter* temp = encryption_.chapoly_encryption_;
    encryption_.chapoly_encryption_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filters::unsafe_arena_set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption) {
  clear_encryption();
  if (chapoly_encryption) {
    set_has_chapoly_encryption();
    encryption_.chapoly_encryption_ = chapoly_encryption;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Filters.chapoly_encryption)
}
inline ::proto::Chapoly_Encryption_filter* Filters::_internal_mutable_chapoly_encryption() {
  if (!_internal_has_chapoly_encryption()) {
    clear_encryption();
    set_has_chapoly_encryption();
    encryption_.chapoly_encryption_ = CreateMaybeMessage< ::proto::Chapoly_Encryption_filter >(
        GetArenaNoVirtual());
  }
  return encryption_.chapoly_encryption_;
}
inline ::proto::Chapoly_Encryption_filter* Filters::mutable_chapoly_encryption() {
  // @@protoc_insertion_point(field_mutable:proto.Filters.chapoly_encryption)
  return _internal_mutable_chapoly_encryption();
}

// optional .proto.Chacha_Encryption_filter chacha_encryption = 3;
inline bool Filters::_internal_has_chacha_encryption() const {
  return encryption_case() == kChachaEncryption;
}
inline bool Filters::has_chacha_encryption() const {
  return _internal_has_chacha_encryption();
}
inline void Filters::set_has_chacha_encryption() {
  _oneof_case_[0] = kChachaEncryption;
}
inline void Filters::clear_chacha_encryption() {
  if (_internal_has_chacha_encryption()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete encryption_.chacha_encryption_;
    }
    clear_has_encryption();
  }
}
inline ::proto::Chacha_Encryption_filter* Filters::release_chacha_encryption() {
  // @@protoc_insertion_point(field_release:proto.Filters.chacha_encryption)
  if (_internal_has_chacha_encryption()) {
    clear_has_encryption();
      ::proto::Chacha_Encryption_filter* temp = encryption_.chacha_encryption_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    encryption_.chacha_encryption_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::Chacha_Encryption_filter& Filters::_internal_chacha_encryption() const {
  return _internal_has_chacha_encryption()
      ? *encryption_.chacha_encryption_
      : *reinterpret_cast< ::proto::Chacha_Encryption_filter*>(&::proto::_Chacha_Encryption_filter_default_instance_);
}
inline const ::proto::Chacha_Encryption_filter& Filters::chacha_encryption() const {
  // @@protoc_insertion_point(field_get:proto.Filters.chacha_encryption)
  return _internal_chacha_encryption();
}
inline ::proto::Chacha_Encryption_filter* Filters::unsafe_arena_release_chacha_encryption() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Filters.chacha_encryption)
  if (_internal_has_chacha_encryption()) {
    clear_has_encryption();
    ::proto::Chacha_Encryption_filter* temp = encryption_.chacha_encryption_;
    encryption_.chacha_encryption_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filters::unsafe_arena_set_allocated_chacha_encryption(::proto::Chacha_Encryption_filter* chacha_encryption) {
  clear_encryption();
  if (chacha_encryption) {
    set_has_chacha_encryption();
    encryption_.chacha_encryption_ = chacha_encryption;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Filters.chacha_encryption)
}
inline ::proto::Chacha_Encryption_filter* Filters::_internal_mutable_chacha_encryption() {
  if (!_internal_has_chacha_encryption()) {
    clear_encryption();
    set_has_chacha_encryption();
    encryption_.chacha_encryption_ = CreateMaybeMessage< ::proto::Chacha_Encryption_filter >(
        GetArenaNoVirtual());
  }
  return encryption_.chacha_encryption_;
}
inline ::proto::Chacha_Encryption_filter* Filters::mutable_chacha_encryption() {
  // @@protoc_insertion_point(field_mutable:proto.Filters.chacha_encryption)
  return _internal_mutable_chacha_encryption();
}

inline bool Filters::has_encryption() const {
  return encryption_case() != ENCRYPTION_NOT_SET;
}
inline void Filters::clear_has_encryption() {
  _oneof_case_[0] = ENCRYPTION_NOT_SET;
}
inline Filters::EncryptionCase Filters::encryption_case() const {
  return Filters::EncryptionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ref_to_refcount

// required string content_fname = 1;
inline bool Ref_to_refcount::_internal_has_content_fname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ref_to_refcount::has_content_fname() const {
  return _internal_has_content_fname();
}
inline void Ref_to_refcount::clear_content_fname() {
  content_fname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Ref_to_refcount::content_fname() const {
  // @@protoc_insertion_point(field_get:proto.Ref_to_refcount.content_fname)
  return _internal_content_fname();
}
inline void Ref_to_refcount::set_content_fname(const std::string& value) {
  _internal_set_content_fname(value);
  // @@protoc_insertion_point(field_set:proto.Ref_to_refcount.content_fname)
}
inline std::string* Ref_to_refcount::mutable_content_fname() {
  // @@protoc_insertion_point(field_mutable:proto.Ref_to_refcount.content_fname)
  return _internal_mutable_content_fname();
}
inline const std::string& Ref_to_refcount::_internal_content_fname() const {
  return content_fname_.Get();
}
inline void Ref_to_refcount::_internal_set_content_fname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  content_fname_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Ref_to_refcount::set_content_fname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  content_fname_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Ref_to_refcount.content_fname)
}
inline void Ref_to_refcount::set_content_fname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  content_fname_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Ref_to_refcount.content_fname)
}
inline void Ref_to_refcount::set_content_fname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  content_fname_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Ref_to_refcount.content_fname)
}
inline std::string* Ref_to_refcount::_internal_mutable_content_fname() {
  _has_bits_[0] |= 0x00000001u;
  return content_fname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Ref_to_refcount::release_content_fname() {
  // @@protoc_insertion_point(field_release:proto.Ref_to_refcount.content_fname)
  if (!_internal_has_content_fname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return content_fname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Ref_to_refcount::set_allocated_content_fname(std::string* content_fname) {
  if (content_fname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_fname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content_fname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Ref_to_refcount.content_fname)
}
inline std::string* Ref_to_refcount::unsafe_arena_release_content_fname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Ref_to_refcount.content_fname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return content_fname_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Ref_to_refcount::unsafe_arena_set_allocated_content_fname(
    std::string* content_fname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (content_fname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_fname_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      content_fname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Ref_to_refcount.content_fname)
}

// required uint64 from = 2;
inline bool Ref_to_refcount::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ref_to_refcount::has_from() const {
  return _internal_has_from();
}
inline void Ref_to_refcount::clear_from() {
  from_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_to_refcount::_internal_from() const {
  return from_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_to_refcount::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_to_refcount.from)
  return _internal_from();
}
inline void Ref_to_refcount::_internal_set_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  from_ = value;
}
inline void Ref_to_refcount::set_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.Ref_to_refcount.from)
}

// -------------------------------------------------------------------

// Fs_record

// required string pathname = 1;
inline bool Fs_record::_internal_has_pathname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fs_record::has_pathname() const {
  return _internal_has_pathname();
}
inline void Fs_record::clear_pathname() {
  pathname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fs_record::pathname() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.pathname)
  return _internal_pathname();
}
inline void Fs_record::set_pathname(const std::string& value) {
  _internal_set_pathname(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.pathname)
}
inline std::string* Fs_record::mutable_pathname() {
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.pathname)
  return _internal_mutable_pathname();
}
inline const std::string& Fs_record::_internal_pathname() const {
  return pathname_.Get();
}
inline void Fs_record::_internal_set_pathname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pathname_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Fs_record::set_pathname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  pathname_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.pathname)
}
inline void Fs_record::set_pathname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  pathname_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.pathname)
}
inline void Fs_record::set_pathname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  pathname_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.pathname)
}
inline std::string* Fs_record::_internal_mutable_pathname() {
  _has_bits_[0] |= 0x00000001u;
  return pathname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Fs_record::release_pathname() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.pathname)
  if (!_internal_has_pathname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pathname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Fs_record::set_allocated_pathname(std::string* pathname) {
  if (pathname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pathname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pathname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.pathname)
}
inline std::string* Fs_record::unsafe_arena_release_pathname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.pathname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return pathname_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Fs_record::unsafe_arena_set_allocated_pathname(
    std::string* pathname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (pathname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pathname_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      pathname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.pathname)
}

// required .proto.File_type type = 2;
inline bool Fs_record::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Fs_record::has_type() const {
  return _internal_has_type();
}
inline void Fs_record::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::proto::File_type Fs_record::_internal_type() const {
  return static_cast< ::proto::File_type >(type_);
}
inline ::proto::File_type Fs_record::type() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.type)
  return _internal_type();
}
inline void Fs_record::_internal_set_type(::proto::File_type value) {
  assert(::proto::File_type_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
}
inline void Fs_record::set_type(::proto::File_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.type)
}

// optional uint64 modified_nanoseconds = 3;
inline bool Fs_record::_internal_has_modified_nanoseconds() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Fs_record::has_modified_nanoseconds() const {
  return _internal_has_modified_nanoseconds();
}
inline void Fs_record::clear_modified_nanoseconds() {
  modified_nanoseconds_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fs_record::_internal_modified_nanoseconds() const {
  return modified_nanoseconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fs_record::modified_nanoseconds() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.modified_nanoseconds)
  return _internal_modified_nanoseconds();
}
inline void Fs_record::_internal_set_modified_nanoseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  modified_nanoseconds_ = value;
}
inline void Fs_record::set_modified_nanoseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_modified_nanoseconds(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.modified_nanoseconds)
}

// optional .proto.Ref_to_refcount ref = 4;
inline bool Fs_record::_internal_has_ref() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || ref_ != nullptr);
  return value;
}
inline bool Fs_record::has_ref() const {
  return _internal_has_ref();
}
inline void Fs_record::clear_ref() {
  if (ref_ != nullptr) ref_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::proto::Ref_to_refcount& Fs_record::_internal_ref() const {
  const ::proto::Ref_to_refcount* p = ref_;
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::Ref_to_refcount*>(
      &::proto::_Ref_to_refcount_default_instance_);
}
inline const ::proto::Ref_to_refcount& Fs_record::ref() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.ref)
  return _internal_ref();
}
inline ::proto::Ref_to_refcount* Fs_record::release_ref() {
  auto temp = unsafe_arena_release_ref();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::proto::Ref_to_refcount* Fs_record::unsafe_arena_release_ref() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.ref)
  _has_bits_[0] &= ~0x00000010u;
  ::proto::Ref_to_refcount* temp = ref_;
  ref_ = nullptr;
  return temp;
}
inline ::proto::Ref_to_refcount* Fs_record::_internal_mutable_ref() {
  _has_bits_[0] |= 0x00000010u;
  if (ref_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Ref_to_refcount>(GetArenaNoVirtual());
    ref_ = p;
  }
  return ref_;
}
inline ::proto::Ref_to_refcount* Fs_record::mutable_ref() {
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.ref)
  return _internal_mutable_ref();
}
inline void Fs_record::set_allocated_ref(::proto::Ref_to_refcount* ref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ref_;
  }
  if (ref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ref);
    if (message_arena != submessage_arena) {
      ref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ref, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ref_ = ref;
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.ref)
}

// optional string symlink_target = 5;
inline bool Fs_record::_internal_has_symlink_target() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fs_record::has_symlink_target() const {
  return _internal_has_symlink_target();
}
inline void Fs_record::clear_symlink_target() {
  symlink_target_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fs_record::symlink_target() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.symlink_target)
  return _internal_symlink_target();
}
inline void Fs_record::set_symlink_target(const std::string& value) {
  _internal_set_symlink_target(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.symlink_target)
}
inline std::string* Fs_record::mutable_symlink_target() {
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.symlink_target)
  return _internal_mutable_symlink_target();
}
inline const std::string& Fs_record::_internal_symlink_target() const {
  return symlink_target_.Get();
}
inline void Fs_record::_internal_set_symlink_target(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  symlink_target_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Fs_record::set_symlink_target(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  symlink_target_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.symlink_target)
}
inline void Fs_record::set_symlink_target(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  symlink_target_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.symlink_target)
}
inline void Fs_record::set_symlink_target(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  symlink_target_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.symlink_target)
}
inline std::string* Fs_record::_internal_mutable_symlink_target() {
  _has_bits_[0] |= 0x00000002u;
  return symlink_target_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Fs_record::release_symlink_target() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.symlink_target)
  if (!_internal_has_symlink_target()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return symlink_target_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Fs_record::set_allocated_symlink_target(std::string* symlink_target) {
  if (symlink_target != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  symlink_target_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symlink_target,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.symlink_target)
}
inline std::string* Fs_record::unsafe_arena_release_symlink_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.symlink_target)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return symlink_target_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Fs_record::unsafe_arena_set_allocated_symlink_target(
    std::string* symlink_target) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (symlink_target != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  symlink_target_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      symlink_target, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.symlink_target)
}

// optional uint32 unix_permissions = 6;
inline bool Fs_record::_internal_has_unix_permissions() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Fs_record::has_unix_permissions() const {
  return _internal_has_unix_permissions();
}
inline void Fs_record::clear_unix_permissions() {
  unix_permissions_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Fs_record::_internal_unix_permissions() const {
  return unix_permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Fs_record::unix_permissions() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.unix_permissions)
  return _internal_unix_permissions();
}
inline void Fs_record::_internal_set_unix_permissions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  unix_permissions_ = value;
}
inline void Fs_record::set_unix_permissions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unix_permissions(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.unix_permissions)
}

// optional string posix_acl = 7;
inline bool Fs_record::_internal_has_posix_acl() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fs_record::has_posix_acl() const {
  return _internal_has_posix_acl();
}
inline void Fs_record::clear_posix_acl() {
  posix_acl_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fs_record::posix_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_acl)
  return _internal_posix_acl();
}
inline void Fs_record::set_posix_acl(const std::string& value) {
  _internal_set_posix_acl(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_acl)
}
inline std::string* Fs_record::mutable_posix_acl() {
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_acl)
  return _internal_mutable_posix_acl();
}
inline const std::string& Fs_record::_internal_posix_acl() const {
  return posix_acl_.Get();
}
inline void Fs_record::_internal_set_posix_acl(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  posix_acl_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Fs_record::set_posix_acl(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  posix_acl_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.posix_acl)
}
inline void Fs_record::set_posix_acl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  posix_acl_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.posix_acl)
}
inline void Fs_record::set_posix_acl(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  posix_acl_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.posix_acl)
}
inline std::string* Fs_record::_internal_mutable_posix_acl() {
  _has_bits_[0] |= 0x00000004u;
  return posix_acl_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Fs_record::release_posix_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_acl)
  if (!_internal_has_posix_acl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return posix_acl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Fs_record::set_allocated_posix_acl(std::string* posix_acl) {
  if (posix_acl != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  posix_acl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), posix_acl,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_acl)
}
inline std::string* Fs_record::unsafe_arena_release_posix_acl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.posix_acl)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return posix_acl_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Fs_record::unsafe_arena_set_allocated_posix_acl(
    std::string* posix_acl) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (posix_acl != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  posix_acl_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      posix_acl, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.posix_acl)
}

// optional string posix_default_acl = 8;
inline bool Fs_record::_internal_has_posix_default_acl() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Fs_record::has_posix_default_acl() const {
  return _internal_has_posix_default_acl();
}
inline void Fs_record::clear_posix_default_acl() {
  posix_default_acl_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Fs_record::posix_default_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_default_acl)
  return _internal_posix_default_acl();
}
inline void Fs_record::set_posix_default_acl(const std::string& value) {
  _internal_set_posix_default_acl(value);
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_default_acl)
}
inline std::string* Fs_record::mutable_posix_default_acl() {
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_default_acl)
  return _internal_mutable_posix_default_acl();
}
inline const std::string& Fs_record::_internal_posix_default_acl() const {
  return posix_default_acl_.Get();
}
inline void Fs_record::_internal_set_posix_default_acl(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  posix_default_acl_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Fs_record::set_posix_default_acl(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  posix_default_acl_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.posix_default_acl)
}
inline void Fs_record::set_posix_default_acl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  posix_default_acl_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.posix_default_acl)
}
inline void Fs_record::set_posix_default_acl(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  posix_default_acl_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.posix_default_acl)
}
inline std::string* Fs_record::_internal_mutable_posix_default_acl() {
  _has_bits_[0] |= 0x00000008u;
  return posix_default_acl_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Fs_record::release_posix_default_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_default_acl)
  if (!_internal_has_posix_default_acl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return posix_default_acl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Fs_record::set_allocated_posix_default_acl(std::string* posix_default_acl) {
  if (posix_default_acl != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  posix_default_acl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), posix_default_acl,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_default_acl)
}
inline std::string* Fs_record::unsafe_arena_release_posix_default_acl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.posix_default_acl)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return posix_default_acl_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Fs_record::unsafe_arena_set_allocated_posix_default_acl(
    std::string* posix_default_acl) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (posix_default_acl != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  posix_default_acl_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      posix_default_acl, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.posix_default_acl)
}

// -------------------------------------------------------------------

// Fs_state

// repeated .proto.Fs_record rec = 1;
inline int Fs_state::_internal_rec_size() const {
  return rec_.size();
}
inline int Fs_state::rec_size() const {
  return _internal_rec_size();
}
inline void Fs_state::clear_rec() {
  rec_.Clear();
}
inline ::proto::Fs_record* Fs_state::mutable_rec(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Fs_state.rec)
  return rec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record >*
Fs_state::mutable_rec() {
  // @@protoc_insertion_point(field_mutable_list:proto.Fs_state.rec)
  return &rec_;
}
inline const ::proto::Fs_record& Fs_state::_internal_rec(int index) const {
  return rec_.Get(index);
}
inline const ::proto::Fs_record& Fs_state::rec(int index) const {
  // @@protoc_insertion_point(field_get:proto.Fs_state.rec)
  return _internal_rec(index);
}
inline ::proto::Fs_record* Fs_state::_internal_add_rec() {
  return rec_.Add();
}
inline ::proto::Fs_record* Fs_state::add_rec() {
  // @@protoc_insertion_point(field_add:proto.Fs_state.rec)
  return _internal_add_rec();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Fs_record >&
Fs_state::rec() const {
  // @@protoc_insertion_point(field_list:proto.Fs_state.rec)
  return rec_;
}

// -------------------------------------------------------------------

// State_file

// optional .proto.Filters filters = 1;
inline bool State_file::_internal_has_filters() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || filters_ != nullptr);
  return value;
}
inline bool State_file::has_filters() const {
  return _internal_has_filters();
}
inline void State_file::clear_filters() {
  if (filters_ != nullptr) filters_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::Filters& State_file::_internal_filters() const {
  const ::proto::Filters* p = filters_;
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline const ::proto::Filters& State_file::filters() const {
  // @@protoc_insertion_point(field_get:proto.State_file.filters)
  return _internal_filters();
}
inline ::proto::Filters* State_file::release_filters() {
  auto temp = unsafe_arena_release_filters();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::proto::Filters* State_file::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_release:proto.State_file.filters)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
  return temp;
}
inline ::proto::Filters* State_file::_internal_mutable_filters() {
  _has_bits_[0] |= 0x00000002u;
  if (filters_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Filters>(GetArenaNoVirtual());
    filters_ = p;
  }
  return filters_;
}
inline ::proto::Filters* State_file::mutable_filters() {
  // @@protoc_insertion_point(field_mutable:proto.State_file.filters)
  return _internal_mutable_filters();
}
inline void State_file::set_allocated_filters(::proto::Filters* filters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filters_;
  }
  if (filters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.State_file.filters)
}

// required string name = 2;
inline bool State_file::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool State_file::has_name() const {
  return _internal_has_name();
}
inline void State_file::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& State_file::name() const {
  // @@protoc_insertion_point(field_get:proto.State_file.name)
  return _internal_name();
}
inline void State_file::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:proto.State_file.name)
}
inline std::string* State_file::mutable_name() {
  // @@protoc_insertion_point(field_mutable:proto.State_file.name)
  return _internal_mutable_name();
}
inline const std::string& State_file::_internal_name() const {
  return name_.Get();
}
inline void State_file::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void State_file::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.State_file.name)
}
inline void State_file::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.State_file.name)
}
inline void State_file::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.State_file.name)
}
inline std::string* State_file::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* State_file::release_name() {
  // @@protoc_insertion_point(field_release:proto.State_file.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void State_file::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.State_file.name)
}
inline std::string* State_file::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.State_file.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void State_file::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.State_file.name)
}

// required uint64 time_created = 3;
inline bool State_file::_internal_has_time_created() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool State_file::has_time_created() const {
  return _internal_has_time_created();
}
inline void State_file::clear_time_created() {
  time_created_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 State_file::_internal_time_created() const {
  return time_created_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 State_file::time_created() const {
  // @@protoc_insertion_point(field_get:proto.State_file.time_created)
  return _internal_time_created();
}
inline void State_file::_internal_set_time_created(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  time_created_ = value;
}
inline void State_file::set_time_created(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time_created(value);
  // @@protoc_insertion_point(field_set:proto.State_file.time_created)
}

// -------------------------------------------------------------------

// Content_file

// optional .proto.Filters filters = 1;
inline bool Content_file::_internal_has_filters() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || filters_ != nullptr);
  return value;
}
inline bool Content_file::has_filters() const {
  return _internal_has_filters();
}
inline void Content_file::clear_filters() {
  if (filters_ != nullptr) filters_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::Filters& Content_file::_internal_filters() const {
  const ::proto::Filters* p = filters_;
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline const ::proto::Filters& Content_file::filters() const {
  // @@protoc_insertion_point(field_get:proto.Content_file.filters)
  return _internal_filters();
}
inline ::proto::Filters* Content_file::release_filters() {
  auto temp = unsafe_arena_release_filters();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::proto::Filters* Content_file::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_release:proto.Content_file.filters)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
  return temp;
}
inline ::proto::Filters* Content_file::_internal_mutable_filters() {
  _has_bits_[0] |= 0x00000002u;
  if (filters_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Filters>(GetArenaNoVirtual());
    filters_ = p;
  }
  return filters_;
}
inline ::proto::Filters* Content_file::mutable_filters() {
  // @@protoc_insertion_point(field_mutable:proto.Content_file.filters)
  return _internal_mutable_filters();
}
inline void Content_file::set_allocated_filters(::proto::Filters* filters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filters_;
  }
  if (filters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.Content_file.filters)
}

// required string name = 2;
inline bool Content_file::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Content_file::has_name() const {
  return _internal_has_name();
}
inline void Content_file::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Content_file::name() const {
  // @@protoc_insertion_point(field_get:proto.Content_file.name)
  return _internal_name();
}
inline void Content_file::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:proto.Content_file.name)
}
inline std::string* Content_file::mutable_name() {
  // @@protoc_insertion_point(field_mutable:proto.Content_file.name)
  return _internal_mutable_name();
}
inline const std::string& Content_file::_internal_name() const {
  return name_.Get();
}
inline void Content_file::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void Content_file::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Content_file.name)
}
inline void Content_file::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Content_file.name)
}
inline void Content_file::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Content_file.name)
}
inline std::string* Content_file::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* Content_file::release_name() {
  // @@protoc_insertion_point(field_release:proto.Content_file.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Content_file::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Content_file.name)
}
inline std::string* Content_file::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Content_file.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Content_file::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Content_file.name)
}

// repeated .proto.Ref_count refs = 3;
inline int Content_file::_internal_refs_size() const {
  return refs_.size();
}
inline int Content_file::refs_size() const {
  return _internal_refs_size();
}
inline void Content_file::clear_refs() {
  refs_.Clear();
}
inline ::proto::Ref_count* Content_file::mutable_refs(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Content_file.refs)
  return refs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count >*
Content_file::mutable_refs() {
  // @@protoc_insertion_point(field_mutable_list:proto.Content_file.refs)
  return &refs_;
}
inline const ::proto::Ref_count& Content_file::_internal_refs(int index) const {
  return refs_.Get(index);
}
inline const ::proto::Ref_count& Content_file::refs(int index) const {
  // @@protoc_insertion_point(field_get:proto.Content_file.refs)
  return _internal_refs(index);
}
inline ::proto::Ref_count* Content_file::_internal_add_refs() {
  return refs_.Add();
}
inline ::proto::Ref_count* Content_file::add_refs() {
  // @@protoc_insertion_point(field_add:proto.Content_file.refs)
  return _internal_add_refs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Ref_count >&
Content_file::refs() const {
  // @@protoc_insertion_point(field_list:proto.Content_file.refs)
  return refs_;
}

// -------------------------------------------------------------------

// Ref_count

// required uint64 from = 1;
inline bool Ref_count::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ref_count::has_from() const {
  return _internal_has_from();
}
inline void Ref_count::clear_from() {
  from_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::_internal_from() const {
  return from_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.from)
  return _internal_from();
}
inline void Ref_count::_internal_set_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  from_ = value;
}
inline void Ref_count::set_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.from)
}

// required uint64 to = 2;
inline bool Ref_count::_internal_has_to() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ref_count::has_to() const {
  return _internal_has_to();
}
inline void Ref_count::clear_to() {
  to_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::_internal_to() const {
  return to_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::to() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.to)
  return _internal_to();
}
inline void Ref_count::_internal_set_to(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  to_ = value;
}
inline void Ref_count::set_to(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.to)
}

// required uint64 ref_count = 3;
inline bool Ref_count::_internal_has_ref_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Ref_count::has_ref_count() const {
  return _internal_has_ref_count();
}
inline void Ref_count::clear_ref_count() {
  ref_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::_internal_ref_count() const {
  return ref_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::ref_count() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.ref_count)
  return _internal_ref_count();
}
inline void Ref_count::_internal_set_ref_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  ref_count_ = value;
}
inline void Ref_count::set_ref_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ref_count(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.ref_count)
}

// required uint64 space_taken = 4;
inline bool Ref_count::_internal_has_space_taken() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Ref_count::has_space_taken() const {
  return _internal_has_space_taken();
}
inline void Ref_count::clear_space_taken() {
  space_taken_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::_internal_space_taken() const {
  return space_taken_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::space_taken() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.space_taken)
  return _internal_space_taken();
}
inline void Ref_count::_internal_set_space_taken(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  space_taken_ = value;
}
inline void Ref_count::set_space_taken(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_space_taken(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.space_taken)
}

// optional uint64 xxhash = 5;
inline bool Ref_count::_internal_has_xxhash() const {
  return csum_case() == kXxhash;
}
inline bool Ref_count::has_xxhash() const {
  return _internal_has_xxhash();
}
inline void Ref_count::set_has_xxhash() {
  _oneof_case_[0] = kXxhash;
}
inline void Ref_count::clear_xxhash() {
  if (_internal_has_xxhash()) {
    csum_.xxhash_ = PROTOBUF_ULONGLONG(0);
    clear_has_csum();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::_internal_xxhash() const {
  if (_internal_has_xxhash()) {
    return csum_.xxhash_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void Ref_count::_internal_set_xxhash(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_xxhash()) {
    clear_csum();
    set_has_xxhash();
  }
  csum_.xxhash_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ref_count::xxhash() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.xxhash)
  return _internal_xxhash();
}
inline void Ref_count::set_xxhash(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_xxhash(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.xxhash)
}

// optional bytes blake2b = 6;
inline bool Ref_count::_internal_has_blake2b() const {
  return csum_case() == kBlake2B;
}
inline bool Ref_count::has_blake2b() const {
  return _internal_has_blake2b();
}
inline void Ref_count::set_has_blake2b() {
  _oneof_case_[0] = kBlake2B;
}
inline void Ref_count::clear_blake2b() {
  if (_internal_has_blake2b()) {
    csum_.blake2b_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_csum();
  }
}
inline const std::string& Ref_count::blake2b() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.blake2b)
  return _internal_blake2b();
}
inline void Ref_count::set_blake2b(const std::string& value) {
  _internal_set_blake2b(value);
  // @@protoc_insertion_point(field_set:proto.Ref_count.blake2b)
}
inline std::string* Ref_count::mutable_blake2b() {
  // @@protoc_insertion_point(field_mutable:proto.Ref_count.blake2b)
  return _internal_mutable_blake2b();
}
inline const std::string& Ref_count::_internal_blake2b() const {
  if (_internal_has_blake2b()) {
    return csum_.blake2b_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Ref_count::_internal_set_blake2b(const std::string& value) {
  if (!_internal_has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  csum_.blake2b_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
}
inline void Ref_count::set_blake2b(std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.Ref_count.blake2b)
  if (!_internal_has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  csum_.blake2b_.SetLite(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Ref_count.blake2b)
}
inline void Ref_count::set_blake2b(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  csum_.blake2b_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Ref_count.blake2b)
}
inline void Ref_count::set_blake2b(const void* value,
                             size_t size) {
  if (!_internal_has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  csum_.blake2b_.SetLite(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Ref_count.blake2b)
}
inline std::string* Ref_count::_internal_mutable_blake2b() {
  if (!_internal_has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return csum_.blake2b_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline std::string* Ref_count::release_blake2b() {
  // @@protoc_insertion_point(field_release:proto.Ref_count.blake2b)
  if (_internal_has_blake2b()) {
    clear_has_csum();
    return csum_.blake2b_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return nullptr;
  }
}
inline void Ref_count::set_allocated_blake2b(std::string* blake2b) {
  if (has_csum()) {
    clear_csum();
  }
  if (blake2b != nullptr) {
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(blake2b);
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Ref_count.blake2b)
}
inline std::string* Ref_count::unsafe_arena_release_blake2b() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Ref_count.blake2b)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (_internal_has_blake2b()) {
    clear_has_csum();
    return csum_.blake2b_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return nullptr;
  }
}
inline void Ref_count::unsafe_arena_set_allocated_blake2b(std::string* blake2b) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (!_internal_has_blake2b()) {
    csum_.blake2b_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_csum();
  if (blake2b) {
    set_has_blake2b();
    csum_.blake2b_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blake2b, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Ref_count.blake2b)
}

inline bool Ref_count::has_csum() const {
  return csum_case() != CSUM_NOT_SET;
}
inline void Ref_count::clear_has_csum() {
  _oneof_case_[0] = CSUM_NOT_SET;
}
inline Ref_count::CsumCase Ref_count::csum_case() const {
  return Ref_count::CsumCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Catalogue

// repeated .proto.State_file state_files = 1;
inline int Catalogue::_internal_state_files_size() const {
  return state_files_.size();
}
inline int Catalogue::state_files_size() const {
  return _internal_state_files_size();
}
inline void Catalogue::clear_state_files() {
  state_files_.Clear();
}
inline ::proto::State_file* Catalogue::mutable_state_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.state_files)
  return state_files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file >*
Catalogue::mutable_state_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.state_files)
  return &state_files_;
}
inline const ::proto::State_file& Catalogue::_internal_state_files(int index) const {
  return state_files_.Get(index);
}
inline const ::proto::State_file& Catalogue::state_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.state_files)
  return _internal_state_files(index);
}
inline ::proto::State_file* Catalogue::_internal_add_state_files() {
  return state_files_.Add();
}
inline ::proto::State_file* Catalogue::add_state_files() {
  // @@protoc_insertion_point(field_add:proto.Catalogue.state_files)
  return _internal_add_state_files();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::State_file >&
Catalogue::state_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.state_files)
  return state_files_;
}

// repeated .proto.Content_file content_files = 2;
inline int Catalogue::_internal_content_files_size() const {
  return content_files_.size();
}
inline int Catalogue::content_files_size() const {
  return _internal_content_files_size();
}
inline void Catalogue::clear_content_files() {
  content_files_.Clear();
}
inline ::proto::Content_file* Catalogue::mutable_content_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.content_files)
  return content_files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file >*
Catalogue::mutable_content_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.content_files)
  return &content_files_;
}
inline const ::proto::Content_file& Catalogue::_internal_content_files(int index) const {
  return content_files_.Get(index);
}
inline const ::proto::Content_file& Catalogue::content_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.content_files)
  return _internal_content_files(index);
}
inline ::proto::Content_file* Catalogue::_internal_add_content_files() {
  return content_files_.Add();
}
inline ::proto::Content_file* Catalogue::add_content_files() {
  // @@protoc_insertion_point(field_add:proto.Catalogue.content_files)
  return _internal_add_content_files();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Content_file >&
Catalogue::content_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.content_files)
  return content_files_;
}

// -------------------------------------------------------------------

// Catalog_header

// optional .proto.Filters filters = 1;
inline bool Catalog_header::_internal_has_filters() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || filters_ != nullptr);
  return value;
}
inline bool Catalog_header::has_filters() const {
  return _internal_has_filters();
}
inline void Catalog_header::clear_filters() {
  if (filters_ != nullptr) filters_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::Filters& Catalog_header::_internal_filters() const {
  const ::proto::Filters* p = filters_;
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline const ::proto::Filters& Catalog_header::filters() const {
  // @@protoc_insertion_point(field_get:proto.Catalog_header.filters)
  return _internal_filters();
}
inline ::proto::Filters* Catalog_header::release_filters() {
  auto temp = unsafe_arena_release_filters();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::proto::Filters* Catalog_header::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_release:proto.Catalog_header.filters)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::Filters* temp = filters_;
  filters_ = nullptr;
  return temp;
}
inline ::proto::Filters* Catalog_header::_internal_mutable_filters() {
  _has_bits_[0] |= 0x00000001u;
  if (filters_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Filters>(GetArenaNoVirtual());
    filters_ = p;
  }
  return filters_;
}
inline ::proto::Filters* Catalog_header::mutable_filters() {
  // @@protoc_insertion_point(field_mutable:proto.Catalog_header.filters)
  return _internal_mutable_filters();
}
inline void Catalog_header::set_allocated_filters(::proto::Filters* filters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filters_;
  }
  if (filters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.Catalog_header.filters)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::File_type> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_format_2eproto
