// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: format.proto

#ifndef PROTOBUF_format_2eproto__INCLUDED
#define PROTOBUF_format_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_format_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsZSTD_Compression_filterImpl();
void InitDefaultsZSTD_Compression_filter();
void InitDefaultsChapoly_Encryption_filterImpl();
void InitDefaultsChapoly_Encryption_filter();
void InitDefaultsChacha_Encryption_filterImpl();
void InitDefaultsChacha_Encryption_filter();
void InitDefaultsFiltersImpl();
void InitDefaultsFilters();
void InitDefaultsRef_to_refcountImpl();
void InitDefaultsRef_to_refcount();
void InitDefaultsFs_recordImpl();
void InitDefaultsFs_record();
void InitDefaultsFs_stateImpl();
void InitDefaultsFs_state();
void InitDefaultsState_fileImpl();
void InitDefaultsState_file();
void InitDefaultsContent_fileImpl();
void InitDefaultsContent_file();
void InitDefaultsRef_countImpl();
void InitDefaultsRef_count();
void InitDefaultsCatalogueImpl();
void InitDefaultsCatalogue();
void InitDefaultsCatalog_headerImpl();
void InitDefaultsCatalog_header();
inline void InitDefaults() {
  InitDefaultsZSTD_Compression_filter();
  InitDefaultsChapoly_Encryption_filter();
  InitDefaultsChacha_Encryption_filter();
  InitDefaultsFilters();
  InitDefaultsRef_to_refcount();
  InitDefaultsFs_record();
  InitDefaultsFs_state();
  InitDefaultsState_file();
  InitDefaultsContent_file();
  InitDefaultsRef_count();
  InitDefaultsCatalogue();
  InitDefaultsCatalog_header();
}
}  // namespace protobuf_format_2eproto
namespace proto {
class Catalog_header;
class Catalog_headerDefaultTypeInternal;
extern Catalog_headerDefaultTypeInternal _Catalog_header_default_instance_;
class Catalogue;
class CatalogueDefaultTypeInternal;
extern CatalogueDefaultTypeInternal _Catalogue_default_instance_;
class Chacha_Encryption_filter;
class Chacha_Encryption_filterDefaultTypeInternal;
extern Chacha_Encryption_filterDefaultTypeInternal _Chacha_Encryption_filter_default_instance_;
class Chapoly_Encryption_filter;
class Chapoly_Encryption_filterDefaultTypeInternal;
extern Chapoly_Encryption_filterDefaultTypeInternal _Chapoly_Encryption_filter_default_instance_;
class Content_file;
class Content_fileDefaultTypeInternal;
extern Content_fileDefaultTypeInternal _Content_file_default_instance_;
class Filters;
class FiltersDefaultTypeInternal;
extern FiltersDefaultTypeInternal _Filters_default_instance_;
class Fs_record;
class Fs_recordDefaultTypeInternal;
extern Fs_recordDefaultTypeInternal _Fs_record_default_instance_;
class Fs_state;
class Fs_stateDefaultTypeInternal;
extern Fs_stateDefaultTypeInternal _Fs_state_default_instance_;
class Ref_count;
class Ref_countDefaultTypeInternal;
extern Ref_countDefaultTypeInternal _Ref_count_default_instance_;
class Ref_to_refcount;
class Ref_to_refcountDefaultTypeInternal;
extern Ref_to_refcountDefaultTypeInternal _Ref_to_refcount_default_instance_;
class State_file;
class State_fileDefaultTypeInternal;
extern State_fileDefaultTypeInternal _State_file_default_instance_;
class ZSTD_Compression_filter;
class ZSTD_Compression_filterDefaultTypeInternal;
extern ZSTD_Compression_filterDefaultTypeInternal _ZSTD_Compression_filter_default_instance_;
}  // namespace proto
namespace proto {

enum File_type {
  FILE = 0,
  DIR = 1,
  SYMLINK = 2
};
bool File_type_IsValid(int value);
const File_type File_type_MIN = FILE;
const File_type File_type_MAX = SYMLINK;
const int File_type_ARRAYSIZE = File_type_MAX + 1;

// ===================================================================

class ZSTD_Compression_filter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ZSTD_Compression_filter) */ {
 public:
  ZSTD_Compression_filter();
  virtual ~ZSTD_Compression_filter();

  ZSTD_Compression_filter(const ZSTD_Compression_filter& from);

  inline ZSTD_Compression_filter& operator=(const ZSTD_Compression_filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ZSTD_Compression_filter(ZSTD_Compression_filter&& from) noexcept
    : ZSTD_Compression_filter() {
    *this = ::std::move(from);
  }

  inline ZSTD_Compression_filter& operator=(ZSTD_Compression_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ZSTD_Compression_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZSTD_Compression_filter* internal_default_instance() {
    return reinterpret_cast<const ZSTD_Compression_filter*>(
               &_ZSTD_Compression_filter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(ZSTD_Compression_filter* other);
  void Swap(ZSTD_Compression_filter* other);
  friend void swap(ZSTD_Compression_filter& a, ZSTD_Compression_filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ZSTD_Compression_filter* New() const PROTOBUF_FINAL { return New(NULL); }

  ZSTD_Compression_filter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ZSTD_Compression_filter& from);
  void MergeFrom(const ZSTD_Compression_filter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ZSTD_Compression_filter* other);
  protected:
  explicit ZSTD_Compression_filter(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.ZSTD_Compression_filter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsZSTD_Compression_filterImpl();
};
// -------------------------------------------------------------------

class Chapoly_Encryption_filter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Chapoly_Encryption_filter) */ {
 public:
  Chapoly_Encryption_filter();
  virtual ~Chapoly_Encryption_filter();

  Chapoly_Encryption_filter(const Chapoly_Encryption_filter& from);

  inline Chapoly_Encryption_filter& operator=(const Chapoly_Encryption_filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chapoly_Encryption_filter(Chapoly_Encryption_filter&& from) noexcept
    : Chapoly_Encryption_filter() {
    *this = ::std::move(from);
  }

  inline Chapoly_Encryption_filter& operator=(Chapoly_Encryption_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Chapoly_Encryption_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chapoly_Encryption_filter* internal_default_instance() {
    return reinterpret_cast<const Chapoly_Encryption_filter*>(
               &_Chapoly_Encryption_filter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Chapoly_Encryption_filter* other);
  void Swap(Chapoly_Encryption_filter* other);
  friend void swap(Chapoly_Encryption_filter& a, Chapoly_Encryption_filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chapoly_Encryption_filter* New() const PROTOBUF_FINAL { return New(NULL); }

  Chapoly_Encryption_filter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Chapoly_Encryption_filter& from);
  void MergeFrom(const Chapoly_Encryption_filter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Chapoly_Encryption_filter* other);
  protected:
  explicit Chapoly_Encryption_filter(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes iv = 1;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 1;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_iv();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_iv(
      ::std::string* iv);

  // optional bytes key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_key();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      ::std::string* key);

  // @@protoc_insertion_point(class_scope:proto.Chapoly_Encryption_filter)
 private:
  void set_has_iv();
  void clear_has_iv();
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsChapoly_Encryption_filterImpl();
};
// -------------------------------------------------------------------

class Chacha_Encryption_filter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Chacha_Encryption_filter) */ {
 public:
  Chacha_Encryption_filter();
  virtual ~Chacha_Encryption_filter();

  Chacha_Encryption_filter(const Chacha_Encryption_filter& from);

  inline Chacha_Encryption_filter& operator=(const Chacha_Encryption_filter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chacha_Encryption_filter(Chacha_Encryption_filter&& from) noexcept
    : Chacha_Encryption_filter() {
    *this = ::std::move(from);
  }

  inline Chacha_Encryption_filter& operator=(Chacha_Encryption_filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Chacha_Encryption_filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chacha_Encryption_filter* internal_default_instance() {
    return reinterpret_cast<const Chacha_Encryption_filter*>(
               &_Chacha_Encryption_filter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Chacha_Encryption_filter* other);
  void Swap(Chacha_Encryption_filter* other);
  friend void swap(Chacha_Encryption_filter& a, Chacha_Encryption_filter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chacha_Encryption_filter* New() const PROTOBUF_FINAL { return New(NULL); }

  Chacha_Encryption_filter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Chacha_Encryption_filter& from);
  void MergeFrom(const Chacha_Encryption_filter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Chacha_Encryption_filter* other);
  protected:
  explicit Chacha_Encryption_filter(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes iv = 1;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 1;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_iv();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_iv(
      ::std::string* iv);

  // optional bytes key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_key();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      ::std::string* key);

  // @@protoc_insertion_point(class_scope:proto.Chacha_Encryption_filter)
 private:
  void set_has_iv();
  void clear_has_iv();
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsChacha_Encryption_filterImpl();
};
// -------------------------------------------------------------------

class Filters : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Filters) */ {
 public:
  Filters();
  virtual ~Filters();

  Filters(const Filters& from);

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Filters(Filters&& from) noexcept
    : Filters() {
    *this = ::std::move(from);
  }

  inline Filters& operator=(Filters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Filters& default_instance();

  enum EncryptionCase {
    kChapolyEncryption = 2,
    kChachaEncryption = 3,
    ENCRYPTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filters* internal_default_instance() {
    return reinterpret_cast<const Filters*>(
               &_Filters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(Filters* other);
  void Swap(Filters* other);
  friend void swap(Filters& a, Filters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Filters* New() const PROTOBUF_FINAL { return New(NULL); }

  Filters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Filters* other);
  protected:
  explicit Filters(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ZSTD_Compression_filter zstd_compression = 1;
  bool has_zstd_compression() const;
  void clear_zstd_compression();
  static const int kZstdCompressionFieldNumber = 1;
  private:
  void _slow_mutable_zstd_compression();
  public:
  const ::proto::ZSTD_Compression_filter& zstd_compression() const;
  ::proto::ZSTD_Compression_filter* release_zstd_compression();
  ::proto::ZSTD_Compression_filter* mutable_zstd_compression();
  void set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression);
  void unsafe_arena_set_allocated_zstd_compression(
      ::proto::ZSTD_Compression_filter* zstd_compression);
  ::proto::ZSTD_Compression_filter* unsafe_arena_release_zstd_compression();

  // optional .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
  bool has_chapoly_encryption() const;
  void clear_chapoly_encryption();
  static const int kChapolyEncryptionFieldNumber = 2;
  private:
  void _slow_mutable_chapoly_encryption();
  public:
  const ::proto::Chapoly_Encryption_filter& chapoly_encryption() const;
  ::proto::Chapoly_Encryption_filter* release_chapoly_encryption();
  ::proto::Chapoly_Encryption_filter* mutable_chapoly_encryption();
  void set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption);
  void unsafe_arena_set_allocated_chapoly_encryption(
      ::proto::Chapoly_Encryption_filter* chapoly_encryption);
  ::proto::Chapoly_Encryption_filter* unsafe_arena_release_chapoly_encryption();

  // optional .proto.Chacha_Encryption_filter chacha_encryption = 3;
  bool has_chacha_encryption() const;
  void clear_chacha_encryption();
  static const int kChachaEncryptionFieldNumber = 3;
  private:
  void _slow_mutable_chacha_encryption();
  public:
  const ::proto::Chacha_Encryption_filter& chacha_encryption() const;
  ::proto::Chacha_Encryption_filter* release_chacha_encryption();
  ::proto::Chacha_Encryption_filter* mutable_chacha_encryption();
  void set_allocated_chacha_encryption(::proto::Chacha_Encryption_filter* chacha_encryption);
  void unsafe_arena_set_allocated_chacha_encryption(
      ::proto::Chacha_Encryption_filter* chacha_encryption);
  ::proto::Chacha_Encryption_filter* unsafe_arena_release_chacha_encryption();

  EncryptionCase encryption_case() const;
  // @@protoc_insertion_point(class_scope:proto.Filters)
 private:
  void set_has_zstd_compression();
  void clear_has_zstd_compression();
  void set_has_chapoly_encryption();
  void set_has_chacha_encryption();

  inline bool has_encryption() const;
  void clear_encryption();
  inline void clear_has_encryption();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::ZSTD_Compression_filter* zstd_compression_;
  union EncryptionUnion {
    EncryptionUnion() {}
    ::proto::Chapoly_Encryption_filter* chapoly_encryption_;
    ::proto::Chacha_Encryption_filter* chacha_encryption_;
  } encryption_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFiltersImpl();
};
// -------------------------------------------------------------------

class Ref_to_refcount : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_to_refcount) */ {
 public:
  Ref_to_refcount();
  virtual ~Ref_to_refcount();

  Ref_to_refcount(const Ref_to_refcount& from);

  inline Ref_to_refcount& operator=(const Ref_to_refcount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ref_to_refcount(Ref_to_refcount&& from) noexcept
    : Ref_to_refcount() {
    *this = ::std::move(from);
  }

  inline Ref_to_refcount& operator=(Ref_to_refcount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Ref_to_refcount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ref_to_refcount* internal_default_instance() {
    return reinterpret_cast<const Ref_to_refcount*>(
               &_Ref_to_refcount_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(Ref_to_refcount* other);
  void Swap(Ref_to_refcount* other);
  friend void swap(Ref_to_refcount& a, Ref_to_refcount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ref_to_refcount* New() const PROTOBUF_FINAL { return New(NULL); }

  Ref_to_refcount* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Ref_to_refcount& from);
  void MergeFrom(const Ref_to_refcount& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_to_refcount* other);
  protected:
  explicit Ref_to_refcount(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string content_fname = 1;
  bool has_content_fname() const;
  void clear_content_fname();
  static const int kContentFnameFieldNumber = 1;
  const ::std::string& content_fname() const;
  void set_content_fname(const ::std::string& value);
  #if LANG_CXX11
  void set_content_fname(::std::string&& value);
  #endif
  void set_content_fname(const char* value);
  void set_content_fname(const char* value, size_t size);
  ::std::string* mutable_content_fname();
  ::std::string* release_content_fname();
  void set_allocated_content_fname(::std::string* content_fname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_content_fname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_content_fname(
      ::std::string* content_fname);

  // required uint64 from = 2;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 2;
  ::google::protobuf::uint64 from() const;
  void set_from(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Ref_to_refcount)
 private:
  void set_has_content_fname();
  void clear_has_content_fname();
  void set_has_from();
  void clear_has_from();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr content_fname_;
  ::google::protobuf::uint64 from_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsRef_to_refcountImpl();
};
// -------------------------------------------------------------------

class Fs_record : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_record) */ {
 public:
  Fs_record();
  virtual ~Fs_record();

  Fs_record(const Fs_record& from);

  inline Fs_record& operator=(const Fs_record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fs_record(Fs_record&& from) noexcept
    : Fs_record() {
    *this = ::std::move(from);
  }

  inline Fs_record& operator=(Fs_record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Fs_record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fs_record* internal_default_instance() {
    return reinterpret_cast<const Fs_record*>(
               &_Fs_record_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(Fs_record* other);
  void Swap(Fs_record* other);
  friend void swap(Fs_record& a, Fs_record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fs_record* New() const PROTOBUF_FINAL { return New(NULL); }

  Fs_record* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Fs_record& from);
  void MergeFrom(const Fs_record& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_record* other);
  protected:
  explicit Fs_record(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pathname = 1;
  bool has_pathname() const;
  void clear_pathname();
  static const int kPathnameFieldNumber = 1;
  const ::std::string& pathname() const;
  void set_pathname(const ::std::string& value);
  #if LANG_CXX11
  void set_pathname(::std::string&& value);
  #endif
  void set_pathname(const char* value);
  void set_pathname(const char* value, size_t size);
  ::std::string* mutable_pathname();
  ::std::string* release_pathname();
  void set_allocated_pathname(::std::string* pathname);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_pathname();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_pathname(
      ::std::string* pathname);

  // optional string symlink_target = 5;
  bool has_symlink_target() const;
  void clear_symlink_target();
  static const int kSymlinkTargetFieldNumber = 5;
  const ::std::string& symlink_target() const;
  void set_symlink_target(const ::std::string& value);
  #if LANG_CXX11
  void set_symlink_target(::std::string&& value);
  #endif
  void set_symlink_target(const char* value);
  void set_symlink_target(const char* value, size_t size);
  ::std::string* mutable_symlink_target();
  ::std::string* release_symlink_target();
  void set_allocated_symlink_target(::std::string* symlink_target);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_symlink_target();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symlink_target(
      ::std::string* symlink_target);

  // optional string posix_acl = 7;
  bool has_posix_acl() const;
  void clear_posix_acl();
  static const int kPosixAclFieldNumber = 7;
  const ::std::string& posix_acl() const;
  void set_posix_acl(const ::std::string& value);
  #if LANG_CXX11
  void set_posix_acl(::std::string&& value);
  #endif
  void set_posix_acl(const char* value);
  void set_posix_acl(const char* value, size_t size);
  ::std::string* mutable_posix_acl();
  ::std::string* release_posix_acl();
  void set_allocated_posix_acl(::std::string* posix_acl);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_posix_acl();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_posix_acl(
      ::std::string* posix_acl);

  // optional string posix_default_acl = 8;
  bool has_posix_default_acl() const;
  void clear_posix_default_acl();
  static const int kPosixDefaultAclFieldNumber = 8;
  const ::std::string& posix_default_acl() const;
  void set_posix_default_acl(const ::std::string& value);
  #if LANG_CXX11
  void set_posix_default_acl(::std::string&& value);
  #endif
  void set_posix_default_acl(const char* value);
  void set_posix_default_acl(const char* value, size_t size);
  ::std::string* mutable_posix_default_acl();
  ::std::string* release_posix_default_acl();
  void set_allocated_posix_default_acl(::std::string* posix_default_acl);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_posix_default_acl();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_posix_default_acl(
      ::std::string* posix_default_acl);

  // optional .proto.Ref_to_refcount ref = 4;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 4;
  private:
  void _slow_mutable_ref();
  public:
  const ::proto::Ref_to_refcount& ref() const;
  ::proto::Ref_to_refcount* release_ref();
  ::proto::Ref_to_refcount* mutable_ref();
  void set_allocated_ref(::proto::Ref_to_refcount* ref);
  void unsafe_arena_set_allocated_ref(
      ::proto::Ref_to_refcount* ref);
  ::proto::Ref_to_refcount* unsafe_arena_release_ref();

  // optional uint64 modified_nanoseconds = 3;
  bool has_modified_nanoseconds() const;
  void clear_modified_nanoseconds();
  static const int kModifiedNanosecondsFieldNumber = 3;
  ::google::protobuf::uint64 modified_nanoseconds() const;
  void set_modified_nanoseconds(::google::protobuf::uint64 value);

  // required .proto.File_type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::proto::File_type type() const;
  void set_type(::proto::File_type value);

  // optional uint32 unix_permissions = 6;
  bool has_unix_permissions() const;
  void clear_unix_permissions();
  static const int kUnixPermissionsFieldNumber = 6;
  ::google::protobuf::uint32 unix_permissions() const;
  void set_unix_permissions(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.Fs_record)
 private:
  void set_has_pathname();
  void clear_has_pathname();
  void set_has_type();
  void clear_has_type();
  void set_has_modified_nanoseconds();
  void clear_has_modified_nanoseconds();
  void set_has_ref();
  void clear_has_ref();
  void set_has_symlink_target();
  void clear_has_symlink_target();
  void set_has_unix_permissions();
  void clear_has_unix_permissions();
  void set_has_posix_acl();
  void clear_has_posix_acl();
  void set_has_posix_default_acl();
  void clear_has_posix_default_acl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pathname_;
  ::google::protobuf::internal::ArenaStringPtr symlink_target_;
  ::google::protobuf::internal::ArenaStringPtr posix_acl_;
  ::google::protobuf::internal::ArenaStringPtr posix_default_acl_;
  ::proto::Ref_to_refcount* ref_;
  ::google::protobuf::uint64 modified_nanoseconds_;
  int type_;
  ::google::protobuf::uint32 unix_permissions_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFs_recordImpl();
};
// -------------------------------------------------------------------

class Fs_state : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Fs_state) */ {
 public:
  Fs_state();
  virtual ~Fs_state();

  Fs_state(const Fs_state& from);

  inline Fs_state& operator=(const Fs_state& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fs_state(Fs_state&& from) noexcept
    : Fs_state() {
    *this = ::std::move(from);
  }

  inline Fs_state& operator=(Fs_state&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Fs_state& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fs_state* internal_default_instance() {
    return reinterpret_cast<const Fs_state*>(
               &_Fs_state_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(Fs_state* other);
  void Swap(Fs_state* other);
  friend void swap(Fs_state& a, Fs_state& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fs_state* New() const PROTOBUF_FINAL { return New(NULL); }

  Fs_state* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Fs_state& from);
  void MergeFrom(const Fs_state& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fs_state* other);
  protected:
  explicit Fs_state(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Fs_record rec = 1;
  int rec_size() const;
  void clear_rec();
  static const int kRecFieldNumber = 1;
  const ::proto::Fs_record& rec(int index) const;
  ::proto::Fs_record* mutable_rec(int index);
  ::proto::Fs_record* add_rec();
  ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >*
      mutable_rec();
  const ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >&
      rec() const;

  // @@protoc_insertion_point(class_scope:proto.Fs_state)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::Fs_record > rec_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsFs_stateImpl();
};
// -------------------------------------------------------------------

class State_file : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.State_file) */ {
 public:
  State_file();
  virtual ~State_file();

  State_file(const State_file& from);

  inline State_file& operator=(const State_file& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State_file(State_file&& from) noexcept
    : State_file() {
    *this = ::std::move(from);
  }

  inline State_file& operator=(State_file&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const State_file& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_file* internal_default_instance() {
    return reinterpret_cast<const State_file*>(
               &_State_file_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(State_file* other);
  void Swap(State_file* other);
  friend void swap(State_file& a, State_file& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State_file* New() const PROTOBUF_FINAL { return New(NULL); }

  State_file* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const State_file& from);
  void MergeFrom(const State_file& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(State_file* other);
  protected:
  explicit State_file(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 1;
  private:
  void _slow_mutable_filters();
  public:
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // required uint64 time_created = 3;
  bool has_time_created() const;
  void clear_time_created();
  static const int kTimeCreatedFieldNumber = 3;
  ::google::protobuf::uint64 time_created() const;
  void set_time_created(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.State_file)
 private:
  void set_has_filters();
  void clear_has_filters();
  void set_has_name();
  void clear_has_name();
  void set_has_time_created();
  void clear_has_time_created();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::proto::Filters* filters_;
  ::google::protobuf::uint64 time_created_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsState_fileImpl();
};
// -------------------------------------------------------------------

class Content_file : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Content_file) */ {
 public:
  Content_file();
  virtual ~Content_file();

  Content_file(const Content_file& from);

  inline Content_file& operator=(const Content_file& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Content_file(Content_file&& from) noexcept
    : Content_file() {
    *this = ::std::move(from);
  }

  inline Content_file& operator=(Content_file&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Content_file& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Content_file* internal_default_instance() {
    return reinterpret_cast<const Content_file*>(
               &_Content_file_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(Content_file* other);
  void Swap(Content_file* other);
  friend void swap(Content_file& a, Content_file& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Content_file* New() const PROTOBUF_FINAL { return New(NULL); }

  Content_file* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Content_file& from);
  void MergeFrom(const Content_file& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Content_file* other);
  protected:
  explicit Content_file(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Ref_count refs = 3;
  int refs_size() const;
  void clear_refs();
  static const int kRefsFieldNumber = 3;
  const ::proto::Ref_count& refs(int index) const;
  ::proto::Ref_count* mutable_refs(int index);
  ::proto::Ref_count* add_refs();
  ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >*
      mutable_refs();
  const ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >&
      refs() const;

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 1;
  private:
  void _slow_mutable_filters();
  public:
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:proto.Content_file)
 private:
  void set_has_filters();
  void clear_has_filters();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::Ref_count > refs_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::proto::Filters* filters_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsContent_fileImpl();
};
// -------------------------------------------------------------------

class Ref_count : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Ref_count) */ {
 public:
  Ref_count();
  virtual ~Ref_count();

  Ref_count(const Ref_count& from);

  inline Ref_count& operator=(const Ref_count& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ref_count(Ref_count&& from) noexcept
    : Ref_count() {
    *this = ::std::move(from);
  }

  inline Ref_count& operator=(Ref_count&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Ref_count& default_instance();

  enum CsumCase {
    kXxhash = 5,
    kBlake2B = 6,
    CSUM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ref_count* internal_default_instance() {
    return reinterpret_cast<const Ref_count*>(
               &_Ref_count_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(Ref_count* other);
  void Swap(Ref_count* other);
  friend void swap(Ref_count& a, Ref_count& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ref_count* New() const PROTOBUF_FINAL { return New(NULL); }

  Ref_count* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Ref_count& from);
  void MergeFrom(const Ref_count& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ref_count* other);
  protected:
  explicit Ref_count(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  ::google::protobuf::uint64 from() const;
  void set_from(::google::protobuf::uint64 value);

  // required uint64 to = 2;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  ::google::protobuf::uint64 to() const;
  void set_to(::google::protobuf::uint64 value);

  // required uint64 ref_count = 3;
  bool has_ref_count() const;
  void clear_ref_count();
  static const int kRefCountFieldNumber = 3;
  ::google::protobuf::uint64 ref_count() const;
  void set_ref_count(::google::protobuf::uint64 value);

  // required uint64 space_taken = 4;
  bool has_space_taken() const;
  void clear_space_taken();
  static const int kSpaceTakenFieldNumber = 4;
  ::google::protobuf::uint64 space_taken() const;
  void set_space_taken(::google::protobuf::uint64 value);

  // optional uint64 xxhash = 5;
  bool has_xxhash() const;
  void clear_xxhash();
  static const int kXxhashFieldNumber = 5;
  ::google::protobuf::uint64 xxhash() const;
  void set_xxhash(::google::protobuf::uint64 value);

  // optional bytes blake2b = 6;
  bool has_blake2b() const;
  void clear_blake2b();
  static const int kBlake2BFieldNumber = 6;
  const ::std::string& blake2b() const;
  void set_blake2b(const ::std::string& value);
  #if LANG_CXX11
  void set_blake2b(::std::string&& value);
  #endif
  void set_blake2b(const char* value);
  void set_blake2b(const void* value, size_t size);
  ::std::string* mutable_blake2b();
  ::std::string* release_blake2b();
  void set_allocated_blake2b(::std::string* blake2b);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_blake2b();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_blake2b(
      ::std::string* blake2b);

  CsumCase csum_case() const;
  // @@protoc_insertion_point(class_scope:proto.Ref_count)
 private:
  void set_has_from();
  void clear_has_from();
  void set_has_to();
  void clear_has_to();
  void set_has_ref_count();
  void clear_has_ref_count();
  void set_has_space_taken();
  void clear_has_space_taken();
  void set_has_xxhash();
  void set_has_blake2b();

  inline bool has_csum() const;
  void clear_csum();
  inline void clear_has_csum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 from_;
  ::google::protobuf::uint64 to_;
  ::google::protobuf::uint64 ref_count_;
  ::google::protobuf::uint64 space_taken_;
  union CsumUnion {
    CsumUnion() {}
    ::google::protobuf::uint64 xxhash_;
    ::google::protobuf::internal::ArenaStringPtr blake2b_;
  } csum_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsRef_countImpl();
};
// -------------------------------------------------------------------

class Catalogue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalogue) */ {
 public:
  Catalogue();
  virtual ~Catalogue();

  Catalogue(const Catalogue& from);

  inline Catalogue& operator=(const Catalogue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Catalogue(Catalogue&& from) noexcept
    : Catalogue() {
    *this = ::std::move(from);
  }

  inline Catalogue& operator=(Catalogue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Catalogue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Catalogue* internal_default_instance() {
    return reinterpret_cast<const Catalogue*>(
               &_Catalogue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(Catalogue* other);
  void Swap(Catalogue* other);
  friend void swap(Catalogue& a, Catalogue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Catalogue* New() const PROTOBUF_FINAL { return New(NULL); }

  Catalogue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Catalogue& from);
  void MergeFrom(const Catalogue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalogue* other);
  protected:
  explicit Catalogue(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.State_file state_files = 1;
  int state_files_size() const;
  void clear_state_files();
  static const int kStateFilesFieldNumber = 1;
  const ::proto::State_file& state_files(int index) const;
  ::proto::State_file* mutable_state_files(int index);
  ::proto::State_file* add_state_files();
  ::google::protobuf::RepeatedPtrField< ::proto::State_file >*
      mutable_state_files();
  const ::google::protobuf::RepeatedPtrField< ::proto::State_file >&
      state_files() const;

  // repeated .proto.Content_file content_files = 2;
  int content_files_size() const;
  void clear_content_files();
  static const int kContentFilesFieldNumber = 2;
  const ::proto::Content_file& content_files(int index) const;
  ::proto::Content_file* mutable_content_files(int index);
  ::proto::Content_file* add_content_files();
  ::google::protobuf::RepeatedPtrField< ::proto::Content_file >*
      mutable_content_files();
  const ::google::protobuf::RepeatedPtrField< ::proto::Content_file >&
      content_files() const;

  // @@protoc_insertion_point(class_scope:proto.Catalogue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::State_file > state_files_;
  ::google::protobuf::RepeatedPtrField< ::proto::Content_file > content_files_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsCatalogueImpl();
};
// -------------------------------------------------------------------

class Catalog_header : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Catalog_header) */ {
 public:
  Catalog_header();
  virtual ~Catalog_header();

  Catalog_header(const Catalog_header& from);

  inline Catalog_header& operator=(const Catalog_header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Catalog_header(Catalog_header&& from) noexcept
    : Catalog_header() {
    *this = ::std::move(from);
  }

  inline Catalog_header& operator=(Catalog_header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const Catalog_header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Catalog_header* internal_default_instance() {
    return reinterpret_cast<const Catalog_header*>(
               &_Catalog_header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(Catalog_header* other);
  void Swap(Catalog_header* other);
  friend void swap(Catalog_header& a, Catalog_header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Catalog_header* New() const PROTOBUF_FINAL { return New(NULL); }

  Catalog_header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Catalog_header& from);
  void MergeFrom(const Catalog_header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalog_header* other);
  protected:
  explicit Catalog_header(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.Filters filters = 1;
  bool has_filters() const;
  void clear_filters();
  static const int kFiltersFieldNumber = 1;
  private:
  void _slow_mutable_filters();
  public:
  const ::proto::Filters& filters() const;
  ::proto::Filters* release_filters();
  ::proto::Filters* mutable_filters();
  void set_allocated_filters(::proto::Filters* filters);
  void unsafe_arena_set_allocated_filters(
      ::proto::Filters* filters);
  ::proto::Filters* unsafe_arena_release_filters();

  // @@protoc_insertion_point(class_scope:proto.Catalog_header)
 private:
  void set_has_filters();
  void clear_has_filters();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::proto::Filters* filters_;
  friend struct ::protobuf_format_2eproto::TableStruct;
  friend void ::protobuf_format_2eproto::InitDefaultsCatalog_headerImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ZSTD_Compression_filter

// -------------------------------------------------------------------

// Chapoly_Encryption_filter

// required bytes iv = 1;
inline bool Chapoly_Encryption_filter::has_iv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Chapoly_Encryption_filter::set_has_iv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Chapoly_Encryption_filter::clear_has_iv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Chapoly_Encryption_filter::clear_iv() {
  iv_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_iv();
}
inline const ::std::string& Chapoly_Encryption_filter::iv() const {
  // @@protoc_insertion_point(field_get:proto.Chapoly_Encryption_filter.iv)
  return iv_.Get();
}
inline void Chapoly_Encryption_filter::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Chapoly_Encryption_filter.iv)
}
#if LANG_CXX11
inline void Chapoly_Encryption_filter::set_iv(::std::string&& value) {
  set_has_iv();
  iv_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Chapoly_Encryption_filter.iv)
}
#endif
inline void Chapoly_Encryption_filter::set_iv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iv();
  iv_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Chapoly_Encryption_filter.iv)
}
inline void Chapoly_Encryption_filter::set_iv(const void* value,
    size_t size) {
  set_has_iv();
  iv_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Chapoly_Encryption_filter.iv)
}
inline ::std::string* Chapoly_Encryption_filter::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:proto.Chapoly_Encryption_filter.iv)
  return iv_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Chapoly_Encryption_filter::release_iv() {
  // @@protoc_insertion_point(field_release:proto.Chapoly_Encryption_filter.iv)
  clear_has_iv();
  return iv_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Chapoly_Encryption_filter.iv)
}
inline ::std::string* Chapoly_Encryption_filter::unsafe_arena_release_iv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Chapoly_Encryption_filter.iv)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_iv();
  return iv_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::unsafe_arena_set_allocated_iv(
    ::std::string* iv) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      iv, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Chapoly_Encryption_filter.iv)
}

// optional bytes key = 2;
inline bool Chapoly_Encryption_filter::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Chapoly_Encryption_filter::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Chapoly_Encryption_filter::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Chapoly_Encryption_filter::clear_key() {
  key_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_key();
}
inline const ::std::string& Chapoly_Encryption_filter::key() const {
  // @@protoc_insertion_point(field_get:proto.Chapoly_Encryption_filter.key)
  return key_.Get();
}
inline void Chapoly_Encryption_filter::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Chapoly_Encryption_filter.key)
}
#if LANG_CXX11
inline void Chapoly_Encryption_filter::set_key(::std::string&& value) {
  set_has_key();
  key_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Chapoly_Encryption_filter.key)
}
#endif
inline void Chapoly_Encryption_filter::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Chapoly_Encryption_filter.key)
}
inline void Chapoly_Encryption_filter::set_key(const void* value,
    size_t size) {
  set_has_key();
  key_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Chapoly_Encryption_filter.key)
}
inline ::std::string* Chapoly_Encryption_filter::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:proto.Chapoly_Encryption_filter.key)
  return key_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Chapoly_Encryption_filter::release_key() {
  // @@protoc_insertion_point(field_release:proto.Chapoly_Encryption_filter.key)
  clear_has_key();
  return key_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Chapoly_Encryption_filter.key)
}
inline ::std::string* Chapoly_Encryption_filter::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Chapoly_Encryption_filter.key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_key();
  return key_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Chapoly_Encryption_filter::unsafe_arena_set_allocated_key(
    ::std::string* key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Chapoly_Encryption_filter.key)
}

// -------------------------------------------------------------------

// Chacha_Encryption_filter

// required bytes iv = 1;
inline bool Chacha_Encryption_filter::has_iv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Chacha_Encryption_filter::set_has_iv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Chacha_Encryption_filter::clear_has_iv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Chacha_Encryption_filter::clear_iv() {
  iv_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_iv();
}
inline const ::std::string& Chacha_Encryption_filter::iv() const {
  // @@protoc_insertion_point(field_get:proto.Chacha_Encryption_filter.iv)
  return iv_.Get();
}
inline void Chacha_Encryption_filter::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Chacha_Encryption_filter.iv)
}
#if LANG_CXX11
inline void Chacha_Encryption_filter::set_iv(::std::string&& value) {
  set_has_iv();
  iv_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Chacha_Encryption_filter.iv)
}
#endif
inline void Chacha_Encryption_filter::set_iv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iv();
  iv_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Chacha_Encryption_filter.iv)
}
inline void Chacha_Encryption_filter::set_iv(const void* value,
    size_t size) {
  set_has_iv();
  iv_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Chacha_Encryption_filter.iv)
}
inline ::std::string* Chacha_Encryption_filter::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:proto.Chacha_Encryption_filter.iv)
  return iv_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Chacha_Encryption_filter::release_iv() {
  // @@protoc_insertion_point(field_release:proto.Chacha_Encryption_filter.iv)
  clear_has_iv();
  return iv_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Chacha_Encryption_filter.iv)
}
inline ::std::string* Chacha_Encryption_filter::unsafe_arena_release_iv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Chacha_Encryption_filter.iv)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_iv();
  return iv_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::unsafe_arena_set_allocated_iv(
    ::std::string* iv) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      iv, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Chacha_Encryption_filter.iv)
}

// optional bytes key = 2;
inline bool Chacha_Encryption_filter::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Chacha_Encryption_filter::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Chacha_Encryption_filter::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Chacha_Encryption_filter::clear_key() {
  key_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_key();
}
inline const ::std::string& Chacha_Encryption_filter::key() const {
  // @@protoc_insertion_point(field_get:proto.Chacha_Encryption_filter.key)
  return key_.Get();
}
inline void Chacha_Encryption_filter::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Chacha_Encryption_filter.key)
}
#if LANG_CXX11
inline void Chacha_Encryption_filter::set_key(::std::string&& value) {
  set_has_key();
  key_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Chacha_Encryption_filter.key)
}
#endif
inline void Chacha_Encryption_filter::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Chacha_Encryption_filter.key)
}
inline void Chacha_Encryption_filter::set_key(const void* value,
    size_t size) {
  set_has_key();
  key_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Chacha_Encryption_filter.key)
}
inline ::std::string* Chacha_Encryption_filter::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:proto.Chacha_Encryption_filter.key)
  return key_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Chacha_Encryption_filter::release_key() {
  // @@protoc_insertion_point(field_release:proto.Chacha_Encryption_filter.key)
  clear_has_key();
  return key_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Chacha_Encryption_filter.key)
}
inline ::std::string* Chacha_Encryption_filter::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Chacha_Encryption_filter.key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_key();
  return key_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Chacha_Encryption_filter::unsafe_arena_set_allocated_key(
    ::std::string* key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Chacha_Encryption_filter.key)
}

// -------------------------------------------------------------------

// Filters

// optional .proto.ZSTD_Compression_filter zstd_compression = 1;
inline bool Filters::has_zstd_compression() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filters::set_has_zstd_compression() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filters::clear_has_zstd_compression() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filters::clear_zstd_compression() {
  if (zstd_compression_ != NULL) zstd_compression_->Clear();
  clear_has_zstd_compression();
}
inline const ::proto::ZSTD_Compression_filter& Filters::zstd_compression() const {
  const ::proto::ZSTD_Compression_filter* p = zstd_compression_;
  // @@protoc_insertion_point(field_get:proto.Filters.zstd_compression)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::ZSTD_Compression_filter*>(
      &::proto::_ZSTD_Compression_filter_default_instance_);
}
inline ::proto::ZSTD_Compression_filter* Filters::release_zstd_compression() {
  // @@protoc_insertion_point(field_release:proto.Filters.zstd_compression)
  clear_has_zstd_compression();
  ::proto::ZSTD_Compression_filter* temp = zstd_compression_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  zstd_compression_ = NULL;
  return temp;
}
inline ::proto::ZSTD_Compression_filter* Filters::unsafe_arena_release_zstd_compression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Filters.zstd_compression)
  clear_has_zstd_compression();
  ::proto::ZSTD_Compression_filter* temp = zstd_compression_;
  zstd_compression_ = NULL;
  return temp;
}
inline ::proto::ZSTD_Compression_filter* Filters::mutable_zstd_compression() {
  set_has_zstd_compression();
  if (zstd_compression_ == NULL) {
    _slow_mutable_zstd_compression();
  }
  // @@protoc_insertion_point(field_mutable:proto.Filters.zstd_compression)
  return zstd_compression_;
}
inline void Filters::set_allocated_zstd_compression(::proto::ZSTD_Compression_filter* zstd_compression) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zstd_compression_;
  }
  if (zstd_compression) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(zstd_compression);
    if (message_arena != submessage_arena) {
      zstd_compression = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zstd_compression, submessage_arena);
    }
    set_has_zstd_compression();
  } else {
    clear_has_zstd_compression();
  }
  zstd_compression_ = zstd_compression;
  // @@protoc_insertion_point(field_set_allocated:proto.Filters.zstd_compression)
}

// optional .proto.Chapoly_Encryption_filter chapoly_encryption = 2;
inline bool Filters::has_chapoly_encryption() const {
  return encryption_case() == kChapolyEncryption;
}
inline void Filters::set_has_chapoly_encryption() {
  _oneof_case_[0] = kChapolyEncryption;
}
inline void Filters::clear_chapoly_encryption() {
  if (has_chapoly_encryption()) {
    if (GetArenaNoVirtual() == NULL) {
      delete encryption_.chapoly_encryption_;
    }
    clear_has_encryption();
  }
}
inline ::proto::Chapoly_Encryption_filter* Filters::release_chapoly_encryption() {
  // @@protoc_insertion_point(field_release:proto.Filters.chapoly_encryption)
  if (has_chapoly_encryption()) {
    clear_has_encryption();
      ::proto::Chapoly_Encryption_filter* temp = encryption_.chapoly_encryption_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    encryption_.chapoly_encryption_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::proto::Chapoly_Encryption_filter& Filters::chapoly_encryption() const {
  // @@protoc_insertion_point(field_get:proto.Filters.chapoly_encryption)
  return has_chapoly_encryption()
      ? *encryption_.chapoly_encryption_
      : *reinterpret_cast< ::proto::Chapoly_Encryption_filter*>(&::proto::_Chapoly_Encryption_filter_default_instance_);
}
inline ::proto::Chapoly_Encryption_filter* Filters::unsafe_arena_release_chapoly_encryption() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Filters.chapoly_encryption)
  if (has_chapoly_encryption()) {
    clear_has_encryption();
    ::proto::Chapoly_Encryption_filter* temp = encryption_.chapoly_encryption_;
    encryption_.chapoly_encryption_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Filters::unsafe_arena_set_allocated_chapoly_encryption(::proto::Chapoly_Encryption_filter* chapoly_encryption) {
  clear_encryption();
  if (chapoly_encryption) {
    set_has_chapoly_encryption();
    encryption_.chapoly_encryption_ = chapoly_encryption;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Filters.chapoly_encryption)
}
inline ::proto::Chapoly_Encryption_filter* Filters::mutable_chapoly_encryption() {
  if (!has_chapoly_encryption()) {
    clear_encryption();
    set_has_chapoly_encryption();
    encryption_.chapoly_encryption_ = 
      ::google::protobuf::Arena::CreateMessage< ::proto::Chapoly_Encryption_filter >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.Filters.chapoly_encryption)
  return encryption_.chapoly_encryption_;
}

// optional .proto.Chacha_Encryption_filter chacha_encryption = 3;
inline bool Filters::has_chacha_encryption() const {
  return encryption_case() == kChachaEncryption;
}
inline void Filters::set_has_chacha_encryption() {
  _oneof_case_[0] = kChachaEncryption;
}
inline void Filters::clear_chacha_encryption() {
  if (has_chacha_encryption()) {
    if (GetArenaNoVirtual() == NULL) {
      delete encryption_.chacha_encryption_;
    }
    clear_has_encryption();
  }
}
inline ::proto::Chacha_Encryption_filter* Filters::release_chacha_encryption() {
  // @@protoc_insertion_point(field_release:proto.Filters.chacha_encryption)
  if (has_chacha_encryption()) {
    clear_has_encryption();
      ::proto::Chacha_Encryption_filter* temp = encryption_.chacha_encryption_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    encryption_.chacha_encryption_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::proto::Chacha_Encryption_filter& Filters::chacha_encryption() const {
  // @@protoc_insertion_point(field_get:proto.Filters.chacha_encryption)
  return has_chacha_encryption()
      ? *encryption_.chacha_encryption_
      : *reinterpret_cast< ::proto::Chacha_Encryption_filter*>(&::proto::_Chacha_Encryption_filter_default_instance_);
}
inline ::proto::Chacha_Encryption_filter* Filters::unsafe_arena_release_chacha_encryption() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Filters.chacha_encryption)
  if (has_chacha_encryption()) {
    clear_has_encryption();
    ::proto::Chacha_Encryption_filter* temp = encryption_.chacha_encryption_;
    encryption_.chacha_encryption_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Filters::unsafe_arena_set_allocated_chacha_encryption(::proto::Chacha_Encryption_filter* chacha_encryption) {
  clear_encryption();
  if (chacha_encryption) {
    set_has_chacha_encryption();
    encryption_.chacha_encryption_ = chacha_encryption;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Filters.chacha_encryption)
}
inline ::proto::Chacha_Encryption_filter* Filters::mutable_chacha_encryption() {
  if (!has_chacha_encryption()) {
    clear_encryption();
    set_has_chacha_encryption();
    encryption_.chacha_encryption_ = 
      ::google::protobuf::Arena::CreateMessage< ::proto::Chacha_Encryption_filter >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:proto.Filters.chacha_encryption)
  return encryption_.chacha_encryption_;
}

inline bool Filters::has_encryption() const {
  return encryption_case() != ENCRYPTION_NOT_SET;
}
inline void Filters::clear_has_encryption() {
  _oneof_case_[0] = ENCRYPTION_NOT_SET;
}
inline Filters::EncryptionCase Filters::encryption_case() const {
  return Filters::EncryptionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ref_to_refcount

// required string content_fname = 1;
inline bool Ref_to_refcount::has_content_fname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ref_to_refcount::set_has_content_fname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ref_to_refcount::clear_has_content_fname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ref_to_refcount::clear_content_fname() {
  content_fname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_content_fname();
}
inline const ::std::string& Ref_to_refcount::content_fname() const {
  // @@protoc_insertion_point(field_get:proto.Ref_to_refcount.content_fname)
  return content_fname_.Get();
}
inline void Ref_to_refcount::set_content_fname(const ::std::string& value) {
  set_has_content_fname();
  content_fname_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Ref_to_refcount.content_fname)
}
#if LANG_CXX11
inline void Ref_to_refcount::set_content_fname(::std::string&& value) {
  set_has_content_fname();
  content_fname_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Ref_to_refcount.content_fname)
}
#endif
inline void Ref_to_refcount::set_content_fname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content_fname();
  content_fname_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Ref_to_refcount.content_fname)
}
inline void Ref_to_refcount::set_content_fname(const char* value,
    size_t size) {
  set_has_content_fname();
  content_fname_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Ref_to_refcount.content_fname)
}
inline ::std::string* Ref_to_refcount::mutable_content_fname() {
  set_has_content_fname();
  // @@protoc_insertion_point(field_mutable:proto.Ref_to_refcount.content_fname)
  return content_fname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Ref_to_refcount::release_content_fname() {
  // @@protoc_insertion_point(field_release:proto.Ref_to_refcount.content_fname)
  clear_has_content_fname();
  return content_fname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Ref_to_refcount::set_allocated_content_fname(::std::string* content_fname) {
  if (content_fname != NULL) {
    set_has_content_fname();
  } else {
    clear_has_content_fname();
  }
  content_fname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content_fname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Ref_to_refcount.content_fname)
}
inline ::std::string* Ref_to_refcount::unsafe_arena_release_content_fname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Ref_to_refcount.content_fname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_content_fname();
  return content_fname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Ref_to_refcount::unsafe_arena_set_allocated_content_fname(
    ::std::string* content_fname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (content_fname != NULL) {
    set_has_content_fname();
  } else {
    clear_has_content_fname();
  }
  content_fname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      content_fname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Ref_to_refcount.content_fname)
}

// required uint64 from = 2;
inline bool Ref_to_refcount::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ref_to_refcount::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ref_to_refcount::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ref_to_refcount::clear_from() {
  from_ = GOOGLE_ULONGLONG(0);
  clear_has_from();
}
inline ::google::protobuf::uint64 Ref_to_refcount::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_to_refcount.from)
  return from_;
}
inline void Ref_to_refcount::set_from(::google::protobuf::uint64 value) {
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_to_refcount.from)
}

// -------------------------------------------------------------------

// Fs_record

// required string pathname = 1;
inline bool Fs_record::has_pathname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fs_record::set_has_pathname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fs_record::clear_has_pathname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fs_record::clear_pathname() {
  pathname_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_pathname();
}
inline const ::std::string& Fs_record::pathname() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.pathname)
  return pathname_.Get();
}
inline void Fs_record::set_pathname(const ::std::string& value) {
  set_has_pathname();
  pathname_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Fs_record.pathname)
}
#if LANG_CXX11
inline void Fs_record::set_pathname(::std::string&& value) {
  set_has_pathname();
  pathname_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.pathname)
}
#endif
inline void Fs_record::set_pathname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pathname();
  pathname_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.pathname)
}
inline void Fs_record::set_pathname(const char* value,
    size_t size) {
  set_has_pathname();
  pathname_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.pathname)
}
inline ::std::string* Fs_record::mutable_pathname() {
  set_has_pathname();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.pathname)
  return pathname_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Fs_record::release_pathname() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.pathname)
  clear_has_pathname();
  return pathname_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Fs_record::set_allocated_pathname(::std::string* pathname) {
  if (pathname != NULL) {
    set_has_pathname();
  } else {
    clear_has_pathname();
  }
  pathname_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pathname,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.pathname)
}
inline ::std::string* Fs_record::unsafe_arena_release_pathname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.pathname)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_pathname();
  return pathname_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Fs_record::unsafe_arena_set_allocated_pathname(
    ::std::string* pathname) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (pathname != NULL) {
    set_has_pathname();
  } else {
    clear_has_pathname();
  }
  pathname_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      pathname, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.pathname)
}

// required .proto.File_type type = 2;
inline bool Fs_record::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Fs_record::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Fs_record::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Fs_record::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::File_type Fs_record::type() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.type)
  return static_cast< ::proto::File_type >(type_);
}
inline void Fs_record::set_type(::proto::File_type value) {
  assert(::proto::File_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.type)
}

// optional uint64 modified_nanoseconds = 3;
inline bool Fs_record::has_modified_nanoseconds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Fs_record::set_has_modified_nanoseconds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Fs_record::clear_has_modified_nanoseconds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Fs_record::clear_modified_nanoseconds() {
  modified_nanoseconds_ = GOOGLE_ULONGLONG(0);
  clear_has_modified_nanoseconds();
}
inline ::google::protobuf::uint64 Fs_record::modified_nanoseconds() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.modified_nanoseconds)
  return modified_nanoseconds_;
}
inline void Fs_record::set_modified_nanoseconds(::google::protobuf::uint64 value) {
  set_has_modified_nanoseconds();
  modified_nanoseconds_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.modified_nanoseconds)
}

// optional .proto.Ref_to_refcount ref = 4;
inline bool Fs_record::has_ref() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fs_record::set_has_ref() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Fs_record::clear_has_ref() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Fs_record::clear_ref() {
  if (ref_ != NULL) ref_->Clear();
  clear_has_ref();
}
inline const ::proto::Ref_to_refcount& Fs_record::ref() const {
  const ::proto::Ref_to_refcount* p = ref_;
  // @@protoc_insertion_point(field_get:proto.Fs_record.ref)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Ref_to_refcount*>(
      &::proto::_Ref_to_refcount_default_instance_);
}
inline ::proto::Ref_to_refcount* Fs_record::release_ref() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.ref)
  clear_has_ref();
  ::proto::Ref_to_refcount* temp = ref_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  ref_ = NULL;
  return temp;
}
inline ::proto::Ref_to_refcount* Fs_record::unsafe_arena_release_ref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.ref)
  clear_has_ref();
  ::proto::Ref_to_refcount* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline ::proto::Ref_to_refcount* Fs_record::mutable_ref() {
  set_has_ref();
  if (ref_ == NULL) {
    _slow_mutable_ref();
  }
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.ref)
  return ref_;
}
inline void Fs_record::set_allocated_ref(::proto::Ref_to_refcount* ref) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ref_;
  }
  if (ref) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(ref);
    if (message_arena != submessage_arena) {
      ref = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ref, submessage_arena);
    }
    set_has_ref();
  } else {
    clear_has_ref();
  }
  ref_ = ref;
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.ref)
}

// optional string symlink_target = 5;
inline bool Fs_record::has_symlink_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fs_record::set_has_symlink_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Fs_record::clear_has_symlink_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Fs_record::clear_symlink_target() {
  symlink_target_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_symlink_target();
}
inline const ::std::string& Fs_record::symlink_target() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.symlink_target)
  return symlink_target_.Get();
}
inline void Fs_record::set_symlink_target(const ::std::string& value) {
  set_has_symlink_target();
  symlink_target_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Fs_record.symlink_target)
}
#if LANG_CXX11
inline void Fs_record::set_symlink_target(::std::string&& value) {
  set_has_symlink_target();
  symlink_target_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.symlink_target)
}
#endif
inline void Fs_record::set_symlink_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symlink_target();
  symlink_target_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.symlink_target)
}
inline void Fs_record::set_symlink_target(const char* value,
    size_t size) {
  set_has_symlink_target();
  symlink_target_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.symlink_target)
}
inline ::std::string* Fs_record::mutable_symlink_target() {
  set_has_symlink_target();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.symlink_target)
  return symlink_target_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Fs_record::release_symlink_target() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.symlink_target)
  clear_has_symlink_target();
  return symlink_target_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Fs_record::set_allocated_symlink_target(::std::string* symlink_target) {
  if (symlink_target != NULL) {
    set_has_symlink_target();
  } else {
    clear_has_symlink_target();
  }
  symlink_target_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symlink_target,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.symlink_target)
}
inline ::std::string* Fs_record::unsafe_arena_release_symlink_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.symlink_target)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_symlink_target();
  return symlink_target_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Fs_record::unsafe_arena_set_allocated_symlink_target(
    ::std::string* symlink_target) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (symlink_target != NULL) {
    set_has_symlink_target();
  } else {
    clear_has_symlink_target();
  }
  symlink_target_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      symlink_target, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.symlink_target)
}

// optional uint32 unix_permissions = 6;
inline bool Fs_record::has_unix_permissions() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Fs_record::set_has_unix_permissions() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Fs_record::clear_has_unix_permissions() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Fs_record::clear_unix_permissions() {
  unix_permissions_ = 0u;
  clear_has_unix_permissions();
}
inline ::google::protobuf::uint32 Fs_record::unix_permissions() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.unix_permissions)
  return unix_permissions_;
}
inline void Fs_record::set_unix_permissions(::google::protobuf::uint32 value) {
  set_has_unix_permissions();
  unix_permissions_ = value;
  // @@protoc_insertion_point(field_set:proto.Fs_record.unix_permissions)
}

// optional string posix_acl = 7;
inline bool Fs_record::has_posix_acl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fs_record::set_has_posix_acl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Fs_record::clear_has_posix_acl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Fs_record::clear_posix_acl() {
  posix_acl_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_posix_acl();
}
inline const ::std::string& Fs_record::posix_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_acl)
  return posix_acl_.Get();
}
inline void Fs_record::set_posix_acl(const ::std::string& value) {
  set_has_posix_acl();
  posix_acl_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_acl)
}
#if LANG_CXX11
inline void Fs_record::set_posix_acl(::std::string&& value) {
  set_has_posix_acl();
  posix_acl_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.posix_acl)
}
#endif
inline void Fs_record::set_posix_acl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_posix_acl();
  posix_acl_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.posix_acl)
}
inline void Fs_record::set_posix_acl(const char* value,
    size_t size) {
  set_has_posix_acl();
  posix_acl_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.posix_acl)
}
inline ::std::string* Fs_record::mutable_posix_acl() {
  set_has_posix_acl();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_acl)
  return posix_acl_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Fs_record::release_posix_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_acl)
  clear_has_posix_acl();
  return posix_acl_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Fs_record::set_allocated_posix_acl(::std::string* posix_acl) {
  if (posix_acl != NULL) {
    set_has_posix_acl();
  } else {
    clear_has_posix_acl();
  }
  posix_acl_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), posix_acl,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_acl)
}
inline ::std::string* Fs_record::unsafe_arena_release_posix_acl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.posix_acl)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_posix_acl();
  return posix_acl_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Fs_record::unsafe_arena_set_allocated_posix_acl(
    ::std::string* posix_acl) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (posix_acl != NULL) {
    set_has_posix_acl();
  } else {
    clear_has_posix_acl();
  }
  posix_acl_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      posix_acl, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.posix_acl)
}

// optional string posix_default_acl = 8;
inline bool Fs_record::has_posix_default_acl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fs_record::set_has_posix_default_acl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Fs_record::clear_has_posix_default_acl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Fs_record::clear_posix_default_acl() {
  posix_default_acl_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_posix_default_acl();
}
inline const ::std::string& Fs_record::posix_default_acl() const {
  // @@protoc_insertion_point(field_get:proto.Fs_record.posix_default_acl)
  return posix_default_acl_.Get();
}
inline void Fs_record::set_posix_default_acl(const ::std::string& value) {
  set_has_posix_default_acl();
  posix_default_acl_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Fs_record.posix_default_acl)
}
#if LANG_CXX11
inline void Fs_record::set_posix_default_acl(::std::string&& value) {
  set_has_posix_default_acl();
  posix_default_acl_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Fs_record.posix_default_acl)
}
#endif
inline void Fs_record::set_posix_default_acl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_posix_default_acl();
  posix_default_acl_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Fs_record.posix_default_acl)
}
inline void Fs_record::set_posix_default_acl(const char* value,
    size_t size) {
  set_has_posix_default_acl();
  posix_default_acl_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Fs_record.posix_default_acl)
}
inline ::std::string* Fs_record::mutable_posix_default_acl() {
  set_has_posix_default_acl();
  // @@protoc_insertion_point(field_mutable:proto.Fs_record.posix_default_acl)
  return posix_default_acl_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Fs_record::release_posix_default_acl() {
  // @@protoc_insertion_point(field_release:proto.Fs_record.posix_default_acl)
  clear_has_posix_default_acl();
  return posix_default_acl_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Fs_record::set_allocated_posix_default_acl(::std::string* posix_default_acl) {
  if (posix_default_acl != NULL) {
    set_has_posix_default_acl();
  } else {
    clear_has_posix_default_acl();
  }
  posix_default_acl_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), posix_default_acl,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Fs_record.posix_default_acl)
}
inline ::std::string* Fs_record::unsafe_arena_release_posix_default_acl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Fs_record.posix_default_acl)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_posix_default_acl();
  return posix_default_acl_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Fs_record::unsafe_arena_set_allocated_posix_default_acl(
    ::std::string* posix_default_acl) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (posix_default_acl != NULL) {
    set_has_posix_default_acl();
  } else {
    clear_has_posix_default_acl();
  }
  posix_default_acl_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      posix_default_acl, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Fs_record.posix_default_acl)
}

// -------------------------------------------------------------------

// Fs_state

// repeated .proto.Fs_record rec = 1;
inline int Fs_state::rec_size() const {
  return rec_.size();
}
inline void Fs_state::clear_rec() {
  rec_.Clear();
}
inline const ::proto::Fs_record& Fs_state::rec(int index) const {
  // @@protoc_insertion_point(field_get:proto.Fs_state.rec)
  return rec_.Get(index);
}
inline ::proto::Fs_record* Fs_state::mutable_rec(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Fs_state.rec)
  return rec_.Mutable(index);
}
inline ::proto::Fs_record* Fs_state::add_rec() {
  // @@protoc_insertion_point(field_add:proto.Fs_state.rec)
  return rec_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >*
Fs_state::mutable_rec() {
  // @@protoc_insertion_point(field_mutable_list:proto.Fs_state.rec)
  return &rec_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Fs_record >&
Fs_state::rec() const {
  // @@protoc_insertion_point(field_list:proto.Fs_state.rec)
  return rec_;
}

// -------------------------------------------------------------------

// State_file

// optional .proto.Filters filters = 1;
inline bool State_file::has_filters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State_file::set_has_filters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State_file::clear_has_filters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State_file::clear_filters() {
  if (filters_ != NULL) filters_->Clear();
  clear_has_filters();
}
inline const ::proto::Filters& State_file::filters() const {
  const ::proto::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:proto.State_file.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline ::proto::Filters* State_file::release_filters() {
  // @@protoc_insertion_point(field_release:proto.State_file.filters)
  clear_has_filters();
  ::proto::Filters* temp = filters_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* State_file::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.State_file.filters)
  clear_has_filters();
  ::proto::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* State_file::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) {
    _slow_mutable_filters();
  }
  // @@protoc_insertion_point(field_mutable:proto.State_file.filters)
  return filters_;
}
inline void State_file::set_allocated_filters(::proto::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filters_;
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    set_has_filters();
  } else {
    clear_has_filters();
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.State_file.filters)
}

// required string name = 2;
inline bool State_file::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State_file::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State_file::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State_file::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& State_file::name() const {
  // @@protoc_insertion_point(field_get:proto.State_file.name)
  return name_.Get();
}
inline void State_file::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.State_file.name)
}
#if LANG_CXX11
inline void State_file::set_name(::std::string&& value) {
  set_has_name();
  name_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.State_file.name)
}
#endif
inline void State_file::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.State_file.name)
}
inline void State_file::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.State_file.name)
}
inline ::std::string* State_file::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:proto.State_file.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* State_file::release_name() {
  // @@protoc_insertion_point(field_release:proto.State_file.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void State_file::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.State_file.name)
}
inline ::std::string* State_file::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.State_file.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void State_file::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.State_file.name)
}

// required uint64 time_created = 3;
inline bool State_file::has_time_created() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State_file::set_has_time_created() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State_file::clear_has_time_created() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State_file::clear_time_created() {
  time_created_ = GOOGLE_ULONGLONG(0);
  clear_has_time_created();
}
inline ::google::protobuf::uint64 State_file::time_created() const {
  // @@protoc_insertion_point(field_get:proto.State_file.time_created)
  return time_created_;
}
inline void State_file::set_time_created(::google::protobuf::uint64 value) {
  set_has_time_created();
  time_created_ = value;
  // @@protoc_insertion_point(field_set:proto.State_file.time_created)
}

// -------------------------------------------------------------------

// Content_file

// optional .proto.Filters filters = 1;
inline bool Content_file::has_filters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Content_file::set_has_filters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Content_file::clear_has_filters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Content_file::clear_filters() {
  if (filters_ != NULL) filters_->Clear();
  clear_has_filters();
}
inline const ::proto::Filters& Content_file::filters() const {
  const ::proto::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:proto.Content_file.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline ::proto::Filters* Content_file::release_filters() {
  // @@protoc_insertion_point(field_release:proto.Content_file.filters)
  clear_has_filters();
  ::proto::Filters* temp = filters_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* Content_file::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Content_file.filters)
  clear_has_filters();
  ::proto::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* Content_file::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) {
    _slow_mutable_filters();
  }
  // @@protoc_insertion_point(field_mutable:proto.Content_file.filters)
  return filters_;
}
inline void Content_file::set_allocated_filters(::proto::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filters_;
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    set_has_filters();
  } else {
    clear_has_filters();
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.Content_file.filters)
}

// required string name = 2;
inline bool Content_file::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Content_file::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Content_file::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Content_file::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& Content_file::name() const {
  // @@protoc_insertion_point(field_get:proto.Content_file.name)
  return name_.Get();
}
inline void Content_file::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Content_file.name)
}
#if LANG_CXX11
inline void Content_file::set_name(::std::string&& value) {
  set_has_name();
  name_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Content_file.name)
}
#endif
inline void Content_file::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Content_file.name)
}
inline void Content_file::set_name(const char* value,
    size_t size) {
  set_has_name();
  name_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Content_file.name)
}
inline ::std::string* Content_file::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:proto.Content_file.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Content_file::release_name() {
  // @@protoc_insertion_point(field_release:proto.Content_file.name)
  clear_has_name();
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Content_file::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:proto.Content_file.name)
}
inline ::std::string* Content_file::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Content_file.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Content_file::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Content_file.name)
}

// repeated .proto.Ref_count refs = 3;
inline int Content_file::refs_size() const {
  return refs_.size();
}
inline void Content_file::clear_refs() {
  refs_.Clear();
}
inline const ::proto::Ref_count& Content_file::refs(int index) const {
  // @@protoc_insertion_point(field_get:proto.Content_file.refs)
  return refs_.Get(index);
}
inline ::proto::Ref_count* Content_file::mutable_refs(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Content_file.refs)
  return refs_.Mutable(index);
}
inline ::proto::Ref_count* Content_file::add_refs() {
  // @@protoc_insertion_point(field_add:proto.Content_file.refs)
  return refs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >*
Content_file::mutable_refs() {
  // @@protoc_insertion_point(field_mutable_list:proto.Content_file.refs)
  return &refs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Ref_count >&
Content_file::refs() const {
  // @@protoc_insertion_point(field_list:proto.Content_file.refs)
  return refs_;
}

// -------------------------------------------------------------------

// Ref_count

// required uint64 from = 1;
inline bool Ref_count::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ref_count::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ref_count::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ref_count::clear_from() {
  from_ = GOOGLE_ULONGLONG(0);
  clear_has_from();
}
inline ::google::protobuf::uint64 Ref_count::from() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.from)
  return from_;
}
inline void Ref_count::set_from(::google::protobuf::uint64 value) {
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.from)
}

// required uint64 to = 2;
inline bool Ref_count::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ref_count::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ref_count::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ref_count::clear_to() {
  to_ = GOOGLE_ULONGLONG(0);
  clear_has_to();
}
inline ::google::protobuf::uint64 Ref_count::to() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.to)
  return to_;
}
inline void Ref_count::set_to(::google::protobuf::uint64 value) {
  set_has_to();
  to_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.to)
}

// required uint64 ref_count = 3;
inline bool Ref_count::has_ref_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ref_count::set_has_ref_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ref_count::clear_has_ref_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ref_count::clear_ref_count() {
  ref_count_ = GOOGLE_ULONGLONG(0);
  clear_has_ref_count();
}
inline ::google::protobuf::uint64 Ref_count::ref_count() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.ref_count)
  return ref_count_;
}
inline void Ref_count::set_ref_count(::google::protobuf::uint64 value) {
  set_has_ref_count();
  ref_count_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.ref_count)
}

// required uint64 space_taken = 4;
inline bool Ref_count::has_space_taken() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ref_count::set_has_space_taken() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ref_count::clear_has_space_taken() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ref_count::clear_space_taken() {
  space_taken_ = GOOGLE_ULONGLONG(0);
  clear_has_space_taken();
}
inline ::google::protobuf::uint64 Ref_count::space_taken() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.space_taken)
  return space_taken_;
}
inline void Ref_count::set_space_taken(::google::protobuf::uint64 value) {
  set_has_space_taken();
  space_taken_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.space_taken)
}

// optional uint64 xxhash = 5;
inline bool Ref_count::has_xxhash() const {
  return csum_case() == kXxhash;
}
inline void Ref_count::set_has_xxhash() {
  _oneof_case_[0] = kXxhash;
}
inline void Ref_count::clear_xxhash() {
  if (has_xxhash()) {
    csum_.xxhash_ = GOOGLE_ULONGLONG(0);
    clear_has_csum();
  }
}
inline ::google::protobuf::uint64 Ref_count::xxhash() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.xxhash)
  if (has_xxhash()) {
    return csum_.xxhash_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void Ref_count::set_xxhash(::google::protobuf::uint64 value) {
  if (!has_xxhash()) {
    clear_csum();
    set_has_xxhash();
  }
  csum_.xxhash_ = value;
  // @@protoc_insertion_point(field_set:proto.Ref_count.xxhash)
}

// optional bytes blake2b = 6;
inline bool Ref_count::has_blake2b() const {
  return csum_case() == kBlake2B;
}
inline void Ref_count::set_has_blake2b() {
  _oneof_case_[0] = kBlake2B;
}
inline void Ref_count::clear_blake2b() {
  if (has_blake2b()) {
    csum_.blake2b_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_csum();
  }
}
inline const ::std::string& Ref_count::blake2b() const {
  // @@protoc_insertion_point(field_get:proto.Ref_count.blake2b)
  if (has_blake2b()) {
    return csum_.blake2b_.Get();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Ref_count::set_blake2b(const ::std::string& value) {
  if (!has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  csum_.blake2b_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:proto.Ref_count.blake2b)
}
#if LANG_CXX11
inline void Ref_count::set_blake2b(::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.Ref_count.blake2b)
  if (!has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  csum_.blake2b_.SetLite(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:proto.Ref_count.blake2b)
}
#endif
inline void Ref_count::set_blake2b(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  csum_.blake2b_.SetLite(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:proto.Ref_count.blake2b)
}
inline void Ref_count::set_blake2b(const void* value,
                             size_t size) {
  if (!has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  csum_.blake2b_.SetLite(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:proto.Ref_count.blake2b)
}
inline ::std::string* Ref_count::mutable_blake2b() {
  if (!has_blake2b()) {
    clear_csum();
    set_has_blake2b();
    csum_.blake2b_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return csum_.blake2b_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:proto.Ref_count.blake2b)
}
inline ::std::string* Ref_count::release_blake2b() {
  // @@protoc_insertion_point(field_release:proto.Ref_count.blake2b)
  if (has_blake2b()) {
    clear_has_csum();
    return csum_.blake2b_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void Ref_count::set_allocated_blake2b(::std::string* blake2b) {
  if (!has_blake2b()) {
    csum_.blake2b_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_csum();
  if (blake2b != NULL) {
    set_has_blake2b();
    csum_.blake2b_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blake2b,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Ref_count.blake2b)
}
inline ::std::string* Ref_count::unsafe_arena_release_blake2b() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Ref_count.blake2b)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_blake2b()) {
    clear_has_csum();
    return csum_.blake2b_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void Ref_count::unsafe_arena_set_allocated_blake2b(::std::string* blake2b) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_blake2b()) {
    csum_.blake2b_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_csum();
  if (blake2b) {
    set_has_blake2b();
    csum_.blake2b_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blake2b, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Ref_count.blake2b)
}

inline bool Ref_count::has_csum() const {
  return csum_case() != CSUM_NOT_SET;
}
inline void Ref_count::clear_has_csum() {
  _oneof_case_[0] = CSUM_NOT_SET;
}
inline Ref_count::CsumCase Ref_count::csum_case() const {
  return Ref_count::CsumCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Catalogue

// repeated .proto.State_file state_files = 1;
inline int Catalogue::state_files_size() const {
  return state_files_.size();
}
inline void Catalogue::clear_state_files() {
  state_files_.Clear();
}
inline const ::proto::State_file& Catalogue::state_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.state_files)
  return state_files_.Get(index);
}
inline ::proto::State_file* Catalogue::mutable_state_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.state_files)
  return state_files_.Mutable(index);
}
inline ::proto::State_file* Catalogue::add_state_files() {
  // @@protoc_insertion_point(field_add:proto.Catalogue.state_files)
  return state_files_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::State_file >*
Catalogue::mutable_state_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.state_files)
  return &state_files_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::State_file >&
Catalogue::state_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.state_files)
  return state_files_;
}

// repeated .proto.Content_file content_files = 2;
inline int Catalogue::content_files_size() const {
  return content_files_.size();
}
inline void Catalogue::clear_content_files() {
  content_files_.Clear();
}
inline const ::proto::Content_file& Catalogue::content_files(int index) const {
  // @@protoc_insertion_point(field_get:proto.Catalogue.content_files)
  return content_files_.Get(index);
}
inline ::proto::Content_file* Catalogue::mutable_content_files(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Catalogue.content_files)
  return content_files_.Mutable(index);
}
inline ::proto::Content_file* Catalogue::add_content_files() {
  // @@protoc_insertion_point(field_add:proto.Catalogue.content_files)
  return content_files_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Content_file >*
Catalogue::mutable_content_files() {
  // @@protoc_insertion_point(field_mutable_list:proto.Catalogue.content_files)
  return &content_files_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Content_file >&
Catalogue::content_files() const {
  // @@protoc_insertion_point(field_list:proto.Catalogue.content_files)
  return content_files_;
}

// -------------------------------------------------------------------

// Catalog_header

// optional .proto.Filters filters = 1;
inline bool Catalog_header::has_filters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Catalog_header::set_has_filters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Catalog_header::clear_has_filters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Catalog_header::clear_filters() {
  if (filters_ != NULL) filters_->Clear();
  clear_has_filters();
}
inline const ::proto::Filters& Catalog_header::filters() const {
  const ::proto::Filters* p = filters_;
  // @@protoc_insertion_point(field_get:proto.Catalog_header.filters)
  return p != NULL ? *p : *reinterpret_cast<const ::proto::Filters*>(
      &::proto::_Filters_default_instance_);
}
inline ::proto::Filters* Catalog_header::release_filters() {
  // @@protoc_insertion_point(field_release:proto.Catalog_header.filters)
  clear_has_filters();
  ::proto::Filters* temp = filters_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* Catalog_header::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Catalog_header.filters)
  clear_has_filters();
  ::proto::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline ::proto::Filters* Catalog_header::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) {
    _slow_mutable_filters();
  }
  // @@protoc_insertion_point(field_mutable:proto.Catalog_header.filters)
  return filters_;
}
inline void Catalog_header::set_allocated_filters(::proto::Filters* filters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filters_;
  }
  if (filters) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    set_has_filters();
  } else {
    clear_has_filters();
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:proto.Catalog_header.filters)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::File_type> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_format_2eproto__INCLUDED
